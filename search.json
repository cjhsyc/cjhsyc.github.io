[{"title":"Echarts的容器宽高使用rem，渲染出的图表很小的问题","url":"/2022/03/06/Echarts%E7%9A%84%E5%AE%B9%E5%99%A8%E5%AE%BD%E9%AB%98%E4%BD%BF%E7%94%A8rem%EF%BC%8C%E6%B8%B2%E6%9F%93%E5%87%BA%E7%9A%84%E5%9B%BE%E8%A1%A8%E5%BE%88%E5%B0%8F%E7%9A%84%E9%97%AE%E9%A2%98/","content":"主要是因为div还没有创建出来echarts就已经加载了，因为获取不到宽高，所以会缩小在一起。参考了几篇文章，我在echarts配置后加入如下代码，解决了问题：\nmyChart.setOption(option); //延迟resize setTimeout(function ()&#123;\t myChart.resize() &#125;,200)//随屏幕大小改变 window.addEventListener(&#x27;resize&#x27;,function()&#123;\t myChart.resize() &#125;)\nCSDN:https://blog.csdn.net/cjhsyc/article/details/122584331参考文章：https://www.cnblogs.com/xxxx0130/p/14182677.htmlhttps://blog.csdn.net/weixin_40180205/article/details/106116073\n","categories":["数据可视化","Echarts"],"tags":["Echarts"]},{"title":"js严格模式","url":"/2022/03/09/js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","content":"严格模式使用严格模式&quot;use strict&quot;\n\n变量a = 10console.log(a)//严格模式报错（必须使用var等声明变量）\n\n静默失败 &#x3D;&gt; 报错var b = 2console.log(Object.getOwnPropertyDescriptor(window, &#x27;b&#x27;))/*configurable: false //var声明的变量默认不可删除enumerable: truevalue: 2writable: true*/delete b//未删除，非严格模式下不报错，程序继续进行（静默失败）//严格模式下报错console.log(b)//2\n\n函数参数唯一function test(a,a)&#123;    console.log(a)//undefined(第二个a),严格模式报错&#125;test(10)\n\n实参和形参的映射关系不存在function test1(a) &#123;    a = 20    console.log(arguments[0])//非严格模式:20,严格模式:10&#125;test1(10)function test2(a = 20) &#123;//参数设置初始后自动开启严格模式    a = 30    console.log(arguments[0])//10&#125;test2(10)\n\n函数的this默认指向undefinedfunction test()&#123;    console.log(this)//undefined&#125;test()\n\n不能使用arguments.callee和callerfunction test()&#123;    console.log(arguments.callee === test)//true,严格模式无法使用    console.log(test.caller === out)//true,严格模式无法使用&#125;function out()&#123;    test()&#125;out()\n\n不能使用eval()和with()eval(&#x27;var a=2&#x27;)console.log(a)//2,严格模式无法使用const obj=&#123;    a:3&#125;function test()&#123;    with (obj) &#123;//改变this指向        console.log(a)//3,严格模式无法使用    &#125;&#125;test()\n\neval和arguments不能作为标识符let eval=&#x27;111&#x27;//严格模式报错\n\n\n\n\n\n\n\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"less预处理语言","url":"/2022/03/08/less%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%AD%E8%A8%80/","content":"变量声明和使用//定义变量@color: red;@var: a;@attr: color;@&#123;var&#125; &#123; //作为选择器或者属性名需要添加大括号    @&#123;attr&#125;: @color; //作为属性值直接使用&#125;@btn: &#123;    width: 100px;    height: 40px;    background-color: aqua;&#125;.btn &#123;    @btn(); //需要括号&#125;    @url: &#x27;https://cdn.jsdelivr.net/gh/cjhsyc/image-hosting@master/头像.677yiujw5980.webp&#x27;;.img&#123;    background-image: url(&quot;@&#123;url&#125;&quot;); //作为url使用    background-size: 100px;    width: 100px;    height: 100px;&#125;\n\n运算可以使用+、-、*、&#x2F;进行运算\n@a: 100px + 20px; //120px@b: @a*2; //240px@c: #666/2; //#333\n\n嵌套.parent&#123;    width: 100px;    height: 100px;    border: 1px solid gray;    .child&#123;        background-color: skyblue;        @media (min-width: 900px)&#123;            background-color: pink;        &#125;        @media (min-width: 500px) and (max-width: 900px)&#123;            background-color: greenyellow;        &#125;    &#125;&#125;\n\n相当于\n.parent &#123;  width: 100px;  height: 100px;  border: 1px solid gray;&#125;.parent .child &#123;  background-color: skyblue;&#125;@media (min-width: 900px) &#123;    .parent .child &#123;        background-color: pink;    &#125;&#125;@media (min-width: 500px) and (max-width: 900px) &#123;    .parent .child &#123;        background-color: greenyellow;    &#125;&#125;\n\n混合.mixins &#123;    border: 2px solid skyblue;    width: 300px;    height: 30px;&#125;.box &#123;    .mixins(); //括号可加可不加&#125;\n\n函数使用函数自定义一个绘制三角形的函数\n.triangle(top,@color:black,@height:50px) &#123;    border-color: transparent transparent @color transparent;&#125;.triangle(left,@color:black,@height:50px) &#123;    border-color: transparent @color transparent transparent;&#125;.triangle(bottom,@color:black,@height:50px) &#123;    border-color: @color transparent transparent transparent;&#125;.triangle(right,@color:black,@height:50px) &#123;    border-color: transparent transparent transparent @color;&#125;.triangle(@dir,@color:black,@height:50px) &#123;//@dir用来匹配第一个参数，后面的参数都要一致    width: 0;    height: 0;    border-width: @height;    border-style: solid;&#125;.triangleBox &#123;    .triangle(top,red);//绘制尖朝上的三角形,后两个参数不写则使用默认值&#125;\n\n命名空间和逻辑判断#card&#123;    //when:进行逻辑判断    //not:取反,and:且,或运算使用逗号    .border(@width,@color,@style) when not(@width &gt; 30px) , (@color &gt;= #666) and (@style = solid)&#123;        border: @width @style @color;    &#125;&#125;#main &#123;    //调用其他作用域的函数（ &#x27;&gt;&#x27; 可以省略 ）    #card &gt; .border(40px, #666, solid); //符合条件才生效    //#card.border(40px, #666, solid);//效果同上&#125;\n\n不定参数.boxShadow(@a,@b,...)&#123;//不定参数    box-shadow: @arguments;//@arguments:所有的参数,包括@a,@b    width: 200px;&#125;#box1&#123;    .boxShadow(0,0,10px,gray);&#125;#box2&#123;    .boxShadow(inset,0,0,5px,gray);&#125;\n\n循环//循环（递归调用函数）.columns(@n,@i:1) when (@i &lt;= @n) &#123;    .column-@&#123;i&#125; &#123;        width: @i*100% / @n;        height: 20px;        background-color: pink;    &#125;    .columns(@n, @i+1)&#125;.columns(4);\n\n属性合并.bg&#123;    width: 200px;    height: 200px;    //+ :属性用逗号隔开    //+_ :属性用空格隔开    background+: #666666;    background+_: url(&quot;@&#123;url&#125;&quot;);    background+_: no-repeat;    background+_: center;    box-shadow+: 0 0 5px greenyellow;    box-shadow+: 0 0 10px #000;    background-size: 100px;&#125;\n\n相当于\n.bg &#123;  width: 200px;  height: 200px;  background: #666666 url(&quot;@&#123;url&#125;&quot;) no-repeat center;  box-shadow: 0 0 5px greenyellow,0 0 10px #000;  background-size: 100px;&#125;\n\n继承.linkBtn &#123;    display: block;    width: 200px;    height: 80px;&#125;.linkBtn &#123;    color: white;    background-color: skyblue;&#125;.link:extend(.linkBtn) &#123;    text-decoration: none;    border: 4px solid orange;&#125;\n\n使用混合也可以实现相同的效果，但混合是相当于把代码再复制一份，而继承不是，上述代码转CSS如下：\n.linkBtn,.link &#123;  display: block;  width: 200px;  height: 80px;&#125;.linkBtn,.link &#123;  color: white;  background-color: skyblue;&#125;.link &#123;  text-decoration: none;  border: 4px solid orange;&#125;\n\n导入导入其他less文件\n@import &quot;./assets/style.less&quot;@import (reference) &quot;./assets/style.less&quot;//添加reference后，未被调用的代码不加载\n\n\n\n参考视频\n","categories":["样式","less"],"tags":["less"]},{"title":"webpack配置","url":"/2022/03/07/webpack%E9%85%8D%E7%BD%AE/","content":"webpack.config.js入口和出口文件const path = require(&#x27;path&#x27;)//引入path模块module.exports = &#123;    entry: &#x27;./src/index.js&#x27;,//打包的入口文件    output: &#123;//出口        filename: &quot;bundle.js&quot;,//出口文件名        path: path.resolve(__dirname, &quot;./dist&quot;),//出口文件路径需要绝对路径        clean: true,//打包前清理dist文件夹    &#125;&#125;\n\n生成HTML文件安装html-webpack-plugin插件\nnpm i html-webpack-plugin -D\n\n该模块用于自动生成HTML文件。在webpack.config.js中引入：\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); //通过 npm 安装\n\n通过plugins配置插件：\nplugins: [    new HtmlWebpackPlugin(&#123;//可不传配置项（默认配置）        template: &quot;./index.html&quot;,//以index.html为模板生成html文件        filename: &quot;app.html&quot;,        inject: &#x27;body&#x27;,//指定script标签写在body标签中（默认为head）    &#125;)]\n\n代码有修改后自动打包：\nwebpack --watch\n\n开发环境安装webpack-dev-server插件\nnpm i webpack-dev-server -D\n\n//开发模式mode: &quot;development&quot;,devtool: &#x27;inline-source-map&#x27;,//精确显示代码位置（比如报错时）devServer: &#123;//开发服务器    static:&#x27;./dist&#x27;&#125;,\n\n命令行执行：\nwebpack-dev-server\n\n无需打包，通过浏览器访问8080端口实时查看页面效果\n资源模块Resource资源加载资源导出url\nmodule:&#123;    rules: [        &#123;            test:/\\.png$/,//匹配.png文件            type: &quot;asset/resource&quot;,//加载资源导出url            generator: &#123;//指定打包的路径（可省略）                filename: &#x27;images/[contenthash][ext]&#x27;//[contenthash]:哈希值作为文件名，[ext]:扩展名            &#125;        &#125;    ]&#125;\n\n示例：在index.js中导入png图片\nimport imgsrc from &#x27;../asset/微信.png&#x27;//图片url(http://localhost:8080/images/a2769eaec65049f8919b.png)const img = document.createElement(&#x27;img&#x27;)img.src = imgsrcdocument.body.appendChild(img)\n\n也可再output中使用assetModuleFilename指定打包路径，优先级低于rules中的配置\noutput: &#123;//出口    filename: &quot;bundle.js&quot;,//出口文件名    path: path.resolve(__dirname, &quot;./dist&quot;),//出口文件路径需要绝对路径    clean: true,//打包前清理dist文件夹    assetModuleFilename: &quot;images/[contenthash][ext]&quot;,//[contenthash]:哈希值作为文件名，[ext]:扩展名&#125;,\n\ninline资源导出为Data URL base64格式\n&#123;    test: /\\.svg$/,    type: &quot;asset/inline&quot;,//导出为Data URL base64格式&#125;,\n\n示例：导入svg图片\nimport logoSvg from &#x27;./asset/logo.svg&#x27;//(data:image/svg+xml;base64,PHN2ZyB4bWxucz......)const img2 = document.createElement(&#x27;img&#x27;)img2.src = logoSvgimg2.style.cssText=&#x27;width:400px;height:600px&#x27;document.body.appendChild(img2)\n\nsource资源导出文件源码\n&#123;    test: /\\.txt$/,    type: &quot;asset/source&quot;,//导出文件源码&#125;\n\n示例：导入源码\nimport helloTxt from &#x27;./asset/hello.txt&#x27;//txt的文本内容const block = document.createElement(&#x27;div&#x27;)block.style.cssText = &#x27;width:200px;height:200px;border:1px solid gray&#x27;block.textContent = helloTxtdocument.body.appendChild(block)\n\n通用资源类型自动选择资源类型，小于maxSize用inline类型，大于则用resource类型\n&#123;    test: /\\.jpg$/,    type: &quot;asset&quot;,//自动选择资源类型，小于maxSize用inline类型，大于则用resource类型    parser: &#123;//自定义条件（可省略）        dataUrlCondition:&#123;            maxSize: 4 * 1024//默认为4 * 1024        &#125;    &#125;&#125;\n\n示例：导入jpg图片\nimport jpgMap from &#x27;./asset/头像.jpg&#x27;//因为大于4k所以是url格式const block = document.createElement(&#x27;div&#x27;)block.style.cssText = &#x27;width:200px;height:200px;border:1px solid gray&#x27;block.textContent = helloTxtdocument.body.appendChild(block)\n\nloader加载CSS安装loader\nnpm i css-loader -Dnpm i style-loader -D\n\n在module &gt; rules中配置\n&#123;    test: /\\.css$/,    //css-loader写在style-loader后面，先加载    //如果需要CSS预处理语言，安装相应的loader，写在css-loader后面    use: [&#x27;style-loader&#x27;,&#x27;css-loader&#x27;],//css-loader允许打包css文件，style-loader将样式加到html页面上&#125;\n\n抽离和压缩CSS安装插件\nnpm i mini-css-extract-plugin -Dnpm i css-minimizer-webpack-plugin -D\n\n引入插件\nconst MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)const CssMinimizerPlugin = require(&#x27;css-minimizer-webpack-plugin&#x27;)\n\n在plugin中使用MiniCssExtractPlugin（用于以link标签的形式在html中导入css文件）\nnew MiniCssExtractPlugin(&#123;\tfilename:&#x27;styles/[contenthash].css&#x27;//自定义打包路径&#125;)\n\n&#123;    test: /\\.css$/,    //&#x27;style-loader&#x27;换为MiniCssExtractPlugin    use: [MiniCssExtractPlugin.loader,&#x27;css-loader&#x27;],//css-loader允许打包css文件，style-loader将样式加到html页面上&#125;\n\n新配置项optimization中使用CssMinimizerPlugin（用于压缩css文件）\noptimization: &#123;    minimizer: [        new CssMinimizerPlugin()    ]&#125;,mode:&#x27;production&#x27;//生产环境下才会压缩（会有其他报错）\n\nbabel-loader如果浏览器不支持ES6语法，使用babel-loader，将ES6转为ES5\n安装babel-loader，@babel&#x2F;core，@babel&#x2F;preset-env\nnpm i babel-loader @babel/core @babel/preset-env -Dnpm i @babel/runtime -Dnpm i @babel/plugin-transform-runtime -D\n\nmodule &gt; rules中配置\n&#123;    test:/\\.js$/,    exclude: /node_modules/,//排除node_modules中的js文件    use:&#123;        loader:&#x27;babel-loader&#x27;,        options: &#123;            presets:[&#x27;@babel/preset-env&#x27;],            plugins: [                [                    &#x27;@babel/plugin-transform-runtime&#x27;                ]            ]        &#125;    &#125;&#125;\n\n代码分离多入口entry中设置多入口文件，修改output中的filename\nentry: &#123;    //两个文件都引入了lodash模块    index: &#x27;./src/index.js&#x27;,    another: &#x27;./src/another.js&#x27;&#125;,//打包的入口文件output: &#123;//出口    filename: &quot;[name].bundle.js&quot;,//出口文件名（[name]:入口文件的键值）    path: path.resolve(__dirname, &quot;./dist&quot;),//出口文件路径需要绝对路径    clean: true,//打包前清理dist文件夹    assetModuleFilename: &quot;images/[contenthash][ext]&quot;,//[contenthash]:哈希值作为文件名，[ext]:扩展名&#125;,\n\n防止重复optimization: &#123;    splitChunks: &#123;        chunks: &quot;all&quot;//自动抽离公共代码模块    &#125;&#125;\n","categories":["工程化"],"tags":["webpack"]},{"title":"实用网站","url":"/2022/03/22/%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99/","content":"面试题前端面试web前端面试 - 面试官系列\n大厂面试题每日一题\n","categories":["网站"],"tags":["面试题"]},{"title":"数据可视化","url":"/2022/03/20/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/","content":"canvascanvas基本使用canvas标签\n &lt;!--canvas：画布，html5新增--&gt;&lt;!--有默认宽高：300 * 150--&gt;&lt;!--浏览器默认canvas标签是一张图片--&gt;&lt;!--给canvas添加文本和子节点无效--&gt;&lt;!--需要通过js操作画布显示内容--&gt;&lt;!--不要通过样式设置canvas的宽高，而通过标签的属性来设置--&gt;&lt;canvas width=&quot;500px&quot; height=&quot;300px&quot;&gt;&lt;/canvas&gt;\n\n通过js操作canvas\nlet canvas = document.querySelector(&#x27;canvas&#x27;)// 获取画布上下文let ctx = canvas.getContext(&#x27;2d&#x27;)// 绘制线段(起点)ctx.moveTo(100, 200)ctx.lineTo(200, 250)//终点（第二个点）ctx.lineTo(150, 300)//第三点ctx.closePath()//连接起点和第三个点ctx.fillStyle = &#x27;red&#x27;//设置填充的颜色ctx.fill()//填充ctx.strokeStyle = &#x27;blue&#x27;//设置线段颜色ctx.lineWidth = &#x27;5&#x27;//设置线段宽度ctx.stroke()//画出线/三角形边框\n\n绘制矩形const canvas = document.querySelector(&#x27;canvas&#x27;)const ctx = canvas.getContext(&#x27;2d&#x27;)//绘制矩形：参数为 左上点坐标和宽高ctx.strokeRect(100,200,300,100)//填充矩形：默认黑色ctx.fillRect(100,400,300,100)\n\n绘制圆形const canvas = document.querySelector(&#x27;canvas&#x27;)const ctx = canvas.getContext(&#x27;2d&#x27;)//开始绘制圆形ctx.beginPath()//画圆:arc(x,y,r,sAngle,eAngle,counterclockwise);//x,y:圆心，r：半径，sAngle：起始弧度，eAngle：结束弧度，(0到2PI绘制一个完整的圆)//counterclockwise：可选。规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针。ctx.arc(300, 200, 100, 0, 2 * Math.PI)//设置填充颜色ctx.fillStyle = &#x27;red&#x27;ctx.fill()//完成绘制ctx.stroke()\n\n清除画布与绘制文字const canvas = document.querySelector(&#x27;canvas&#x27;)const ctx = canvas.getContext(&#x27;2d&#x27;)ctx.fillRect(200,100,300,200)//清除画布(一个矩形范围内)ctx.clearRect(0,0,700,500)//设置字体ctx.font=&#x27;20px 微软雅黑&#x27;ctx.fillStyle=&#x27;red&#x27;//文字颜色//绘制文字(参数：文本内容和起始位置)ctx.fillText(&#x27;数据可视化&#x27;,50,20)\n\nsvg基本使用&lt;!--默认宽高：300*150,可通过样式设置宽高--&gt;&lt;!--在svg内部使用相应的标签绘图--&gt;&lt;svg class=&quot;box&quot;&gt;  &lt;!--画线:属性包括两点的坐标，stroke：线的颜色（必选），stroke-width：线的宽度--&gt;  &lt;line x1=&quot;100&quot; y1=&quot;100&quot; x2=&quot;200&quot; y2=&quot;300&quot; stroke=&quot;red&quot; stroke-width=&quot;5&quot;&gt;&lt;/line&gt;  &lt;!--折线：points：各个点的坐标--&gt;  &lt;!--会自动填充颜色（黑色），fill-opacity：填充颜色透明度--&gt;  &lt;polyline points=&quot;300 300,50 100,120 400&quot; stroke=&quot;green&quot; fill-opacity=&quot;0&quot;&gt;&lt;/polyline&gt;  &lt;!--矩形：默认填充黑色,fill:设置填充颜色--&gt;  &lt;rect x=&quot;400&quot; y=&quot;200&quot; width=&quot;150&quot; height=&quot;50&quot; fill=&quot;pink&quot;&gt;&lt;/rect&gt;  &lt;!--圆形：自动填充黑色，style：设置样式，r：半径，cx、cy：圆心坐标--&gt;  &lt;circle r=&quot;50&quot; cx=&quot;100&quot; cy=&quot;100&quot; style=&quot;stroke: skyblue;fill: none&quot;&gt;&lt;/circle&gt;  &lt;!--椭圆：rx：水平半径，ry：垂直半径--&gt;  &lt;ellipse rx=&quot;100&quot; ry=&quot;50&quot; cx=&quot;400&quot; cy=&quot;400&quot; style=&quot;stroke: skyblue;fill: none&quot;&gt;&lt;/ellipse&gt;  &lt;!--多边形--&gt;  &lt;polygon points=&quot;300 100,400 200,350 300&quot; stroke=&quot;blue&quot; fill=&quot;none&quot;&gt;&lt;/polygon&gt;  &lt;!--任意图形--&gt;  &lt;!--d:M:起点，L：线终点，Z：连接起点--&gt;  &lt;path d=&quot;M 10 10 L 120 70 L 30 140 L 60 340 L 432 110 Z&quot; fill=&quot;none&quot; stroke=&quot;red&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n\nEChartsECharts官网\n引入ECharts&lt;!--引入ECharts--&gt;&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/echarts/5.3.1/echarts.min.js&quot;&gt;&lt;/script&gt;\n\n基本使用&lt;!--准备一个容器--&gt;&lt;div style=&quot;width: 800px;height: 500px&quot; id=&quot;main&quot;&gt;&lt;/div&gt;\n\n绘制柱状图\nmyCharts.setOption(&#123;  //标题  title:&#123;    text:&#x27;数据可视化&#x27;,//主标题    subtext:&#x27;echarts基本使用&#x27;,//副标题    textAlign:&#x27;center&#x27;,//居中对齐    left:&#x27;center&#x27;,//title 组件离容器左侧的距离。  &#125;,  //x轴配置  xAxis:&#123;    //数据    data:[&#x27;衣服&#x27;,&#x27;食品&#x27;,&#x27;游戏&#x27;,&#x27;电影&#x27;],  &#125;,  //y轴配置  yAxis: &#123;    axisLine:&#123;//线      show:true    &#125;,    axisTick:&#123;//刻度      show:true    &#125;  &#125;,  //系列的设置：图表的类型和数据  series:[    &#123;      //图标类型      type:&#x27;bar&#x27;,//bar：柱状图，line：折线图      data:[10,30,40,20],//数据      color:&#x27;pink&#x27;,//颜色    &#125;  ]&#125;)\n\n一个容器显示多个图表在series中配置多个图表\nseries: [      &#123;        //图标类型        type: &#x27;bar&#x27;,//bar：柱状图，line：折线图        data: [10, 30, 40, 20],//数据        color: &#x27;pink&#x27;,//颜色      &#125;,      &#123;        type: &#x27;line&#x27;,        data: [10, 30, 40, 20],//数据        color: &#x27;gray&#x27;      &#125;,      &#123;        type: &#x27;pie&#x27;,//pie:饼图        data: [&#123;name: &#x27;衣服&#x27;, value: 10&#125;, &#123;name: &#x27;食品&#x27;, value: 30&#125;, &#123;name: &#x27;游戏&#x27;, value: 40&#125;, &#123;name: &#x27;电影&#x27;, value: 20&#125;],        width: 300,//包括文字内容的大小范围        height: 150,        left: 500,//距离左侧的距离        radius: 50,//半径      &#125;    ]\n\ndataset数据集准备数据集（二维数组）\n//数据集const data = [  [&#x27;衣服&#x27;, 10, 20, &#x27;饮料&#x27;, 22],  [&#x27;食品&#x27;, 30, 10, &#x27;电器&#x27;, 44],  [&#x27;游戏&#x27;, 40, 40, &#x27;小说&#x27;, 11],  [&#x27;电影&#x27;, 20, 30, &#x27;音乐&#x27;, 33],]\n\n在echarts的配置对象中设置字符集\n//设置字符集dataset:&#123;  //数据源  source:data,&#125;,\n\nseries中的data换成encode，指定使用的数据的索引值\nseries: [  &#123;    //图标类型    type: &#x27;bar&#x27;,//bar：柱状图，line：折线图    // data: [10, 30, 40, 20],//数据    color: &#x27;pink&#x27;,//颜色    encode: &#123;      x: 0,      y: 1,    &#125;  &#125;,  &#123;    type: &#x27;line&#x27;,    // data: [10, 30, 40, 20],//数据    color: &#x27;gray&#x27;,    encode: &#123;      x: 0,      y: 2,    &#125;  &#125;,  &#123;    type: &#x27;pie&#x27;,//pie:饼图    // data: [&#123;name: &#x27;衣服&#x27;, value: 10&#125;, &#123;name: &#x27;食品&#x27;, value: 30&#125;, &#123;name: &#x27;游戏&#x27;, value: 40&#125;, &#123;name: &#x27;电影&#x27;, value: 20&#125;],    width: 300,//包括文字内容的大小范围    height: 150,    left: 500,//距离左侧的距离    radius: 50,//半径    encode: &#123;      //饼图旁边的文字      itemName: 3,      value: 4,    &#125;  &#125;]\n\n组件提示组件//提示组件(鼠标悬浮时显示)tooltip:&#123;  textStyle:&#123;    //文字颜色    color:&#x27;red&#x27;  &#125;&#125;\n\n系列切换组件给图表添加name属性\nseries: [  &#123;    name:&#x27;柱状图&#x27;,    type: &#x27;bar&#x27;,    encode: &#123;      x: 0,      y: 1,    &#125;  &#125;,  &#123;    name:&#x27;折线图&#x27;,    type: &#x27;line&#x27;,    encode: &#123;      x: 0,      y: 2,    &#125;  &#125;,],//系列切换组件legend:&#123;  data:[&#x27;柱状图&#x27;,&#x27;折线图&#x27;],  right: &#x27;20%&#x27;&#125;\n\n工具栏组件// 工具栏组件toolbox: &#123;  show: true,  feature: &#123;    dataZoom: &#123;      yAxisIndex: &quot;none&quot;    &#125;,    dataView: &#123;      readOnly: false    &#125;,    magicType: &#123;      type: [&quot;line&quot;, &quot;bar&quot;]    &#125;,    restore: &#123;&#125;,    saveAsImage: &#123;&#125;  &#125;&#125;,\n\n双坐标两个x轴\nmyCharts.setOption(&#123;  title: &#123;    text: &#x27;echarts坐标系&#x27;,    left: &#x27;center&#x27;,    textAlign: &#x27;center&#x27;,  &#125;,  //多个坐标系，使用数组  xAxis: [    &#123;      data: [&#x27;衣服&#x27;, &#x27;食品&#x27;, &#x27;游戏&#x27;, &#x27;电影&#x27;],    &#125;,    &#123;&#125;,  ],  yAxis: &#123;&#125;,  series: [    &#123;      type: &#x27;scatter&#x27;,//散点图      data: [        [11, 87],        [34, 45],        [64, 23],        [43, 54],        [12, 40],      ],      xAxisIndex: 1,//使用第二个x轴    &#125;,    &#123;      type: &#x27;bar&#x27;,      data: [10, 30, 40, 20],      xAxisIndex: 0,//使用第一个x轴    &#125;  ]&#125;)\n","categories":["数据可视化"],"tags":["Echarts","canvas","svg"]},{"title":"防抖节流","url":"/2022/03/09/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/","content":"防抖function debounce(fn, duration = 500) &#123;//自定义防抖函数,默认0.5秒内没有再次触发该函数时执行    let timer    return function (...args) &#123;        timer &amp;&amp; clearTimeout(timer)        timer = setTimeout(() =&gt; &#123;            typeof fn === &#x27;function&#x27; &amp;&amp; fn.apply(this, args)        &#125;, duration)    &#125;&#125;const input = document.getElementById(&#x27;input&#x27;)input.addEventListener(&#x27;input&#x27;, debounce(event =&gt; &#123;    console.log(event.target.value)&#125;));\n\n节流function throttle(fn, duration = 1000) &#123; //自定义节流函数，1秒内只触发一次    let time = 0    return function (...args) &#123;        if (new Date() - time &gt; duration) &#123;            typeof fn === &#x27;function&#x27; &amp;&amp; fn.apply(this, args)            time = new Date()        &#125;    &#125;&#125;const btn = document.getElementById(&#x27;btn&#x27;)btn.addEventListener(&#x27;click&#x27;, throttle(event =&gt; &#123;    console.log(event.target.innerText)&#125;));\n\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"HTTP缓存","url":"/2022/03/27/HTTP%E7%BC%93%E5%AD%98/","content":"强制缓存对于强制缓存而言，如果浏览器判断所请求的目标资源有效命中，则可直接从强制缓存中返回请求响应，无需与服务器进行任何通信。\nExpires服务器返回资源时在响应头中设置Expires字段，指定过期时间。在过期时间之前，浏览器再次访问该资源，则直接从强制缓存中获取。\nExpires:New Date(&#x27;2022-03-27 15:08:38&#x27;).toUTCString()\n\n缺点这个方式存在一个很大的漏洞，即对本地时间戳过分依赖，如果客户端本地的时间与服务器端的时间不同步，或者对客户端时间进行主动修改，那么对于缓存过期的判断可能就无法和预期相符。\ncache-controlmax-agecache-control设置max-age&#x3D;60属性值来控制响应资源的有效期，它是一个以秒为单位的时间长度，表示该资源在被请求到后的60秒内有效，如此便可避免服务器端和客户端时间戳不同步而造成的问题。\ncache-control:max-age=60//滑动时间，单位为秒\n\ncache-control还可以配置一些其他属性值，下面介绍。\nno-store和no-cacheno-store和no-cache是一组互斥属性\nno-store：表示禁止使用缓存\nno-cache：表示强制进行协商缓存\npublic和privatepublic和private是一组互斥属性\npublic：表示响应资源既可以被浏览器缓存，又可以被代理服务器缓存。\nprivate：响应资源只能被浏览器缓存，若未显式指定则默认值为private。\n对于应用程序中不会改变的文件，你通常可以在发送响应头前添加积极缓存（public）。这包括例如由应用程序提供的静态文件，例如图像，CSS 文件和JavaScript文件。\ns-maxages-maxage：表示代理服务器缓存的过期时间。\n协商缓存协商缓存就是在使用本地缓存之前，需要向服务器端发起一次GET请求，与之协商当前浏览器保存的本地缓存是否已经过期。\nlast-modified&#x2F;if-modified-since响应头中设置：\ncache-control:no-cache//进行协商缓存last-modified:xxx//资源最后一次修改的时间\n\n浏览器再次访问时请求头中会加上if-modified-since字段：\nif-modified-since:xxx//值为上次请求时响应头的last-modified的值\n\n服务器判断if-modified-since和此次的last-modified是否一致。如果一致则只需返回状态码304，表示从缓存中获取数据计可。如果不一致，就需要返回新的数据和last-modified。\n缺陷首先，它只是根据资源最后的修改时间戳进行判断的，虽然请求的文件资源进行了编辑，但内容并没有发生任何变化，时间戳也会更新，从而导致协商缓存时关于有效性的判断验证为失效，需要重新进行完整的资源请求。这无疑会造成网络带宽资源的浪费，以及延长用户获取到目标资源的时间。\n其次，标识文件资源修改的时间戳单位是秒，如果文件修改的速度非常快，假设在几百毫秒内完成，那么上述通过时间戳的方式来验证缓存的有效性，是无法识别出该次文件资源的更新的。\netag和if-none-match其内容主要是服务器为不同资源进行哈希运算所生成的一个字符串，只要文件内容编码存在差异，对应的 etag标签值就会不同，因此可以使用etag对文件资源进行更精准的变化感知。\n响应头中设置：\netag:xxx//根据资源进行哈希运算所生成的一个字符串\n\n浏览器再次访问时请求头中会加上if-none-match字段：\nif-none-match:xxx//值为上次请求时响应头的etag的值\n\n服务器判断if-none-match和此次的etag是否一致。如果一致则只需返回状态码304，表示从缓存中获取数据计可。如果不一致，就需要返回新的数据和etag。\n缺陷一方面，服务器对于生成文件资源的etag需要付出额外的计算开销，如果资源的尺寸较大，数量较多且修改比较频繁，那么生成etag的过程就会影响服务器的性能。\n另一方面，etag字段值的生成分为强验证和弱验证，强验证根据资源内容进行生成，能够保证每个字节都相同;弱验证则根据资源的部分属性值来生成，生成速度快但无法确保每个字节都相同，并且在服务器集群场景下，也会因为不够准确而降低协商缓存有效性验证的成功率，所以恰当的方式是根据具体的资源使用场景选择恰当的缓存校验方式。\n参考视频\n","categories":["HTTP","HTTP缓存"],"tags":["HTTP"]},{"title":"Vue解决SEO","url":"/2022/03/27/Vue%E8%A7%A3%E5%86%B3SEO/","content":"SEO：搜索引擎优化seo需要的几个关键点：\n\n多页面\ntitle、描述、关键词\n网站的内容\n\nvue-cli无法实现以上三点：\n\nvue项目是SPA：单页面应用\nvue项目只有一套title、描述、关键词\nvue项目的内容是通过引入js文件加载的，无法通过源代码的HTML文件中直接读取\n\n预渲染在html页面生成之前数据就已经加载完成。预渲染的流程：\n\n读取配置，获取需要预渲染的页面\n\n发布机模拟浏览器环境打开页面\n\n页面脚本触发渲染时机\n\n渲染出当前的页面内容\n\n获取当前所有的DOM结构\n\n生成HTML文件\n\n\nprerender-spa-plugin提供一个预渲染解决方案。\n安装插件prerender-spa-plugin：\nnpm i prerender-spa-plugin\n\n在vue.config.js中进行配置：\nconst path = require(&#x27;path&#x27;)const PrerenderSPAPlugin = require(&#x27;prerender-spa-plugin&#x27;) module.exports = &#123;\tpublicPath:&#x27;./&#x27;,\tconfigureWebpack:&#123;    \tplugins: [\t        new PrerenderSPAPlugin(&#123;          \t\tstaticDir: path.join(__dirname, &#x27;dist&#x27;),          \t\t//将指定的路由分别预渲染为HTML页面(打包后生成多个HTML页面)         \t\troutes: [ &#x27;/&#x27;, &#x27;/about&#x27;, &#x27;/some/deep/nested/route&#x27; ],        \t&#125;)      \t]\t&#125; &#125;\n\nvue-meta-info修改title、描述、关键词。\nnpm i vue-meta-info\n\n在路由对应 的Vue文件中设置对应的meta-info：\n&lt;template&gt;    ...&lt;/template&gt; &lt;script&gt;  export default &#123;    metaInfo: &#123;      title: &#x27;My Example App&#x27;, // 设置title      meta: [&#123;                         name: &#x27;keyWords&#x27;,//关键字        content: &#x27;My Example App&#x27;//描述      &#125;]      /*link: [&#123;//设置link        rel: &#x27;asstes&#x27;,        href: &#x27;https://assets-cdn.github.com/&#x27;      &#125;]*/    &#125;  &#125;&lt;/script&gt; \n\n存在的问题prerender-spa-plugin无法配置动态路由，适合一个项目只需要其中几个页面需要做seo。\nvue-meta-info无法给title、描述和关键字设置动态数据。\n服务器渲染（SSR）在客户端和后端之间再添加一个服务器端（比如node.js）,后端将返回的数据交给服务器端，服务器端将html返回给客户端。\nNUXTNUXT中文官网\n一个基于 Vue.js 的服务端渲染应用框架\n安装:\nnpx create-nuxt-app &lt;项目名&gt;\n\n安装时需要进行一些选择\n目录结构pages：文件夹中放置路由组件。在该文件夹下的组件会在.nuxt文件夹下的router.js中自动配置路由。\ncomponents：文件夹中放置全局组件，使用其中的组件时无需import，可直接使用。因为配置文件nuxt.config.js配置文件中的components: true（改为false后需要手动引入组件）\nstore：store 目录用于组织应用的 Vuex 状态树 文件。 Nuxt.js 框架集成了 Vuex 状态树 的相关功能配置，在 store 目录下创建一个 index.js 文件可激活这些配置。\nNUXT生命周期服务端生命周期nuxtServerInit在store 目录下新建index.js。在vuex的actions模块中使用nuxtServerInit\nexport const state = () =&gt; &#123;&#125;export const mutations = &#123;&#125;export const actions = &#123;  //参数1：vuex上下文  //参数2：nuxt上下文  //只能在index.js中使用，其他的js文件会被当成子模块，子模块中使用nuxtServerInit无效  nuxtServerInit(store, context) &#123;    console.log(&#x27;nuxtServerInit&#x27;)  &#125;&#125;\n\nmiddleware（中间件）根目录下新建middleware目录，添加js文件（name.js）:\nexport default (&#123;store,route,req,res,redirect&#125;) =&gt; &#123;//可接收很多参数  console.log(&#x27;middleware&#x27;)&#125;\n\n全局middleware：nuxt.config.js中添加：\nrouter:&#123;  middleware:&#x27;name&#x27;,//对应middleware目录下的js文件名&#125;\n\n局部（组件内）middleware：\n&lt;template&gt;  &lt;Tutorial/&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;IndexPage&#x27;,  // middleware:&#x27;name&#x27;,  middleware()&#123;//不需要在middleware目录下写js文件    console.log(&#x27;局部middleware&#x27;)  &#125;&#125;&lt;/script&gt;\n\nvalidate用于校验路由参数\n在组件中使用：\n&lt;template&gt;  &lt;Tutorial/&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;IndexPage&#x27;,  validate(&#123;params,query&#125;)&#123;//接收路由的参数    console.log(&#x27;validate&#x27;)    return /^\\d+$/.test(query.id)//返回值为true时才能正常访问  &#125;&#125;&lt;/script&gt;\n\nasyncData只能在页面组件中使用，在组件每次加载之前调用，一般用来发送请求、获取数据。\nfetch可以在所有组件中使用\n服务端和客户端共有的生命周期beforeCreate&#x2F;created在NUXT服务器和客户端都执行\n客户端生命周期和vue中一致：\n\nbeforeMount&#x2F;mounted\n\nbeforeUpdate&#x2F;updated\n\nbeforeDestroy&#x2F;destroyed\n\n\nNUXT路由nuxt-link&lt;nuxt-link&gt; 的作用和&lt;router-link&gt;一致。为了提高 Nuxt.js 应用程序的响应能力，当链接将显示在视口中时，Nuxt.js 将自动预获取代码分割页面。\n子路由在pages目录下新一个和父路由同名的文件夹，该文件夹下的.vue文件为子路由\n动态路由.vue文件以下划线（’_’）开头的为动态路由\n手动配置router.js使用@nuxtjs&#x2F;router\nnpm i @nuxtjs/router\n\nnuxt.config.js中配置：\nmodules:[\t&#x27;@nuxtjs/router&#x27;]\n\n\n\n\n\n\n\n\n\n参考视频\n","categories":["SEO","服务端渲染","NUXT"],"tags":["Vue","SEO","Nuxt"]}]