[{"title":"Echarts的容器宽高使用rem，渲染出的图表很小的问题","url":"/2022/03/06/Echarts%E7%9A%84%E5%AE%B9%E5%99%A8%E5%AE%BD%E9%AB%98%E4%BD%BF%E7%94%A8rem%EF%BC%8C%E6%B8%B2%E6%9F%93%E5%87%BA%E7%9A%84%E5%9B%BE%E8%A1%A8%E5%BE%88%E5%B0%8F%E7%9A%84%E9%97%AE%E9%A2%98/","content":"主要是因为div还没有创建出来echarts就已经加载了，因为获取不到宽高，所以会缩小在一起。参考了几篇文章，我在echarts配置后加入如下代码，解决了问题：\nmyChart.setOption(option); //延迟resize setTimeout(function ()&#123;\t myChart.resize() &#125;,200)//随屏幕大小改变 window.addEventListener(&#x27;resize&#x27;,function()&#123;\t myChart.resize() &#125;)\nCSDN:https://blog.csdn.net/cjhsyc/article/details/122584331参考文章：https://www.cnblogs.com/xxxx0130/p/14182677.htmlhttps://blog.csdn.net/weixin_40180205/article/details/106116073\n","categories":["数据可视化","Echarts"],"tags":["Echarts"]},{"title":"webpack配置","url":"/2022/03/07/webpack%E9%85%8D%E7%BD%AE/","content":"webpack.config.js入口和出口文件const path = require(&#x27;path&#x27;)//引入path模块module.exports = &#123;    entry: &#x27;./src/index.js&#x27;,//打包的入口文件    output: &#123;//出口        filename: &quot;bundle.js&quot;,//出口文件名        path: path.resolve(__dirname, &quot;./dist&quot;),//出口文件路径需要绝对路径        clean: true,//打包前清理dist文件夹    &#125;&#125;\n\n生成HTML文件安装html-webpack-plugin插件\nnpm i html-webpack-plugin -D\n\n该模块用于自动生成HTML文件。在webpack.config.js中引入：\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); //通过 npm 安装\n\n通过plugins配置插件：\nplugins: [    new HtmlWebpackPlugin(&#123;//可不传配置项（默认配置）        template: &quot;./index.html&quot;,//以index.html为模板生成html文件        filename: &quot;app.html&quot;,        inject: &#x27;body&#x27;,//指定script标签写在body标签中（默认为head）    &#125;)]\n\n代码有修改后自动打包：\nwebpack --watch\n\n开发环境安装webpack-dev-server插件\nnpm i webpack-dev-server -D\n\n//开发模式mode: &quot;development&quot;,devtool: &#x27;inline-source-map&#x27;,//精确显示代码位置（比如报错时）devServer: &#123;//开发服务器    static:&#x27;./dist&#x27;&#125;,\n\n命令行执行：\nwebpack-dev-server\n\n无需打包，通过浏览器访问8080端口实时查看页面效果\n资源模块Resource资源加载资源导出url\nmodule:&#123;    rules: [        &#123;            test:/\\.png$/,//匹配.png文件            type: &quot;asset/resource&quot;,//加载资源导出url            generator: &#123;//指定打包的路径（可省略）                filename: &#x27;images/[contenthash][ext]&#x27;//[contenthash]:哈希值作为文件名，[ext]:扩展名            &#125;        &#125;    ]&#125;\n\n示例：在index.js中导入png图片\nimport imgsrc from &#x27;../asset/微信.png&#x27;//图片url(http://localhost:8080/images/a2769eaec65049f8919b.png)const img = document.createElement(&#x27;img&#x27;)img.src = imgsrcdocument.body.appendChild(img)\n\n也可再output中使用assetModuleFilename指定打包路径，优先级低于rules中的配置\noutput: &#123;//出口    filename: &quot;bundle.js&quot;,//出口文件名    path: path.resolve(__dirname, &quot;./dist&quot;),//出口文件路径需要绝对路径    clean: true,//打包前清理dist文件夹    assetModuleFilename: &quot;images/[contenthash][ext]&quot;,//[contenthash]:哈希值作为文件名，[ext]:扩展名&#125;,\n\ninline资源导出为Data URL base64格式\n&#123;    test: /\\.svg$/,    type: &quot;asset/inline&quot;,//导出为Data URL base64格式&#125;,\n\n示例：导入svg图片\nimport logoSvg from &#x27;./asset/logo.svg&#x27;//(data:image/svg+xml;base64,PHN2ZyB4bWxucz......)const img2 = document.createElement(&#x27;img&#x27;)img2.src = logoSvgimg2.style.cssText=&#x27;width:400px;height:600px&#x27;document.body.appendChild(img2)\n\nsource资源导出文件源码\n&#123;    test: /\\.txt$/,    type: &quot;asset/source&quot;,//导出文件源码&#125;\n\n示例：导入源码\nimport helloTxt from &#x27;./asset/hello.txt&#x27;//txt的文本内容const block = document.createElement(&#x27;div&#x27;)block.style.cssText = &#x27;width:200px;height:200px;border:1px solid gray&#x27;block.textContent = helloTxtdocument.body.appendChild(block)\n\n通用资源类型自动选择资源类型，小于maxSize用inline类型，大于则用resource类型\n&#123;    test: /\\.jpg$/,    type: &quot;asset&quot;,//自动选择资源类型，小于maxSize用inline类型，大于则用resource类型    parser: &#123;//自定义条件（可省略）        dataUrlCondition:&#123;            maxSize: 4 * 1024//默认为4 * 1024        &#125;    &#125;&#125;\n\n示例：导入jpg图片\nimport jpgMap from &#x27;./asset/头像.jpg&#x27;//因为大于4k所以是url格式const block = document.createElement(&#x27;div&#x27;)block.style.cssText = &#x27;width:200px;height:200px;border:1px solid gray&#x27;block.textContent = helloTxtdocument.body.appendChild(block)\n\nloader加载CSS安装loader\nnpm i css-loader -Dnpm i style-loader -D\n\n在module &gt; rules中配置\n&#123;    test: /\\.css$/,    //css-loader写在style-loader后面，先加载    //如果需要CSS预处理语言，安装相应的loader，写在css-loader后面    use: [&#x27;style-loader&#x27;,&#x27;css-loader&#x27;],//css-loader允许打包css文件，style-loader将样式加到html页面上&#125;\n\n抽离和压缩CSS安装插件\nnpm i mini-css-extract-plugin -Dnpm i css-minimizer-webpack-plugin -D\n\n引入插件\nconst MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)const CssMinimizerPlugin = require(&#x27;css-minimizer-webpack-plugin&#x27;)\n\n在plugin中使用MiniCssExtractPlugin（用于以link标签的形式在html中导入css文件）\nnew MiniCssExtractPlugin(&#123;\tfilename:&#x27;styles/[contenthash].css&#x27;//自定义打包路径&#125;)\n\n&#123;    test: /\\.css$/,    //&#x27;style-loader&#x27;换为MiniCssExtractPlugin    use: [MiniCssExtractPlugin.loader,&#x27;css-loader&#x27;],//css-loader允许打包css文件，style-loader将样式加到html页面上&#125;\n\n新配置项optimization中使用CssMinimizerPlugin（用于压缩css文件）\noptimization: &#123;    minimizer: [        new CssMinimizerPlugin()    ]&#125;,mode:&#x27;production&#x27;//生产环境下才会压缩（会有其他报错）\n\nbabel-loader如果浏览器不支持ES6语法，使用babel-loader，将ES6转为ES5\n安装babel-loader，@babel&#x2F;core，@babel&#x2F;preset-env\nnpm i babel-loader @babel/core @babel/preset-env -Dnpm i @babel/runtime -Dnpm i @babel/plugin-transform-runtime -D\n\nmodule &gt; rules中配置\n&#123;    test:/\\.js$/,    exclude: /node_modules/,//排除node_modules中的js文件    use:&#123;        loader:&#x27;babel-loader&#x27;,        options: &#123;            presets:[&#x27;@babel/preset-env&#x27;],            plugins: [                [                    &#x27;@babel/plugin-transform-runtime&#x27;                ]            ]        &#125;    &#125;&#125;\n\n代码分离多入口entry中设置多入口文件，修改output中的filename\nentry: &#123;    //两个文件都引入了lodash模块    index: &#x27;./src/index.js&#x27;,    another: &#x27;./src/another.js&#x27;&#125;,//打包的入口文件output: &#123;//出口    filename: &quot;[name].bundle.js&quot;,//出口文件名（[name]:入口文件的键值）    path: path.resolve(__dirname, &quot;./dist&quot;),//出口文件路径需要绝对路径    clean: true,//打包前清理dist文件夹    assetModuleFilename: &quot;images/[contenthash][ext]&quot;,//[contenthash]:哈希值作为文件名，[ext]:扩展名&#125;,\n\n防止重复optimization: &#123;    splitChunks: &#123;        chunks: &quot;all&quot;//自动抽离公共代码模块    &#125;&#125;\n","categories":["工程化"],"tags":["webpack"]},{"title":"less预处理语言","url":"/2022/03/08/less%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%AD%E8%A8%80/","content":"变量声明和使用//定义变量@color: red;@var: a;@attr: color;@&#123;var&#125; &#123; //作为选择器或者属性名需要添加大括号    @&#123;attr&#125;: @color; //作为属性值直接使用&#125;@btn: &#123;    width: 100px;    height: 40px;    background-color: aqua;&#125;.btn &#123;    @btn(); //需要括号&#125;    @url: &#x27;https://cdn.jsdelivr.net/gh/cjhsyc/image-hosting@master/头像.677yiujw5980.webp&#x27;;.img&#123;    background-image: url(&quot;@&#123;url&#125;&quot;); //作为url使用    background-size: 100px;    width: 100px;    height: 100px;&#125;\n\n运算可以使用+、-、*、&#x2F;进行运算\n@a: 100px + 20px; //120px@b: @a*2; //240px@c: #666/2; //#333\n\n嵌套.parent&#123;    width: 100px;    height: 100px;    border: 1px solid gray;    .child&#123;        background-color: skyblue;        @media (min-width: 900px)&#123;            background-color: pink;        &#125;        @media (min-width: 500px) and (max-width: 900px)&#123;            background-color: greenyellow;        &#125;    &#125;&#125;\n\n相当于\n.parent &#123;  width: 100px;  height: 100px;  border: 1px solid gray;&#125;.parent .child &#123;  background-color: skyblue;&#125;@media (min-width: 900px) &#123;    .parent .child &#123;        background-color: pink;    &#125;&#125;@media (min-width: 500px) and (max-width: 900px) &#123;    .parent .child &#123;        background-color: greenyellow;    &#125;&#125;\n\n混合.mixins &#123;    border: 2px solid skyblue;    width: 300px;    height: 30px;&#125;.box &#123;    .mixins(); //括号可加可不加&#125;\n\n函数使用函数自定义一个绘制三角形的函数\n.triangle(top,@color:black,@height:50px) &#123;    border-color: transparent transparent @color transparent;&#125;.triangle(left,@color:black,@height:50px) &#123;    border-color: transparent @color transparent transparent;&#125;.triangle(bottom,@color:black,@height:50px) &#123;    border-color: @color transparent transparent transparent;&#125;.triangle(right,@color:black,@height:50px) &#123;    border-color: transparent transparent transparent @color;&#125;.triangle(@dir,@color:black,@height:50px) &#123;//@dir用来匹配第一个参数，后面的参数都要一致    width: 0;    height: 0;    border-width: @height;    border-style: solid;&#125;.triangleBox &#123;    .triangle(top,red);//绘制尖朝上的三角形,后两个参数不写则使用默认值&#125;\n\n命名空间和逻辑判断#card&#123;    //when:进行逻辑判断    //not:取反,and:且,或运算使用逗号    .border(@width,@color,@style) when not(@width &gt; 30px) , (@color &gt;= #666) and (@style = solid)&#123;        border: @width @style @color;    &#125;&#125;#main &#123;    //调用其他作用域的函数（ &#x27;&gt;&#x27; 可以省略 ）    #card &gt; .border(40px, #666, solid); //符合条件才生效    //#card.border(40px, #666, solid);//效果同上&#125;\n\n不定参数.boxShadow(@a,@b,...)&#123;//不定参数    box-shadow: @arguments;//@arguments:所有的参数,包括@a,@b    width: 200px;&#125;#box1&#123;    .boxShadow(0,0,10px,gray);&#125;#box2&#123;    .boxShadow(inset,0,0,5px,gray);&#125;\n\n循环//循环（递归调用函数）.columns(@n,@i:1) when (@i &lt;= @n) &#123;    .column-@&#123;i&#125; &#123;        width: @i*100% / @n;        height: 20px;        background-color: pink;    &#125;    .columns(@n, @i+1)&#125;.columns(4);\n\n属性合并.bg&#123;    width: 200px;    height: 200px;    //+ :属性用逗号隔开    //+_ :属性用空格隔开    background+: #666666;    background+_: url(&quot;@&#123;url&#125;&quot;);    background+_: no-repeat;    background+_: center;    box-shadow+: 0 0 5px greenyellow;    box-shadow+: 0 0 10px #000;    background-size: 100px;&#125;\n\n相当于\n.bg &#123;  width: 200px;  height: 200px;  background: #666666 url(&quot;@&#123;url&#125;&quot;) no-repeat center;  box-shadow: 0 0 5px greenyellow,0 0 10px #000;  background-size: 100px;&#125;\n\n继承.linkBtn &#123;    display: block;    width: 200px;    height: 80px;&#125;.linkBtn &#123;    color: white;    background-color: skyblue;&#125;.link:extend(.linkBtn) &#123;    text-decoration: none;    border: 4px solid orange;&#125;\n\n使用混合也可以实现相同的效果，但混合是相当于把代码再复制一份，而继承不是，上述代码转CSS如下：\n.linkBtn,.link &#123;  display: block;  width: 200px;  height: 80px;&#125;.linkBtn,.link &#123;  color: white;  background-color: skyblue;&#125;.link &#123;  text-decoration: none;  border: 4px solid orange;&#125;\n\n导入@import &quot;./assets/style.less&quot;@import (reference) &quot;./assets/style.less&quot;//添加reference后，未被调用的代码不加载\n\n\n\n\n\n","categories":["样式","less"],"tags":["less"]},{"title":"js严格模式","url":"/2022/03/09/js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","content":"严格模式使用严格模式&quot;use strict&quot;\n\n变量a = 10console.log(a)//严格模式报错（必须使用var等声明变量）\n\n静默失败 &#x3D;&gt; 报错var b = 2console.log(Object.getOwnPropertyDescriptor(window, &#x27;b&#x27;))/*configurable: false //var声明的变量默认不可删除enumerable: truevalue: 2writable: true*/delete b//未删除，非严格模式下不报错，程序继续进行（静默失败）//严格模式下报错console.log(b)//2\n\n函数参数唯一function test(a,a)&#123;    console.log(a)//undefined(第二个a),严格模式报错&#125;test(10)\n\n实参和形参的映射关系不存在function test1(a) &#123;    a = 20    console.log(arguments[0])//非严格模式:20,严格模式:10&#125;test1(10)function test2(a = 20) &#123;//参数设置初始后自动开启严格模式    a = 30    console.log(arguments[0])//10&#125;test2(10)\n\n函数的this默认指向undefinedfunction test()&#123;    console.log(this)//undefined&#125;test()\n\n不能使用arguments.callee和callerfunction test()&#123;    console.log(arguments.callee === test)//true,严格模式无法使用    console.log(test.caller === out)//true,严格模式无法使用&#125;function out()&#123;    test()&#125;out()\n\n不能使用eval()和with()eval(&#x27;var a=2&#x27;)console.log(a)//2,严格模式无法使用const obj=&#123;    a:3&#125;function test()&#123;    with (obj) &#123;//改变this指向        console.log(a)//3,严格模式无法使用    &#125;&#125;test()\n\neval和arguments不能作为标识符let eval=&#x27;111&#x27;//严格模式报错\n\n\n\n\n\n\n\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"防抖节流","url":"/2022/03/09/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/","content":"防抖function debounce(fn, duration = 500) &#123;//自定义防抖函数,默认0.5秒内没有再次触发该函数时执行    let timer    return function (...args) &#123;        timer &amp;&amp; clearTimeout(timer)        timer = setTimeout(() =&gt; &#123;            typeof fn === &#x27;function&#x27; &amp;&amp; fn.apply(this, args)        &#125;, duration)    &#125;&#125;const input = document.getElementById(&#x27;input&#x27;)input.addEventListener(&#x27;input&#x27;, debounce(event =&gt; &#123;    console.log(event.target.value)&#125;));\n\n节流function throttle(fn, duration = 1000) &#123; //自定义节流函数，1秒内只触发一次    let time = 0    return function (...args) &#123;        if (new Date() - time &gt; duration) &#123;            typeof fn === &#x27;function&#x27; &amp;&amp; fn.apply(this, args)            time = new Date()        &#125;    &#125;&#125;const btn = document.getElementById(&#x27;btn&#x27;)btn.addEventListener(&#x27;click&#x27;, throttle(event =&gt; &#123;    console.log(event.target.innerText)&#125;));\n\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"数据可视化","url":"/2022/03/20/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/","content":"","categories":["数据可视化"],"tags":["Echarts","canvas","svg"]}]