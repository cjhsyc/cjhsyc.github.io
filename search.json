[{"title":"Echarts的容器宽高使用rem，渲染出的图表很小的问题","url":"/2022/03/06/Echarts%E7%9A%84%E5%AE%B9%E5%99%A8%E5%AE%BD%E9%AB%98%E4%BD%BF%E7%94%A8rem%EF%BC%8C%E6%B8%B2%E6%9F%93%E5%87%BA%E7%9A%84%E5%9B%BE%E8%A1%A8%E5%BE%88%E5%B0%8F%E7%9A%84%E9%97%AE%E9%A2%98/","content":"主要是因为div还没有创建出来echarts就已经加载了，因为获取不到宽高，所以会缩小在一起。参考了几篇文章，我在echarts配置后加入如下代码，解决了问题：\nmyChart.setOption(option); //延迟resize setTimeout(function ()&#123;\t myChart.resize() &#125;,200)//随屏幕大小改变 window.addEventListener(&#x27;resize&#x27;,function()&#123;\t myChart.resize() &#125;)\nCSDN:https://blog.csdn.net/cjhsyc/article/details/122584331参考文章：https://www.cnblogs.com/xxxx0130/p/14182677.htmlhttps://blog.csdn.net/weixin_40180205/article/details/106116073\n","tags":["Echarts"]},{"title":"webpack配置","url":"/2022/03/07/webpack%E9%85%8D%E7%BD%AE/","content":"webpack.config.js入口和出口文件const path = require(&#x27;path&#x27;)//引入path模块module.exports = &#123;    entry: &#x27;./src/index.js&#x27;,//打包的入口文件    output: &#123;//出口        filename: &quot;bundle.js&quot;,//出口文件名        path: path.resolve(__dirname, &quot;./dist&quot;),//出口文件路径需要绝对路径        clean: true,//打包前清理dist文件夹    &#125;&#125;\n\n生成HTML文件安装html-webpack-plugin插件\nnpm i html-webpack-plugin -D\n\n该模块用于自动生成HTML文件。在webpack.config.js中引入：\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); //通过 npm 安装\n\n通过plugins配置插件：\nplugins: [    new HtmlWebpackPlugin(&#123;//可不传配置项（默认配置）        template: &quot;./index.html&quot;,//以index.html为模板生成html文件        filename: &quot;app.html&quot;,        inject: &#x27;body&#x27;,//指定script标签写在body标签中（默认为head）    &#125;)]\n\n代码有修改后自动打包：\nwebpack --watch\n\n开发环境安装webpack-dev-server插件\nnpm i webpack-dev-server -D\n\n//开发模式mode: &quot;development&quot;,devtool: &#x27;inline-source-map&#x27;,//精确显示代码位置（比如报错时）devServer: &#123;//开发服务器    static:&#x27;./dist&#x27;&#125;,\n\n命令行执行：\nwebpack-dev-server\n\n无需打包，通过http查看页面效果\n","tags":["webpack"]},{"title":"less预处理语言","url":"/2022/03/08/less%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%AD%E8%A8%80/","content":"变量声明和使用//定义变量@color: red;@var: a;@attr: color;@&#123;var&#125; &#123; //作为选择器或者属性名需要添加大括号    @&#123;attr&#125;: @color; //作为属性值直接使用&#125;@btn: &#123;    width: 100px;    height: 40px;    background-color: aqua;&#125;.btn &#123;    @btn(); //需要括号&#125;    @url: &#x27;https://cdn.jsdelivr.net/gh/cjhsyc/image-hosting@master/头像.677yiujw5980.webp&#x27;;.img&#123;    background-image: url(&quot;@&#123;url&#125;&quot;); //作为url使用    background-size: 100px;    width: 100px;    height: 100px;&#125;\n\n运算可以使用+、-、*、&#x2F;进行运算\n@a: 100px + 20px; //120px@b: @a*2; //240px@c: #666/2; //#333\n\n嵌套.parent&#123;    width: 100px;    height: 100px;    border: 1px solid gray;    .child&#123;        background-color: skyblue;        @media (min-width: 900px)&#123;            background-color: pink;        &#125;        @media (min-width: 500px) and (max-width: 900px)&#123;            background-color: greenyellow;        &#125;    &#125;&#125;\n\n相当于\n.parent &#123;  width: 100px;  height: 100px;  border: 1px solid gray;&#125;.parent .child &#123;  background-color: skyblue;&#125;@media (min-width: 900px) &#123;    .parent .child &#123;        background-color: pink;    &#125;&#125;@media (min-width: 500px) and (max-width: 900px) &#123;    .parent .child &#123;        background-color: greenyellow;    &#125;&#125;\n\n混合.mixins &#123;    border: 2px solid skyblue;    width: 300px;    height: 30px;&#125;.box &#123;    .mixins(); //括号可加可不加&#125;\n\n函数使用函数自定义一个绘制三角形的函数\n.triangle(top,@color:black,@height:50px) &#123;    border-color: transparent transparent @color transparent;&#125;.triangle(left,@color:black,@height:50px) &#123;    border-color: transparent @color transparent transparent;&#125;.triangle(bottom,@color:black,@height:50px) &#123;    border-color: @color transparent transparent transparent;&#125;.triangle(right,@color:black,@height:50px) &#123;    border-color: transparent transparent transparent @color;&#125;.triangle(@dir,@color:black,@height:50px) &#123;//@dir用来匹配第一个参数，后面的参数都要一致    width: 0;    height: 0;    border-width: @height;    border-style: solid;&#125;.triangleBox &#123;    .triangle(top,red);//绘制尖朝上的三角形,后两个参数不写则使用默认值&#125;\n\n命名空间和逻辑判断#card&#123;    //when:进行逻辑判断    //not:取反,and:且,或运算使用逗号    .border(@width,@color,@style) when not(@width &gt; 30px) , (@color &gt;= #666) and (@style = solid)&#123;        border: @width @style @color;    &#125;&#125;#main &#123;    //调用其他作用域的函数（ &#x27;&gt;&#x27; 可以省略 ）    #card &gt; .border(40px, #666, solid); //符合条件才生效    //#card.border(40px, #666, solid);//效果同上&#125;\n\n不定参数.boxShadow(@a,@b,...)&#123;//不定参数    box-shadow: @arguments;//@arguments:所有的参数,包括@a,@b    width: 200px;&#125;#box1&#123;    .boxShadow(0,0,10px,gray);&#125;#box2&#123;    .boxShadow(inset,0,0,5px,gray);&#125;\n\n循环//循环（递归调用函数）.columns(@n,@i:1) when (@i &lt;= @n) &#123;    .column-@&#123;i&#125; &#123;        width: @i*100% / @n;        height: 20px;        background-color: pink;    &#125;    .columns(@n, @i+1)&#125;.columns(4);\n\n属性合并.bg&#123;    width: 200px;    height: 200px;    //+ :属性用逗号隔开    //+_ :属性用空格隔开    background+: #666666;    background+_: url(&quot;@&#123;url&#125;&quot;);    background+_: no-repeat;    background+_: center;    box-shadow+: 0 0 5px greenyellow;    box-shadow+: 0 0 10px #000;    background-size: 100px;&#125;\n\n相当于\n.bg &#123;  width: 200px;  height: 200px;  background: #666666 url(&quot;@&#123;url&#125;&quot;) no-repeat center;  box-shadow: 0 0 5px greenyellow,0 0 10px #000;  background-size: 100px;&#125;\n\n继承.linkBtn &#123;    display: block;    width: 200px;    height: 80px;&#125;.linkBtn &#123;    color: white;    background-color: skyblue;&#125;.link:extend(.linkBtn) &#123;    text-decoration: none;    border: 4px solid orange;&#125;\n\n使用混合也可以实现相同的效果，但混合是相当于把代码再复制一份，而继承不是，上述代码转CSS如下：\n.linkBtn,.link &#123;  display: block;  width: 200px;  height: 80px;&#125;.linkBtn,.link &#123;  color: white;  background-color: skyblue;&#125;.link &#123;  text-decoration: none;  border: 4px solid orange;&#125;\n\n导入@import &quot;./assets/style.less&quot;@import (reference) &quot;./assets/style.less&quot;//添加reference后，未被调用的代码不加载\n\n\n\n\n\n","tags":["less"]},{"title":"js严格模式","url":"/2022/03/09/js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","content":"严格模式使用严格模式&quot;use strict&quot;\n\n变量a = 10console.log(a)//严格模式报错（必须使用var等声明变量）\n\n静默失败 &#x3D;&gt; 报错var b = 2console.log(Object.getOwnPropertyDescriptor(window, &#x27;b&#x27;))/*configurable: false //var声明的变量默认不可删除enumerable: truevalue: 2writable: true*/delete b//未删除，非严格模式下不报错，程序继续进行（静默失败）//严格模式下报错console.log(b)//2\n\n函数参数唯一function test(a,a)&#123;    console.log(a)//undefined(第二个a),严格模式报错&#125;test(10)\n\n实参和形参的映射关系不存在function test1(a) &#123;    a = 20    console.log(arguments[0])//非严格模式:20,严格模式:10&#125;test1(10)function test2(a = 20) &#123;//参数设置初始后自动开启严格模式    a = 30    console.log(arguments[0])//10&#125;test2(10)\n\n函数的this默认指向undefinedfunction test()&#123;    console.log(this)//undefined&#125;test()\n\n不能使用arguments.callee和callerfunction test()&#123;    console.log(arguments.callee === test)//true,严格模式无法使用    console.log(test.caller === out)//true,严格模式无法使用&#125;function out()&#123;    test()&#125;out()\n\n不能使用eval()和with()eval(&#x27;var a=2&#x27;)console.log(a)//2,严格模式无法使用const obj=&#123;    a:3&#125;function test()&#123;    with (obj) &#123;//改变this指向        console.log(a)//3,严格模式无法使用    &#125;&#125;test()\n\neval和arguments不能作为标识符let eval=&#x27;111&#x27;//严格模式报错\n\n\n\n\n\n\n\n","tags":["JavaScript"]}]