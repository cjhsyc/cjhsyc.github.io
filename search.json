[{"title":"ArrayBuffer","url":"/2022/04/09/ArrayBuffer/","content":"ArrayBuffer存储固定btye（字节）的二进制数据，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。\n使用：\nconst buf = new ArrayBuffer(32) //生成一段32字节的连续内存空间，每个字节的值默认都是 0。\n\nbtyeLength二进制数组的字节长度\nconst buffer = new ArrayBuffer(32)buffer.byteLength // 32\n\nslice截取\nconst buffer = new ArrayBuffer(32)const newBuffer = buffer.slice(2,6) //拷贝第2至5个字节\n\nisView表示参数是否为ArrayBuffer的视图实例。\nconst buffer = new ArrayBuffer(8);ArrayBuffer.isView(buffer) // falseconst v = new Int32Array(buffer);ArrayBuffer.isView(v) // true\n\nTypedArray视图TypedArray一共包括九种：\n\nInt8Array：8 位有符号整数，长度 1 个字节。\nUint8Array：8 位无符号整数，长度 1 个字节。\nUint8ClampedArray：8 位无符号整数，长度 1 个字节，溢出处理不同。\nInt16Array：16 位有符号整数，长度 2 个字节。\nUint16Array：16 位无符号整数，长度 2 个字节。\nInt32Array：32 位有符号整数，长度 4 个字节。\nUint32Array：32 位无符号整数，长度 4 个字节。\nFloat32Array：32 位浮点数，长度 4 个字节。\nFloat64Array：64 位浮点数，长度 8 个字节。\n\n以上九种构造函数统称为TypedArray视图，数组的大部分方法它们都能使用。（concat不能）\n特点：\n\n每个数组成员的类型相同\n每个数组成员的默认值为0\n\n使用：\nconst b = new ArrayBuffer(8);// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾const v1 = new Int32Array(b);// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾const v2 = new Uint8Array(b, 2);// 创建一个指向b的Int16视图，开始于字节2，长度为2const v3 = new Int16Array(b, 2, 2);\n\n参数1：ArrayBuffer对象，参数2：视图开始的字节数，必须为每个成员字节数的整数倍（可选），参数3：视图的长度（可选）\n上面三个视图指向同一个ArrayBuffer对象，只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。\nTypedArray视图还可以不接收ArrayBuffer生成：\n\n数字（长度）：const f64a = new Float64Array(8) //8个Float64  \n普通数组：const typedArray = new Uint8Array([1, 2, 3, 4])\n另一个TypedArray\n\nDataView视图使用：\nconst buffer = new ArrayBuffer(24);const dv = new DataView(buffer);\n\n参数1：ArrayBuffer对象，参数2：视图开始的字节数（可选），参数3：视图的长度（可选）\nDataView实例提供 8 个方法读取内存：（参数：开始的字节序号）\n\ngetInt8：读取 1 个字节，返回一个 8 位整数。\ngetUint8：读取 1 个字节，返回一个无符号的 8 位整数。\ngetInt16：读取 2 个字节，返回一个 16 位整数。\ngetUint16：读取 2 个字节，返回一个无符号的 16 位整数。\ngetInt32：读取 4 个字节，返回一个 32 位整数。\ngetUint32：读取 4 个字节，返回一个无符号的 32 位整数。\ngetFloat32：读取 4 个字节，返回一个 32 位浮点数。\ngetFloat64：读取 8 个字节，返回一个 64 位浮点数。\n\nDataView 视图提供 8 个方法写入内存：（参数1：开始的字节序号，参数2：写入的数据）\n\nsetInt8：写入 1 个字节的 8 位整数。\nsetUint8：写入 1 个字节的 8 位无符号整数。\nsetInt16：写入 2 个字节的 16 位整数。\nsetUint16：写入 2 个字节的 16 位无符号整数。\nsetInt32：写入 4 个字节的 32 位整数。\nsetUint32：写入 4 个字节的 32 位无符号整数。\nsetFloat32：写入 4 个字节的 32 位浮点数。\nsetFloat64：写入 8 个字节的 64 位浮点数。\n\nget和set方法还可接收最后一个参数：false：表示使用大端字节序（默认），true：表示使用小端字节序\n\n大端字节序：从多字节数据类型的第一个字节开始读取（或存储）\n小端字节序：从多字节数据类型的最后一个字节开始读取（或存储）\n\n参考文献\n","categories":["ES6"],"tags":["ES6","ArrayBuffer","TypedArray","DataView"]},{"title":"Echarts的容器宽高使用rem，渲染出的图表很小的问题","url":"/2022/03/06/Echarts%E7%9A%84%E5%AE%B9%E5%99%A8%E5%AE%BD%E9%AB%98%E4%BD%BF%E7%94%A8rem%EF%BC%8C%E6%B8%B2%E6%9F%93%E5%87%BA%E7%9A%84%E5%9B%BE%E8%A1%A8%E5%BE%88%E5%B0%8F%E7%9A%84%E9%97%AE%E9%A2%98/","content":"主要是因为div还没有创建出来echarts就已经加载了，因为获取不到宽高，所以会缩小在一起。参考了几篇文章，我在echarts配置后加入如下代码，解决了问题：\nmyChart.setOption(option); //延迟resize setTimeout(function ()&#123;\t myChart.resize() &#125;,200)//随屏幕大小改变 window.addEventListener(&#x27;resize&#x27;,function()&#123;\t myChart.resize() &#125;)\nCSDN:https://blog.csdn.net/cjhsyc/article/details/122584331参考文章：https://www.cnblogs.com/xxxx0130/p/14182677.htmlhttps://blog.csdn.net/weixin_40180205/article/details/106116073\n","categories":["数据可视化","Echarts"],"tags":["Echarts"]},{"title":"MongoDB","url":"/2022/04/10/MongoDB/","content":"安装（win系统）下载下载地址\n下载zip压缩包，并解压。\n创建服务在mongodb目录下创建两个目录data和logs，分别用于存放数据和日志（和bin目录同级）\n管理员身份运行cmd，进入mongodb下的bin目录。\ncmd下进行安装：（两个path后输入自己新建的两个目录的地址，logs目录后需要加上mongodb.log）\nmongod --install --dbpath D:\\MongoDB\\data --logpath D:\\MongoDB\\logs\\mongodb.log\n\n没有报错即为成功\n验证：键盘点击win+R，输入services.msc，能找到MongoDB即可\n启动服务cmd中：\nnet start mongodb #启动mongo #进入mongodbexit #退出\n\n\n\n基本使用MongoDB/bin下打开cmd：输入mongo开始使用\n\n查看数据库：show databases\n选择数据库：use test1（隐式创建：选择不存在的数据库不会报错，如果之后该数据库有数据时会自动创建）\n查看集合：show collections\n创建集合：db.createCollection(&#39;集合名&#39;)\n删除集合：db.集合名.drop()\n\n增删改查\n插入数据：db.集合名.insert(JSON数据)\nuse test2db.c1.insert(&#123;uname:&#x27;luo&#x27;,age:18&#125;) #注：集合不存在则隐式创建#注：MongoDB会给每条数据添加一个_id(全球唯一)\n\n一次性插入多条数据：插入数组即可\n多次插入数据：mongodb支持部分js语法，所以可以使用循环：\nfor(var i=0;i&lt;3;i++)&#123;    db.c1.insert(&#123;uname:&#x27;a&#x27;+i,age:i&#125;) &#125;\n\n查询数据：db.集合名.find()\ndb.c1.find() #查询所有数据#输出：&#123; &quot;_id&quot; : ObjectId(&quot;6252c272dbdf6baae7f71b64&quot;), &quot;uname&quot; : &quot;luo&quot;, &quot;age&quot; : 18 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;6252e60235f4e186f4e8dbfa&quot;), &quot;uname&quot; : &quot;a0&quot;, &quot;age&quot; : 0 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;6252e60235f4e186f4e8dbfb&quot;), &quot;uname&quot; : &quot;a1&quot;, &quot;age&quot; : 1 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;6252e60235f4e186f4e8dbfc&quot;), &quot;uname&quot; : &quot;a2&quot;, &quot;age&quot; : 2 &#125;#注：MongoDB会给每条数据添加一个_id(全球唯一)\n\n格式化输出数据：db.集合名.find().pretty()\n条件查询：db.集合名.find(条件)\ndb.c1.find(&#123;age:1&#125;) #age=1的数据db.c1.find(&#123;uname:&#x27;a0&#x27;,age:0&#125;) #多条件查询\n\n其他运算符：db.集合名.find(&#123;键:&#123;运算符:值&#125;)\n\n\n\n运算符\n作用\n\n\n\n$gt\n大于\n\n\n$gte\n大于等于\n\n\n$lt\n小于\n\n\n$lte\n小于等于\n\n\n$ne\n不等于\n\n\n$in\nin\n\n\n$nin\nnot in\n\n\ndb.c1.find(&#123;age:&#123;&amp;gt:1&#125;) #age&gt;1的数据db.c1.find(&#123;age:&#123;&amp;in:[0,2]) #age=0或2的值\n\n查询列：（传入第二个参数）\ndb.c1.find(&#123;&#125;,&#123;age:1&#125;) #只显示age列db.c1.find(&#123;&#125;,&#123;age:0&#125;) #显示除了age列的其他列#注：无论何时_id都会显示\n\n修改数据：db.集合名.update(条件,新数据)\ndb.c1.update(&#123;uname:&#x27;luo&#x27;&#125;,&#123;uname:&#x27;zhang&#x27;&#125;) #不只是修改uname，而是直接用新数据替换（所以修改后age没有了）#注：默认只修改符合条件的第一条数据\n\n其他运算符：\n\n\n\n修改器\n作用\n\n\n\n$inc\n递增\n\n\n$rename\n修改列名\n\n\n$set\n修改列值\n\n\n$unset\n删除列\n\n\ndb.c1.update(&#123;uname:&#x27;luo&#x27;&#125;,&#123;$set:&#123;uname:&#x27;zhang&#x27;&#125;&#125;) #只修改uname，所以age还在db.c1.update(&#123;uname:&#x27;luo&#x27;&#125;,&#123;$inc:&#123;age:3&#125;&#125;) #age增加3（负数为减）db.c1.update(&#123;uname:&#x27;luo&#x27;&#125;,&#123; #同时进行多种修改\t$set:&#123;uname:&#x27;zhang&#x27;&#125;,\t$inc:&#123;age:3&#125;&#125;)\n\n是否新增：第三个参数（true：未匹配到数据则新插入一条数据，false：默认值，不新增）\n是否修改多条：第四个参数（true：修改所有匹配的数据，false：默认值，修改匹配到的第一条数据）\n\n删除数据：db.集合名.remove(条件)\n是否只删除一条：第二个参数（true：只删除第一条数据，false：默认值，删除所有匹配的数据）\n\n\n排序和分页\n排序：db.集合名.find().sort(&#123;键：值&#125;)\ndb.c1.find().sort(&#123;age:0&#125;) #根据age进行排序，1表示升序，-1表示降序\n\n分页：db.集合名.find().skip(数字).limit(数字)\ndb.c1.find().limit(2) #查询两条数据，limit：限制查询的数量db.c1.find().skip(1) #skip：跳过指定的数量db.c1.find().skip(1).limit(2) #一起使用时，skip写在前面db.c1.find().count() #count:计数，显示结果的条数\n\n聚合查询db.集合名.aggregate([\t&#123;管道:&#123;表达式&#125;&#125;\t...])\n\n常用管道\n$group\t将集合中的文档分组，用于统计结果$match\t过滤数据，只要输出符合条件的文档$sort\t聚合数据进一步排序$skip\t跳过指定文档数$limit\t限制集合数据返回文档数\n\n常用表达式\n$sum\t总和$avg\t平均$min\t最小值$max\t最大值\n\n\n分组\ndb.c1.aggregate([\t&#123;\t\t$group:&#x27;$sex&#x27;,  # $group：分组，按sex进行分组，sex前需加上$符\t\tsum:&#123;$sum:&#x27;$age&#x27;&#125; # $sum：总和，同一组的age的总和，age前需加上$符，并将结果显示在sum列中\t&#125;])db.c1.aggregate([\t&#123;\t\t$group:null, # $group为null表示不分组\t\tsum:&#123;$sum:1&#125;, # $sum为1表示统计每组的数据条数\t\tavg:&#123;$avg:&#x27;$age&#x27;&#125; # $avg：平均值\t&#125;])\n\n多个管道\ndb.c1.aggregate([\t&#123;\t\t$group:&#x27;$sex&#x27;,\t\tsum:&#123;$sum:&#x27;$age&#x27;&#125;\t&#125;，\t&#123;\t\t$sort:&#123;sum:1&#125; #sort:排序，sum:1表示按照sum升序\t&#125;])\n\n索引索引是一个排序好的数据结构，可以提高数据查询的效率，但大量索引也会影响数据，因为每次插入和修改数据都需要更新索引\n\n创建索引：db.集合名.createIndex(待创建索引的列)\ndb.c1.createIndex(&#123;uname:1&#125;) #按照name字段升序创建索引db.c1.createIndex(&#123;uname:1,age:1&#125;) #复合索引\n\n自定义索引名：(第二个参数对象中，name:指定索引名)\ndb.c1.createIndex(&#123;uname:1&#125;,&#123;name:&#x27;unameIndex&#x27;&#125;)\n\n唯一索引：(第二个参数对象中，unique:是否唯一)\n#建立唯一索引后，所有数据的uname不能重复db.c1.createIndex(&#123;uname:1&#125;,&#123;unique:true&#125;)\n\n查看索引：db.集合名.getIndexes()\ndb.c1.getIndexes()#结果：[        &#123;                &quot;v&quot; : 2,                &quot;key&quot; : &#123;                        &quot;_id&quot; : 1                &#125;,                &quot;name&quot; : &quot;_id_&quot;        &#125;,        &#123;                &quot;v&quot; : 2,                &quot;key&quot; : &#123; #根据哪个key建立的索引                        &quot;uname&quot; : 1                &#125;,                &quot;name&quot; : &quot;uname_1&quot; #索引名        &#125;]\n\n删除索引：db.集合名.dropIndex(索引名)\n#先通过getIndexes()查看索引名db.c1.dropIndex(&#x27;uname_1&#x27;)db.c1.dropIndexes() #删除全部索引（除系统自带的）\n\n分析（explain）explain()帮助我们查看此次查询的相关数据（是否使用索引查询，查询速度）\n基本使用：\ndb.c1.find(&#123;age:1&#125;).explain()\n\n权限机制开启验证模式\n添加超级管理员（输入mongo进入MongoDB后use admin）\n#创建账号db.createUser(&#123;\t&quot;user&quot;:&quot;账号&quot;,\t&quot;pwd&quot;:&quot;密码&quot;,\t&quot;roles&quot;:[&#123;\t\trole:&quot;角色&quot;,\t\tdb:&quot;所属数据库&quot; #就是admin\t&#125;]&#125;)#比如：db.createUser(&#123;\tuser:&#x27;admin&#x27;,\tpwd:&#x27;123456&#x27;,\troles:[&#123;\t\trole:&#x27;root&#x27;,\t\tdb:&#x27;admin&#x27;\t&#125;]&#125;)\n\n卸载服务（管理员身份运行cmd）\n#在MongoDB/bin目录下执行mongod --remove\n\n安装需要身份验证的MongoDB服务（添加--auth）\nmongod --install --dbpath D:\\MongoDB\\data --logpath D:\\MongoDB\\logs\\mongodb2.log --auth注：.log文件名不能和之前安装时的重复#启动服务net start mongodb\n\n登录\n#进入MongoDBmongo#查看数据库，结果为空，因为没有身份验证show dbs\n\n通过超级管理员登录：\n\n方式一：mongo IP地址:端口/数据库 -u 用户名 -p 密码\n#默认端口：27017mongo 127.0.0.1:27017/admin -u admin -p 123456#即可查看数据库show dbs\n\n方式二：\n#先进入mongo#使用数据库use admin#登录(输出1：表示成功)db.auth(&#x27;admin&#x27;,&#x27;123456&#x27;)\n\n创建其他角色#角色种类超级用户角色:root数据库用户角色：read,readWrite数据库管理角色:dbAdmin,userAdmin集群管理角色:clusterAdmin、clusterManager、clusterMontitor、hostManager;备份恢复角色:backup、restore;所有数据库角色:readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase#角色说明root：只在admin数据库中可用。超级账号，超级权限read：允许用户读取指定数据库readWrite：允许用户读写指定数据库dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除、查看统计或访问system.profile\n\n例：创建角色test1可以读写test1数据库\nuse test1db.createUser(&#123;\tuser:&#x27;test1&#x27;,\tpwd:&#x27;test1&#x27;,\troles:[&#123;\t\trole:&#x27;readWrite&#x27;,\t\tdb:&#x27;test1&#x27;\t&#125;]&#125;)#注：创建的角色信息存在admin数据库下的system.usersuse admindb.system.users.find().pretty()\n\n退出，并登录为test1后，只能读写test1数据库\n\n\n备份还原安装MongoDB Database Tools下载地址\n选择zip进行下载，解压后将bin目录下的内容复制到MongoDB/bin下即可\nmongodump(备份)语法：\n# 导出数据mongodump -h -port -u -p -d -o# 说明# -h\thost \t服务器IP地址(一般不写 默认本机)# -port\t\t \t端口(一般不写 默认27017)# -u\tuser \t账号# -p \tpwd\t \t密码# -d\tdatabase数据库(注意：数据库不写则导出全局)# -o\topen\t备份到指定目录下\n\n备份所有数据：\n# MongoDB/bin下执行，需新建一个备份目录（bak）mongodump -u admin -p 123456 -o D:\\MongoDB\\bak\n\n备份指定数据：\nmongodump -u test1 -p test1 -d test1 -o D:\\MongoDB\\bak2# 注：超级管理员只能备份全部数据库，不能备份单个数据库\n\nmongoerstore（还原）语法：\nmongorestore -h -port -u -p -d --drop 备份数据目录#说明:# -d\t\t不写则还原全部数据库# --drop\t表示先删除数据库再导入\n\n还原所有数据库\nmongorestore -u admin -p 123456 --drop D:\\MongoDB\\bak\n\n还原指定数据库\nmongorestore -u test1 -p test1 -d test1 --drop D:\\MongoDB\\bak2\\test1\n\nmongoose是Node中提供的用来操作MongoDB的模块\nmongoose文档\n安装:\nyarn add mongoose或npm i mongoose\n\n使用：（js文件，node命令运行）\n//导入mongoose const mongoose = require(&#x27;mongoose&#x27;)//连接数据库(参数1：url，参数2：options，参数3：回调函数)const db = mongoose.connect(&#x27;mongodb://admin:123456@localhost/admin&#x27;, &#123;&#125;, error =&gt; &#123;  if (error) &#123;    console.log(&#x27;error:&#x27; + error)  &#125; else &#123;    console.log(&#x27;ok&#x27;)  &#125;&#125;)\n\nSchemaMongoose 的一切始于 Schema。每个 schema 都会映射到一个 MongoDB 集合，并定义这个集合里的文档的构成。\nconst Schema = mongoose.Schema;const mySchema = new Schema(&#123;  name: String,  age: Number,  date: &#123;type: Date, default: Date.now()&#125; //date字段的数据类型是Date，默认值为Date.now&#125;);\n\n允许使用的 SchemaTypes 有:\n\nString\nNumber\nDate\nBuffer\nBoolean\nMixed\nObjectId\nArray\n\nModelModel是从 Schema 编译来的构造函数。 它们的实例就代表着可以从数据库保存和读取的 documents（文档）。 从数据库创建和读取 document 的所有操作都是通过 model 进行的。\n//参数1：集合名（不是s结尾会自动加上s）const model = mongoose.model(&#x27;user&#x27;, mySchema)\n\n添加数据：\nconst insertObj = new model(&#123;  name: &#x27;罗小黑&#x27;,  age: 8&#125;)insertObj.save().then(res =&gt; &#123;  console.log(res)&#125;)\n\n查询数据：\n//查询一条model.findOne(&#123;age: 8&#125;).then(res =&gt; &#123;  console.log(res)&#125;)//查询所有model.find(&#123;age: 8&#125;).then(res =&gt; &#123;  console.log(res)&#125;)//跳过和分页model.find(&#123;age: 8&#125;).skip(1).limit(1).then(res =&gt; &#123;  console.log(res)&#125;)\n\n接口接口就是一个文件（js&#x2F;json&#x2F;php等），主要响应JSON数据或XML数据。\n推荐的JSON数据格式：\n&#123;\tmeta:&#123;\t\tstatus:状态码,\t\tmsg:&#x27;提示信息&#x27;\t&#125;,\tdata:数据&#125;\n\n接口开发规范（Restful API）Restful API：提供了接口设计规则和约束条件（一个规范），统一开发标准，便于团队协作。\n举例：\n列表页:访问-/模块名\t\t\t\t (get)详情页:访问-/模块名/编号\t\t\t(get)添加页:访问-/模块名/create\t\t (get)处理:访问-/模块名\t\t\t\t  (post)修改页:访问-/模块名/编号/edit\t\t(get)处理:访问-/模块名/编号\t\t\t (put)删除:访问-/模块名/编号\t\t\t(delete)HTTP动词: get、post、put、delete\n\n接口开发使用express框架：\nyarn add express\n\n新建http.js\nconst express = require(&#x27;express&#x27;)const app = express()app.listen(3000,()=&gt;&#123;  console.log(&#x27;http://localhost:3000&#x27;)&#125;)app.get(&#x27;/&#x27;,((req, res) =&gt; &#123;  res.send(&#x27;hello!&#x27;)&#125;))\n\n实战练习编写学生添加接口：\n新建models/stu.js:(操作数据库)\nconst mongoose = require(&#x27;mongoose&#x27;)mongoose.connect(&#x27;mongodb://test1:test1@localhost/test1&#x27;, &#123;&#125;, error =&gt; &#123;  if (error) &#123;    console.log(&#x27;数据库连接失败:&#x27; + error)  &#125; else &#123;    console.log(&#x27;数据库连接成功&#x27;)  &#125;&#125;)const Schema = mongoose.Schema;const mySchema = new Schema(&#123;  name: String,  age: Number,  sex: String&#125;);const model = mongoose.model(&#x27;stu&#x27;, mySchema)//添加学生const insert = (data) =&gt; &#123;  const obj = new model(data)  return obj.save().then(res =&gt; &#123;    console.log(&#x27;添加数据成功&#x27;)    return res  &#125;, err =&gt; &#123;    console.log(&#x27;添加数据失败：&#x27; + err)  &#125;)&#125;//获取学生列表const findStus = (skip,limit) =&gt; &#123;  return model.find().skip(skip).limit(limit).then(res =&gt; &#123;    console.log(&#x27;获取数据成功&#x27;)    return res  &#125;, err =&gt; &#123;    console.log(&#x27;获取数据失败：&#x27; + err)  &#125;)&#125;module.exports = &#123;  insert,findStus&#125;\n\n新建constroller/stu.js:(业务逻辑)\nconst path = require(&#x27;path&#x27;)const &#123;insert, findStus&#125; = require(path.resolve(__dirname, &#x27;../models/stu&#x27;))//添加学生const create = async (req, res) =&gt; &#123;  const data = req.body  const result = await insert(data)  if (result) &#123;    res.send(&#123;      meta: &#123;        status: 200,        msg: &#x27;ok&#x27;      &#125;,      data: result    &#125;)  &#125; else &#123;    res.send(&#123;      meta: &#123;        status: 500,        msg: &#x27;error&#x27;      &#125;    &#125;)  &#125;&#125;//获取学生列表const getStus = async (req, res) =&gt; &#123;  const &#123;pageno, pagesize&#125; = req.query //获取页数和每页显示的数量  const result = await findStus((pageno - 1) * pagesize, pagesize)  if (result) &#123;    res.send(&#123;      meta: &#123;        status: 200,        msg: &#x27;ok&#x27;      &#125;,      data: result    &#125;)  &#125; else &#123;    res.send(&#123;      meta: &#123;        status: 500,        msg: &#x27;error&#x27;      &#125;    &#125;)  &#125;&#125;module.exports = &#123;  create,  getStus&#125;\n\n安装body-parser：（在 Express 中没有内置获取表单 POST 请求体的 API , 我们需要添加第三方插件库）\nyarn add body-parser\n\nhttp.js:\nconst express = require(&#x27;express&#x27;)const path = require(&#x27;path&#x27;)const bodyParser = require(&#x27;body-parser&#x27;)const app = express()//配置 body-parser 中间件 (插件, 专门用来解析表单 POST 请求)// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded(&#123;extended: false&#125;))//parse application/jsonapp.use(bodyParser.json())app.listen(3000, () =&gt; &#123;  console.log(&#x27;http://localhost:3000&#x27;)&#125;)app.get(&#x27;/&#x27;, ((req, res) =&gt; &#123;  res.send(&#x27;hello!&#x27;)&#125;))//绝对路径const stu = require(path.resolve(__dirname, &#x27;controller/stu&#x27;))//添加学生app.post(&#x27;/stu&#x27;, stu.create)//获取学生列表app.get(&#x27;/stu&#x27;,stu.getStus)\n\n使用接口调试工具（postman等）进行测试\n接口文档（apiDoc）apiDoc文档\napiDoc是node的一个模块，能够根据注释快速生成接口文档。\n全局安装：\nnpm i apidoc -g\n\n项目根目录新建apidoc.json：\n&#123;  &quot;name&quot;: &quot;接口文档名&quot;,  &quot;version&quot;: &quot;0.1.0&quot;,  &quot;description&quot;: &quot;接口文档描述&quot;,  &quot;title&quot;: &quot;Custom apiDoc browser title&quot;,  &quot;url&quot; : &quot;http://loaclhost:3000&quot;&#125;\n\n编写注释：（在实现业务逻辑的函数前写注释）\n/** * @api &#123;get&#125; /user   学生列表 * @apiName GetUser * @apiGroup User * * @apiParam &#123;Number&#125; pageno     获取第几页 * @apiParam &#123;Number&#125; pagesize   每页显示条数 * * @apiSuccess &#123;Object&#125; meta 状态码&amp;提示 * @apiSuccess &#123;Array&#125; data  数据 */\n\n生成接口文档：apidoc -i 接口注释所在目录 -o 接口文档生成目录\napidoc -i ./controller -o ./apidoc# 根目录执行\n\n生成apidoc目录，该目录下的index.html即为接口文档\n参考视频\n","categories":["MongoDB","Node"],"tags":["MongoDB","mongoose","express","apiDoc"]},{"title":"HTTP缓存","url":"/2022/03/27/HTTP%E7%BC%93%E5%AD%98/","content":"强制缓存对于强制缓存而言，如果浏览器判断所请求的目标资源有效命中，则可直接从强制缓存中返回请求响应，无需与服务器进行任何通信。\nExpires服务器返回资源时在响应头中设置Expires字段，指定过期时间。在过期时间之前，浏览器再次访问该资源，则直接从强制缓存中获取。\nExpires:New Date(&#x27;2022-03-27 15:08:38&#x27;).toUTCString()\n\n缺点这个方式存在一个很大的漏洞，即对本地时间戳过分依赖，如果客户端本地的时间与服务器端的时间不同步，或者对客户端时间进行主动修改，那么对于缓存过期的判断可能就无法和预期相符。\ncache-controlCache-Control 作为响应头，用以控制缓存策略，这也是前端 HTTP 缓存策略的基础。\nmax-agecache-control设置max-age&#x3D;60属性值来控制响应资源的有效期，它是一个以秒为单位的时间长度，表示该资源在被请求到后的60秒内有效，如此便可避免服务器端和客户端时间戳不同步而造成的问题。\ncache-control:max-age=60//滑动时间，单位为秒\n\ncache-control还可以配置一些其他属性值，下面介绍。\nno-store和no-cacheno-store和no-cache是一组互斥属性\nno-store：表示禁止使用缓存\nno-cache：表示强制进行协商缓存\npublic和privatepublic和private是一组互斥属性\npublic：表示响应资源既可以被浏览器缓存，又可以被代理服务器缓存。\nprivate：响应资源只能被浏览器缓存，若未显式指定则默认值为private。\n对于应用程序中不会改变的文件，你通常可以在发送响应头前添加积极缓存（public）。这包括例如由应用程序提供的静态文件，例如图像，CSS 文件和JavaScript文件。\ns-maxages-maxage：表示代理服务器缓存的过期时间。\n协商缓存协商缓存就是在使用本地缓存之前，需要向服务器端发起一次GET请求，与之协商当前浏览器保存的本地缓存是否已经过期。\nlast-modified&#x2F;if-modified-since响应头中设置：\ncache-control:no-cache//进行协商缓存last-modified:xxx//资源最后一次修改的时间\n\n浏览器再次访问时请求头中会加上if-modified-since字段：\nif-modified-since:xxx//值为上次请求时响应头的last-modified的值\n\n服务器判断if-modified-since和此次的last-modified是否一致。如果一致则只需返回状态码304，表示从缓存中获取数据计可。如果不一致，就需要返回新的数据和last-modified。\n缺陷首先，它只是根据资源最后的修改时间戳进行判断的，虽然请求的文件资源进行了编辑，但内容并没有发生任何变化，时间戳也会更新，从而导致协商缓存时关于有效性的判断验证为失效，需要重新进行完整的资源请求。这无疑会造成网络带宽资源的浪费，以及延长用户获取到目标资源的时间。\n其次，标识文件资源修改的时间戳单位是秒，如果文件修改的速度非常快，假设在几百毫秒内完成，那么上述通过时间戳的方式来验证缓存的有效性，是无法识别出该次文件资源的更新的。\netag和if-none-match其内容主要是服务器为不同资源进行哈希运算所生成的一个字符串，只要文件内容编码存在差异，对应的 etag标签值就会不同，因此可以使用etag对文件资源进行更精准的变化感知。\n响应头中设置：\netag:xxx//根据资源进行哈希运算所生成的一个字符串\n\n浏览器再次访问时请求头中会加上if-none-match字段：\nif-none-match:xxx//值为上次请求时响应头的etag的值\n\n服务器判断if-none-match和此次的etag是否一致。如果一致则只需返回状态码304，表示从缓存中获取数据计可。如果不一致，就需要返回新的数据和etag。\n缺陷一方面，服务器对于生成文件资源的etag需要付出额外的计算开销，如果资源的尺寸较大，数量较多且修改比较频繁，那么生成etag的过程就会影响服务器的性能。\n另一方面，etag字段值的生成分为强验证和弱验证，强验证根据资源内容进行生成，能够保证每个字节都相同;弱验证则根据资源的部分属性值来生成，生成速度快但无法确保每个字节都相同，并且在服务器集群场景下，也会因为不够准确而降低协商缓存有效性验证的成功率，所以恰当的方式是根据具体的资源使用场景选择恰当的缓存校验方式。\ncache-control请求头Cache-Control 也可以作为请求头，以最常见的 no-cache 及 max-age=0 为例，二者均会重新向服务器发起请求，哪怕该请求已被强缓存。\n\nCache-Control: no-cache 作为请求头，表示即便在客户端拥有未过期的缓存，也要向服务器请求获得最新的资源。\nCache-Control: max-age=0 作为请求头，将会验证服务器资源的新鲜度，如果缓存未过期，则利用缓存，返回 304 状态码，否则重新获取资源返回 200 状态码。\n\n结论：\n\n只有服务端才能开启缓存，默认是不会走缓存的\n\n走了强缓存就不会再向服务端发送请求了\n\n客户端的请求头中只有设置了cache-control为：’no-store’ | ‘no-cache’ | ‘max-age&#x3D;0’才会生效（也就是客户端不想走强缓存的时候生效），除非后端对这个字段做特殊处理\n\n\n最佳实践关于 http 缓存配置的最佳实践为以下两条：\n\n文件路径中带有 hash 值：一年的强缓存。因为该文件的内容发生变化时，会生成一个带有新的 hash 值的 URL。前端将会发起一个新的 URL 的请求。配置响应头 Cache-Control: public,max-age=31536000,immutable\n文件路径中不带有 hash 值：协商缓存。大部分为 public 下文件。配置响应头 Cache-Control: no-cache 与 etag/last-modified\n\n但是当处理永久缓存时，切记不可打包为一个大的 bundle.js，此时一行业务代码的改变，将导致整个项目的永久缓存失效，此时需要按代码更新频率分为多个 chunk 进行打包，可细粒度控制缓存。\n参考视频\n","categories":["计算机网络"],"tags":["HTTP","cache-control"]},{"title":"axios","url":"/2022/04/08/axios/","content":"axios基本使用安装：\nnpm install axios\n\n发送请求：\naxios(&#123;          url:&#x27;xxx&#x27;,    // 设置请求的地址  method:&quot;GET&quot;, // 设置请求方法  params:&#123;      // get请求使用params进行参数凭借,如果是post请求用data    type: &#x27;&#x27;,    page: 1  &#125;&#125;).then(res =&gt; &#123;    // res为后端返回的数据  console.log(res);   &#125;)\n\n二次封装const requests = axios.create(&#123;    //配置对象    baseURL: process.env.VUE_APP_BASEURL,//基础路径，自动加在端口后    timeout: 5000,//超时的时间    headers:&#123;...&#125;//通用请求头&#125;)\n\n请求拦截器requests.interceptors.request.use(  config =&gt; &#123;    if (store.state.user.token) &#123;        config.headers.token = store.state.user.token    &#125;    return config  &#125;,  error =&gt; &#123;    return Promise.error(error)  &#125;)\n\n响应拦截器requests.interceptors.response.use((res) =&gt; &#123;    //成功的回调    return res.data//返回数据部分&#125;, (err) =&gt; &#123;    //失败的回调    return Promise.reject(new Error(&#x27;失败&#x27;))&#125;)\n\n取消请求方式一：\nconst CancelToken = axios.CancelToken;const source = CancelToken.source(); axios.post(url, &#123;    data&#125;, &#123;    cancelToken: source.token&#125;)// 取消请求 (请求原因是可选的)source.cancel(&#x27;主动取消请求&#x27;);\n\n方式二：\nconst CancelToken = axios.CancelToken;let cancel;axios.get(url, &#123;  cancelToken: new CancelToken(function executor(c) &#123;    cancel = c;  &#125;)&#125;);cancel(&#x27;主动取消请求&#x27;);\n\n简易原理class Axios &#123;    constructor() &#123;    &#125;    request(config) &#123;        return new Promise(resolve =&gt; &#123;            const &#123;url = &#x27;&#x27;, method = &#x27;get&#x27;, data = &#123;&#125;&#125; = config;            // 发送ajax请求            const xhr = new XMLHttpRequest();            //参数3：是否为异步请求，默认为true            xhr.open(method, url, true);            xhr.onload = function() &#123;                console.log(xhr.responseText)                resolve(xhr.responseText);            &#125;            xhr.send(data);        &#125;)    &#125;&#125;//生成axios实例function CreateAxiosFn() &#123;    let axios = new Axios();    let req = axios.request.bind(axios);    return req;&#125;// 得到最后的全局变量axioslet axios = CreateAxiosFn();\n","categories":["axios"],"tags":["axios","xhr","ajax"]},{"title":"Vue解决SEO","url":"/2022/03/27/Vue%E8%A7%A3%E5%86%B3SEO/","content":"SEO：搜索引擎优化seo需要的几个关键点：\n\n多页面\ntitle、描述、关键词\n网站的内容\n\nvue-cli无法实现以上三点：\n\nvue项目是SPA：单页面应用\nvue项目只有一套title、描述、关键词\nvue项目的内容是通过引入js文件加载的，无法通过源代码的HTML文件中直接读取\n\n预渲染在html页面生成之前数据就已经加载完成。预渲染的流程：\n\n读取配置，获取需要预渲染的页面\n\n发布机模拟浏览器环境打开页面\n\n页面脚本触发渲染时机\n\n渲染出当前的页面内容\n\n获取当前所有的DOM结构\n\n生成HTML文件\n\n\nprerender-spa-plugin提供一个预渲染解决方案。\n安装插件prerender-spa-plugin：\nnpm i prerender-spa-plugin\n\n在vue.config.js中进行配置：\nconst path = require(&#x27;path&#x27;)const PrerenderSPAPlugin = require(&#x27;prerender-spa-plugin&#x27;) module.exports = &#123;\tpublicPath:&#x27;./&#x27;,\tconfigureWebpack:&#123;    \tplugins: [\t        new PrerenderSPAPlugin(&#123;          \t\tstaticDir: path.join(__dirname, &#x27;dist&#x27;),          \t\t//将指定的路由分别预渲染为HTML页面(打包后生成多个HTML页面)         \t\troutes: [ &#x27;/&#x27;, &#x27;/about&#x27;, &#x27;/some/deep/nested/route&#x27; ],        \t&#125;)      \t]\t&#125; &#125;\n\nvue-meta-info修改title、描述、关键词。\nnpm i vue-meta-info\n\n在路由对应 的Vue文件中设置对应的meta-info：\n&lt;template&gt;    ...&lt;/template&gt; &lt;script&gt;  export default &#123;    metaInfo: &#123;      title: &#x27;My Example App&#x27;, // 设置title      meta: [&#123;                         name: &#x27;keyWords&#x27;,//关键字        content: &#x27;My Example App&#x27;//描述      &#125;]      /*link: [&#123;//设置link        rel: &#x27;asstes&#x27;,        href: &#x27;https://assets-cdn.github.com/&#x27;      &#125;]*/    &#125;  &#125;&lt;/script&gt; \n\n存在的问题prerender-spa-plugin无法配置动态路由，适合一个项目只需要其中几个页面需要做seo。\nvue-meta-info无法给title、描述和关键字设置动态数据。\n服务器渲染（SSR）在客户端和后端之间再添加一个服务器端（比如node.js）,后端将返回的数据交给服务器端，服务器端将html返回给客户端。\nNUXTNUXT中文官网\n一个基于 Vue.js 的服务端渲染应用框架\n安装:\nnpx create-nuxt-app &lt;项目名&gt;\n\n安装时需要进行一些选择\n目录结构pages：文件夹中放置路由组件。在该文件夹下的组件会在.nuxt文件夹下的router.js中自动配置路由。\ncomponents：文件夹中放置全局组件，使用其中的组件时无需import，可直接使用。因为配置文件nuxt.config.js配置文件中的components: true（改为false后需要手动引入组件）\nstore：store 目录用于组织应用的 Vuex 状态树 文件。 Nuxt.js 框架集成了 Vuex 状态树 的相关功能配置，在 store 目录下创建一个 index.js 文件可激活这些配置。\nNUXT生命周期服务端生命周期nuxtServerInit在store 目录下新建index.js。在vuex的actions模块中使用nuxtServerInit\nexport const state = () =&gt; &#123;&#125;export const mutations = &#123;&#125;export const actions = &#123;  //参数1：vuex上下文  //参数2：nuxt上下文  //只能在index.js中使用，其他的js文件会被当成子模块，子模块中使用nuxtServerInit无效  nuxtServerInit(store, context) &#123;    console.log(&#x27;nuxtServerInit&#x27;)  &#125;&#125;\n\nmiddleware（中间件）根目录下新建middleware目录，添加js文件（name.js）:\nexport default (&#123;store,route,req,res,redirect,query,params&#125;) =&gt; &#123;//可接收很多参数  console.log(&#x27;middleware&#x27;)    if(route.name=&#x27;home&#x27;)&#123;//前往home路由        redirect(&#x27;/login&#x27;)//重定向到login路由    &#125;&#125;\n\n全局middleware：nuxt.config.js中添加：\nrouter:&#123;  middleware:&#x27;name&#x27;,//对应middleware目录下的js文件名&#125;\n\n局部（组件内）middleware：\n&lt;template&gt;  &lt;Tutorial/&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;IndexPage&#x27;,  // middleware:&#x27;name&#x27;,  middleware()&#123;//不需要在middleware目录下写js文件    console.log(&#x27;局部middleware&#x27;)  &#125;&#125;&lt;/script&gt;\n\nvalidate用于校验路由参数\n在组件中使用：\n&lt;template&gt;  &lt;Tutorial/&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;IndexPage&#x27;,  validate(&#123;params,query&#125;)&#123;//接收路由的参数    console.log(&#x27;validate&#x27;)    return /^\\d+$/.test(query.id)//返回值为true时才能正常访问  &#125;&#125;&lt;/script&gt;\n\nasyncData只能在页面组件中使用，在组件每次加载之前调用，一般用来发送请求、获取数据。\nfetch可以在所有组件中使用\n服务端和客户端共有的生命周期beforeCreate&#x2F;created在NUXT服务器和客户端都执行\n客户端生命周期和vue中一致：\n\nbeforeMount&#x2F;mounted\n\nbeforeUpdate&#x2F;updated\n\nbeforeDestroy&#x2F;destroyed\n\n\nNUXT路由nuxt-link&lt;nuxt-link&gt; 的作用和&lt;router-link&gt;一致。为了提高 Nuxt.js 应用程序的响应能力，当链接将显示在视口中时，Nuxt.js 将自动预获取代码分割页面。\nnuxt中不使用路由懒加载。\n子路由在pages目录下新一个和父路由同名的文件夹，该文件夹下的.vue文件为子路由\n&lt;nuxt-child&gt;相当于&lt;router-view&gt;\n动态路由.vue文件以下划线（’_’）开头的为动态路由\n手动配置router.js使用@nuxtjs&#x2F;router\nnpm i @nuxtjs/router\n\nnuxt.config.js中配置：\nmodules:[\t&#x27;@nuxtjs/router&#x27;]\n\n在根目录下创建router.js文件，手动配置路由，与vue中不同的是向外暴露的不是router实例而是一个函数\nimport Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;Vue.use(Router)import MyPage from &#x27;~/components/my-page&#x27;const routes = [&#123;        path: &#x27;/&#x27;,        component: MyPage      &#125;]export function createRouter() &#123;  return new Router(&#123;    mode: &#x27;history&#x27;,    routes  &#125;)&#125;\n\n路由导航守卫在router.js中使用和vue-cli中一样 (全局守卫，路由独享守卫)\nnuxtjs自动生成路由时使用：\n\n中间件：middleware\n\n配置插件\n根目录新建plugins/router.js\nexport default (&#123;app&#125;) =&gt; &#123;  app.router.beforeEach((to,from,next)=&gt;&#123;    console.log(&#x27;beforeEach&#x27;)    next()  &#125;)&#125;\n\nnuxt.config.js中设置：\nplugins:[\t&#x27;@/plugins/router.js&#x27;]\n\n注意导航守卫在服务器端就已经执行，无法获取localStorage和cookie\n解决方法：安装cookie-universal-nuxt\nnpm i cookie-universal-nuxt\n\nnuxt.config.js中:\nmodules:[\t&#x27;cookie-universal-nuxt&#x27;,]\n\n即可正常使用，如：\n\nthis.$cookies.set\nthis.$cookies.get\n\n配置（nuxt.config.js）headhead用于配置title、描述、关键字：\nhead: &#123;  title: &#x27;app&#x27;,  htmlAttrs: &#123;    lang: &#x27;en&#x27;  &#125;,  meta: [    &#123; charset: &#x27;utf-8&#x27; &#125;,//网页编码    &#123; name: &#x27;viewport&#x27;, content: &#x27;width=device-width, initial-scale=1&#x27; &#125;,    &#123; hid: &#x27;description&#x27;, name: &#x27;description&#x27;, content: &#x27;&#x27; &#125;,    &#123; name: &#x27;format-detection&#x27;, content: &#x27;telephone=no&#x27; &#125;  ],  link: [    &#123; rel: &#x27;icon&#x27;, type: &#x27;image/x-icon&#x27;, href: &#x27;/favicon.ico&#x27; &#125;//网页图标  ]&#125;,\n\n如果当前页面的.vue文件没有单独配置head，则使用nuxt.config.js中的head\n在每个页面中单独配置：（使用函数的形式）\n&lt;template&gt;  &lt;div&gt;about&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;About&quot;,  head() &#123;    return &#123;      title: &#x27;about&#x27;,//可以设置为动态数据      meta: [        &#123;hid: &#x27;keywords&#x27;,name:&#x27;keywords&#x27;,content: &#x27;网站关键字&#x27;&#125;,        &#123;hid: &#x27;description&#x27;, name: &#x27;description&#x27;, content: &#x27;网站描述&#x27;&#125;,      ]    &#125;  &#125;&#125;&lt;/script&gt;\n\ncss配置全局的css文件：（比如：初始化css、UI组件库的css文件）\ncss: [  &#x27;@/static/reset.css&#x27;//static下准备样式初始化文件],\n\nplugins配置全局js文件：（比如：axios二次封装、UI组件库）\nplugins: [  &#x27;@/plugins/router.js&#x27;//plugins文件夹下准备全局js文件],\n\nmodulesmodules是Nuxt.js扩展\nnuxt中安装axios(方式一)：\nnpm i @nuxtjs/axios\n\nmodules中配置：\nmodeules:[\t&#x27;@nuxtjs/axios&#x27;]\n\n方式二：\nnpm i axios\n\n由于nuxt项目中没有main.js文件，使用时需要在.vue文件中单独import。\n这里使用方式一：\n在pages下 的页面组件中使用sayncData发送请求：\n&lt;template&gt;  &lt;div&gt;首页&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;IndexPage&#x27;,  data()&#123;    return&#123;      list:[]      &#125;  &#125;,  async asyncData(&#123;$axios&#125;)&#123;//接收一个参数是页面组件上下文    const res = await $axios.get(&#123;url:&#x27;http://xxxxxxxxxxxxx&#x27;&#125;)    return&#123;//asyncData中的this为undefined，需使用return返回数据，返回的数据会合并到组件的data中      list:res.data    &#125;  &#125;&#125;&lt;/script&gt;\n\n在components下的组件使用fetch发送请求获取数据：\n&lt;template&gt;  &lt;div&gt;news&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;News&quot;,  data() &#123;    return &#123;      list: []    &#125;  &#125;,  async fetch() &#123;//也接收一个参数是页面组件上下文，components下的组件接收不到      //fetch函数的this是组件实例，该函数不能直接将数据返回给页面组件，所有可以在components下的组件使用      //如果要在页面组件中使用需要将数据传到vuex中    const res = await this.$axios.get(&#123;url: &#x27;http://xxxxxxxxxxxxx&#x27;&#125;)    this.list = res.data  &#125;&#125;&lt;/script&gt;\n\n配置代理安装aixos和proxy：\nnpm i @nuxtjs/axiosnpm i @nuxtjs/proxy\n\n配置：\nmodules: [  &#x27;@nuxtjs/axios&#x27;,  &#x27;@nuxtjs/proxy&#x27;,],axios: &#123;  proxy: true,//是否可以跨域  baseUrl: &#x27;xxxxxxx&#x27;,  retry: &#123;retries: 3&#125;,//超时重试次数&#125;,proxy: &#123;//配置代理  &#x27;/api&#x27;: &#123;    target: &#x27;http://localhost:8080&#x27;,    pathRewrite: &#123;      &#x27;^/api&#x27;: &#x27;&#x27;    &#125;  &#125;&#125;,\n\naxios二次封装新建plugins/axios,js:\nexport default (&#123;$axios&#125;) =&gt; &#123;  $axios.defaults.timeout = 10000//超时时间  //请求拦截器  $axios.onRequest(config =&gt; &#123;    console.log(config)  &#125;)  //错误拦截器  $axios.onError((error =&gt; &#123;    console.log(error)  &#125;))  //响应拦截器  $axios.onResponse(response =&gt; &#123;    return response.data  &#125;)&#125;\n\n配置:\nplugins: [  &#x27;@/plugins/axios.js&#x27;,],\n\nloading (加载进度条)配置关闭loading：\nloading:false,//默认为true\n\n配置样式：\nloading:&#123;\tcolor:&#x27;blue&#x27;,\theight:&#x27;5px&#x27;&#125;\n\nVuex状态树新建store/index.js：\nexport const state = () =&gt; &#123;//state使用函数，避免返回引用&#125;export const mutations = &#123;&#125;export const actions = &#123;&#125;export const getters = &#123;&#125;\n\n模块：\n新建js文件，模块名就是文件名\nnuxt项目上线\n打包\nnpm run build\n\n将.nuxt、static、nuxt.config.js、package.json四个文件放到服务器中，服务器下载node环境。\n\n服务器安装依赖并启动（依旧是localhost:3000）\nnpm installnpm run start\n\nnginx代理\n\n\n参考视频\n","categories":["服务端渲染","NUXT","SEO"],"tags":["Vue","SEO","Nuxt"]},{"title":"git多人协作流程","url":"/2022/05/03/git%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B/","content":"Fork在github上找到需要参与开发的项目，fork到自己的github仓库中\ngit clone初始化\ngit clone &lt;url&gt; #克隆远程仓库git init #初始化本地版本库\n\n克隆fork来的仓库\ngit remotegit remote -v #显示所有远程仓库git remote show &lt;remote&gt; #查看指定远程仓库git remote add &lt;remote&gt; &lt;url&gt; #添加远程仓库\n\n添加对应的github远程仓库\ngit remote add upstream &lt;url&gt; #添加目标项目的主仓库git remote add origin &lt;url&gt; #添加fork来的的仓库\n\ngit branchgit branch #查看本地所有分支git branch -r #查看远程所有分支git branch -a #查看本地和远程所有分支git branch &lt;新分支名&gt; #基于当前分支，新建一个分支git checkout -b &lt;新分支名&gt; #基于当前分支新建分支，并切换为这个分支git checkout &lt;分支名&gt; #切换到本地某个分支git checkout --orphan &lt;新分支名&gt; #新建一个空分支（会保留之前分支的所有文件）git branch -d &lt;分支名&gt; #删除本地某个分支git branch &lt;新分支名称&gt; &lt;提交ID&gt; #从提交历史恢复某个删掉的某个分支git branch -m &lt;原分支名&gt; &lt;新分支名&gt; #分支更名\n\n新建一个分支\ngit checkout -b new\n\n在该分支上进行开发\ngit add&#x2F;git commit&#x2F;git pushgit add .  #提交全部文件修改到缓存区git add &lt;具体某个文件路径+全名&gt;  #提交某些文件到缓存区git diff  #查看当前代码 add后，会 add 哪些内容git diff --staged  #查看现在 commit 提交后，会提交哪些内容git status  #查看当前分支状态git commit -m &quot;&lt;注释&gt;&quot;  #提交代码到本地仓库，并写提交注释git commit -v  #提交时显示所有diff信息git commit --amend [file1] [file2]  #重做上一次commit，并包括指定文件的新变化git push [remote] [branch] #上传本地指定分支到远程仓库git push [remote] --force #强行推送当前分支到远程仓库，即使有冲突git push [remote] --all #推送所有分支到远程仓库\n\ngit add添加新增文件，git commit提交修改到本地仓库，git push提交到自己的远程仓库\ngit add test.txtgit commit -m &quot;commit test&quot;git push origin new\n\npull requestgithub中使用pull request将修改的内容请求合并到主仓库中\ngit pullgit pull [remote] [branch] #拉取远程仓库的分支与本地当前分支合并git merge &lt;分支名&gt; #合并指定分支到当前分支git merge --abort #合并分支出现冲突时，取消合并，一切回到合并前的状态\n\n在提交到主仓库之前，先拉取主仓库最新的代码\ngit pull upstream main\n\ngit rmgit rm -r --cached . #移除所有文件git rm --cached &lt;文件路径&gt; #移除指定文件git rm --f &lt;文件路径&gt; #移除指定文件并删除该文件（不会放入回收站）\n\n将已经提交过的文件加入git忽略文件：\ngit rm -r --cached . #移除所有文件#将目标文件加入.gitignoregit add . #重新add所有文件\n\n","categories":["git"],"tags":["git","github"]},{"title":"js垃圾回收","url":"/2022/04/06/js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","content":"js垃圾回收机制\n找出不在使用的变量\n释放器内存空间\n固定的时间间隔执行\n\n标记清除当变量进入执行环境是，就标记这个变量为“进入环境“，进入环境的变量所占用的内存就不能释放。当变量离开环境时，则将其标记为“离开环境“。\n被标记为“离开环境”的变量等待垃圾回收。\n全局变量和闭包所形成的特殊的变量不会被标记为“离开环境”：\nfunction f1()&#123;    let a=1    return function f2()&#123;        a++        console.log(a)    &#125;&#125;const f3 = f1()f3() //2f3() //3\n\n在上述代码中，函数执行完之后变量a并没有消失，因为不会被标记清除，也就是不会被垃圾回收。\n解决：\nf3 = null\n\n引用计数根据一个值的引用次数来判断是否进行垃圾回收，如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。\nconst a = new Object() //a的引用数:1const b = new Object() //b的引用数:1let c = a //a的引用数:2let c = b //a的引用数:1,b的引用数:2a.prop = bb.prop = a //a的引用数:2,b的引用数:2\n\n如上所示，a和b的引用数永远都大于0，不会被垃圾回收。所以使用引用计数来进行垃圾回收的浏览器较少。\n解决：(解除引用)\na = nullb = null\n\nV8引擎垃圾回收V8是一个由Google开源的采用C++编写的高性能JavaScript和WebAssembly引擎，应用在 Chrome和Node.js等。\n在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象(大部分对象)，老生代中存放的生存时间久的对象（比如Vue）。\n新生代的内存空间小（16&#x2F;32M），老生代的内存空间大（0.7&#x2F;1.4G）\n新时代的对象被使用很多次之后会被转移到老生代中，老生代使用的垃圾回收机制就是标记清除。\n新时代的垃圾回收机制是Scavenge，Scavenge又是基于cheney算法的：\ncheney算法将内存分为from和to两个区域（各一半），正在使用的对象都存在from中，假如有一个对象被赋值为null（等待垃圾回收）\n\n将需要被回收的对象留在from中，其他数据转移到to中\n将from和to中的所有数据互换\n将to中的数据回收\n\ncheney算法用空间换取时间（有一半内存不能用）\n参考视频\n","categories":["JavaScript"],"tags":["垃圾回收","JavaScript","V8引擎"]},{"title":"js严格模式","url":"/2022/03/09/js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","content":"严格模式使用严格模式&quot;use strict&quot;\n\n变量a = 10console.log(a)//严格模式报错（必须使用var等声明变量）\n\n静默失败 &#x3D;&gt; 报错var b = 2console.log(Object.getOwnPropertyDescriptor(window, &#x27;b&#x27;))/*configurable: false //var声明的变量默认不可删除enumerable: truevalue: 2writable: true*/delete b//未删除，非严格模式下不报错，程序继续进行（静默失败）//严格模式下报错console.log(b)//2\n\n函数参数唯一function test(a,a)&#123;  console.log(a)//undefined(第二个a),严格模式报错&#125;test(10)\n\n实参和形参的映射关系不存在function test1(a) &#123;  a = 20  console.log(arguments[0])//非严格模式:20,严格模式:10&#125;test1(10)function test2(a = 20) &#123;//参数设置初始后自动开启严格模式  a = 30  console.log(arguments[0])//10&#125;test2(10)\n\n函数的this默认指向undefinedfunction test()&#123;  console.log(this)//undefined&#125;test()\n\n不能使用arguments.callee和callerfunction test()&#123;  console.log(arguments.callee === test)//true,严格模式无法使用  console.log(test.caller === out)//true,严格模式无法使用&#125;function out()&#123;  test()&#125;out()\n\n不能使用eval()和with()eval(&#x27;var a=2&#x27;)console.log(a)//2,严格模式无法使用const obj=&#123;  a:3&#125;function test()&#123;  with (obj) &#123;//改变this指向    console.log(a)//3,严格模式无法使用  &#125;&#125;test()\n\neval和arguments不能作为标识符let eval=&#x27;111&#x27;//严格模式报错\n\n\n\n\n\n\n\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"nginx","url":"/2022/03/30/nginx/","content":"前言已准备好如下软件：\n\nVMware\nXshell和Xftp\n\n安装CentOS7.4下载CentOS7.4下载地址\n选择CentOS-7-x86_64-Minimal-1708.iso进行下载\n使用VMware运行虚拟机\n联网修改网卡配置文件：\nvi /etc/sysconfig/network-scripts/ifcfg-ens33\n将ONBOOT=no改为ONBOOT=yes\n保存退出后，执行：（重启网卡）\nsystemctl restart network\n使用ping命令测试可以联网\n重启网卡失败有可能是VMware软件的问题，可卸载重装\n设置静态ip使用Xshell连接虚拟机（Xshell终端的操作更方便）：\n使用ip addr查看ens33的IP地址\n打开Xshell新建连接：\n\n名称随意、主机填写IP地址\n填写用户名（root）和密码、完成连接\n\n修改配置文件：\nvi /etc/sysconfig/network-scripts/ifcfg-ens33\n将BOOTPROTO=dhcp改为BOOTPROTO=static\n添加如下配置ip地址、子网掩码、网关、DNS：（每人的ip地址不同）\nIPADDR=192.168.181.128NETMASK=255.255.255.0GATEWAY=192.168.181.2DNS1=8.8.8.8\n\n查看网关是否正确：\n\nVMware左上角点击编辑\n虚拟网络编辑器\n更改设置\n选择VMnet8\n点击NET设置即可查看网关\n\n重启网卡：systemctl restart network\nping命令测试联网成功（ping 8.8.8.8）\nNginx安装和启动在安装之前可将虚拟机克隆一份：\n\n虚拟机关机\n右键-管理-克隆\n\nnginx官网\n下载地址： nginx-1.21.6\n点击nginx-1.21.6进行下载、完成后通过Xftp将压缩包传到虚拟机上\n也可以直接在虚拟机里使用wget下载\n可参考文章\n安装所需环境：\n\n安装gcc：yum install -y gcc\n\n安装PCRE pcre-devel：yum install -y pcre pcre-devel\n\n安装zlib：yum install -y zlib zlib-devel\n\n\n解压安装nginx：\n\n解压：tar zxvf nginx-1.21.6.tar.gz \n进入 ：cd nginx-1.21.6\n配置并指定安装目录：./configure --prefix=/usr/local/nginx\n编译、安装：make；make install\n\n启动nginx：\n\n进入安装目录：cd /usr/local/nginx/sbin/\n启动：./nginx\n验证：浏览器访问虚拟机的ip地址（需关闭防火墙）\n\n防火墙：\n\n关闭：systemctl stop firewalld.service\n禁止防火墙开机启动：systemctl disable firewalld.service\n\nnginx服务脚本：\n\n创建脚本文件：vi /usr/lib/systemd/system/nginx.service\n\n文件内容：\n[Unit]Description=nginx - web serverAfter=network.target remote-fs.target nss-lookup.target[Service]Type=forkingPIDFile=/usr/local/nginx/logs/nginx.pidExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.confExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.confExecReload=/usr/local/nginx/sbin/nginx -s reloadExecStop=/usr/local/nginx/sbin/nginx -s stopExecQuit=/usr/local/nginx/sbin/nginx -s quitPrivateTmp=true[Install]WantedBy=multi-user.target\n\n保存退出\n\n重新加载系统服务：systemctl daemon-reload\n\n关闭nginx：./nginx -s stop\n\n启动服务：systemctl start nginx.service\n\n查看：systemctl status nginx.service，出现active (running)表示成功\n\n开机启动： systemctl enable nginx.service\n\n重启：reboot，等待一会后浏览器可访问虚拟机ip地址表示脚本成功执行\n\n\nnginx基本使用在修改配置之前克隆一份虚拟机\n目录结构可使用Xftp查看&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;\n\nconf：配置文件\nhtml：静态页面\nlogs：日志\nsbin：nginx的主程序\n\n“_temp”结尾的文件夹是nginx运行时才生成的\n基本运行原理nginx启动后有一个主进程（Master）和多个子进程（Worker）\nMaster校验配置文件，协调子进程\nWorker处理和响应请求\n配置文件（nginx.conf）进入&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;\n使用Xftp时，右键文件可以通过记事本进行编辑\n编辑nginx.conf：（如下是开头的两行）\n#user  nobody;#该符号表示注释worker_processes  1;\n\n先不看带注释的配置：（最小配置文件）\nworker_processes  1; #子进程个数events &#123;    worker_connections  1024; #单个子进程可接受的连接数&#125;http &#123;    include       mime.types; #include：引入其他配置文件；mime.types：指定各种文件后缀的资源类型    default_type  application/octet-stream; #默认类型        sendfile        on; #使用linux的 sendfile(socket, file, len) 高效网络传输，也就是数据0拷贝。        keepalive_timeout  65;        server &#123; #虚拟主机，可以有多个（vhost）        listen       80; #监听的端口号        server_name  localhost; #域名或主机名（可以写多个，用空格隔开）        location / &#123; #uri            root   html; #根目录（html相当于/usr/local/nginx/html/）            index  index.html index.htm; #默认页        &#125;        error_page   500 502 503 504  /50x.html; #服务器错误时的页面        location = /50x.html &#123;            root   html;        &#125;    &#125;&#125;\n\n虚拟主机配置多个server：\nserver &#123;     listen       80;     server_name  www.my.com; #(需在阿里云购买域名)    location / &#123;        root   /www/www; #在虚拟机上创建对应的目录和目录下的资源        index  index.html index.htm;     &#125;    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   html;    &#125;&#125;server &#123;     listen       80;     server_name  *.my.com; # *号表示通配符（匹配所有的三级域名），域名解析时先匹配前面的server，再匹配第二个    location / &#123;        root   /www/video;        index  index.html index.htm;     &#125;    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   html;    &#125;&#125;\n\n修改配置后重新加载nginx：ststemctl reload nginx\nserver_name:还可以使用正则表达式进行匹配\n可以修改本机的hosts文件进行server_name的测试：C:\\Windows\\System32\\drivers\\etc\\hosts（需管理员权限）\n在最后添加：192.168.181.128 x.com,前者为虚拟机ip地址，后者为自定义域名\n修改后可以在本机通过域名访问虚拟机ip地址\n反向代理反向代理服务器（比如nginx）位于用户和目标服务器（比如Tomcat）之间，用户无法直接访问Tomcat，而由nginx接收请求，然后转发给Tomcat，返回数据给nginx后，再返回给用户。\nproxy_pass配置反向代理：\nserver &#123;    listen       80;    server_name  localhost;    location / &#123; #在这里配置proxy_pass，且不需要root和index    \tproxy_pass  http://www.qq.com; #指定服务器        #root   html;        #index  index.html index.htm;    &#125;    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   html;    &#125;&#125;\n\n重新加载nginx：systemctl reload nginx\n浏览器再次访问虚拟机ip会重定向到腾讯网（外网服务器）(301：重定向，地址栏改变)\n测试代理内网服务器：\n\n克隆一份虚拟机（刚安装配置好nginx的状态）\n\n修改配置文件：vi /etc/sysconfig/network-scripts/ifcfg-ens33\n\n修改IPADDR=192.168.181.128为IPADDR=192.168.181.129\n\n重启网卡：systemctl restart network\n\nXshell连接192.168.181.129\n\n修改&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;index.html\n\nXshell连接192.168.181.128\n\n修改配置：proxy_pass http://192.168.181.129 ; #指定服务器\n\n重新加载nginx：systemctl reload nginx\n\n浏览器访问192.168.181.128，显示192.168.181.129上的index.html（地址栏不变）\n\n\n负载均衡反向代理多个服务器，当nginx接收到请求时，通过轮询的方式将请求转发给服务器（轮流）\n作用：通过负载均衡，将多个请求分摊到多台服务器上，相当于把一台服务器需要承担的负载量交给多台服务器处理，进而提高系统的吞吐率；另外如果其中某一台服务器挂掉，其他服务器还可以正常提供服务，以此来提高系统的可伸缩性与可靠性。\n按照之前的流程再克隆一个虚拟机，ip设置为192.168.181.130并修改index.html\nXshell连接192.168.181.128，进行配置：\nupstream httpds&#123; #upstream:对应多组服务器，httpds：自定名称\tserver 192.168.181.129;\tserver 192.168.181.130;&#125;server &#123;    listen       80;    server_name  localhost;    location / &#123;    \tproxy_pass  http://httpds; #httpds:对应upstream的名称    &#125;    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   html;    &#125;&#125;\n\nupstream和server同级\n重新加载nginx：systemctl reload nginx\n浏览器多次访问192.168.181.128，轮流显示两个服务器中index.html的内容\n负载均衡策略\n权重 weight\nupstream httpds&#123;\tserver 192.168.181.129 weight=8; #添加weight：值越大，访问该服务器的概率越大\tserver 192.168.181.130 weight=2;&#125;\n\n下线 down\nupstream httpds&#123;\tserver 192.168.181.129 weight=8 down; #down：该服务器不会被访问（出现故障时下线该服务器）\tserver 192.168.181.130 weight=2;&#125;\n\n备用 backup\nupstream httpds&#123;\tserver 192.168.181.129 weight=8 down;\tserver 192.168.181.130 weight=2 backup; #backup：备用机，只有其他服务器都不可用时才会被使用&#125;\n\n都需要手动配置文件然后reload nginx\n动静分离将静态资源（比如图片、css、js）放在nginx上\n作用：将静态页面与动态页面或者静态内容接口和动态内容接口分开不同系统访问的架构设计方法，进而提升整个服务访问性能和可维护性。\n在nginx配置中的server下配置多个location即可（也可使用正则）：\nlocation / &#123;\tproxy_pass  192.168.181.129;&#125;# ~号表示开始正则匹配，*号表示不区分大小写location ~*/(img|css|js) &#123; #匹配根目录下的三种文件夹（img|css|js），优先级比location /高\troot html; #根目录：/usr/local/nginx/html/\tindex index.html index.htm;&#125;\n\nURLRewrite重写url，可以隐藏真实的url\nlocation / &#123;\trewrite  ^/([0-9]+).html$  /index.html?pageNum=$1  break;\tproxy_pass  192.168.181.129;&#125;\n\nrewrite  &lt;正则&gt;  &lt;真实uri&gt;  &lt;标识&gt;;\n^:正则开始，$:正则结束\n将匹配到的正则替换为真实uri（$1:表示正则表达式的第一个括号里匹配到的内容）\n四种标识:\n\nlast #本条规则匹配完成后，继续向下匹配新的location URI规则 \nbreak #本条规则匹配完成即终止，不再匹配后面的任何规则 \nredirect #返回302临时重定向，浏览器地址会显示跳转后的URL地址 \npermanent #返回301永久重定向，浏览器地址栏会显示跳转后的URL地址\n\ntry_files按顺序检查文件是否存在，返回第一个找到的文件或文件夹，如果所有的文件或文件夹都找不到，会进行一个内部重定向到最后一个参数。\nlocation / &#123;  root data;  index index.html index.htm;  try_files $uri $uri/ /index.html;&#125;\n\n查找逻辑：\n\n首先：检查 data 目录中是否存在 api 文件，如果存在，则返回文件；如果不存在，则进行下一步。\n其次：检查 data 目录中是否存在 api/ 目录，如果存在，则在检查 api/ 目录中是否存在 index.html 或者 index.htm 文件（由 index 指定）；如果存在，则返回该文件。如果不存在，则进行下一步。\n最后：检查 data 目录中是否存在 index.html 文件。如果存在，则返回文件；如果不存在，则返回 404。\n\n参考视频\n","categories":["部署"],"tags":["nginx","CentOS"]},{"title":"less预处理语言","url":"/2022/03/08/less%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%AD%E8%A8%80/","content":"变量声明和使用//定义变量@color: red;@var: a;@attr: color;@&#123;var&#125; &#123; //作为选择器或者属性名需要添加大括号    @&#123;attr&#125;: @color; //作为属性值直接使用&#125;@btn: &#123;    width: 100px;    height: 40px;    background-color: aqua;&#125;.btn &#123;    @btn(); //需要括号&#125;    @url: &#x27;https://cdn.jsdelivr.net/gh/cjhsyc/image-hosting@master/头像.677yiujw5980.webp&#x27;;.img&#123;    background-image: url(&quot;@&#123;url&#125;&quot;); //作为url使用    background-size: 100px;    width: 100px;    height: 100px;&#125;\n\n运算可以使用+、-、*、&#x2F;进行运算\n@a: 100px + 20px; //120px@b: @a*2; //240px@c: #666/2; //#333\n\n嵌套.parent&#123;    width: 100px;    height: 100px;    border: 1px solid gray;    .child&#123;        background-color: skyblue;        @media (min-width: 900px)&#123;            background-color: pink;        &#125;        @media (min-width: 500px) and (max-width: 900px)&#123;            background-color: greenyellow;        &#125;    &#125;&#125;\n\n相当于\n.parent &#123;  width: 100px;  height: 100px;  border: 1px solid gray;&#125;.parent .child &#123;  background-color: skyblue;&#125;@media (min-width: 900px) &#123;    .parent .child &#123;        background-color: pink;    &#125;&#125;@media (min-width: 500px) and (max-width: 900px) &#123;    .parent .child &#123;        background-color: greenyellow;    &#125;&#125;\n\n混合.mixins &#123;    border: 2px solid skyblue;    width: 300px;    height: 30px;&#125;.box &#123;    .mixins(); //括号可加可不加&#125;\n\n函数使用函数自定义一个绘制三角形的函数\n.triangle(top,@color:black,@height:50px) &#123;    border-color: transparent transparent @color transparent;&#125;.triangle(left,@color:black,@height:50px) &#123;    border-color: transparent @color transparent transparent;&#125;.triangle(bottom,@color:black,@height:50px) &#123;    border-color: @color transparent transparent transparent;&#125;.triangle(right,@color:black,@height:50px) &#123;    border-color: transparent transparent transparent @color;&#125;.triangle(@dir,@color:black,@height:50px) &#123;//@dir用来匹配第一个参数，后面的参数都要一致    width: 0;    height: 0;    border-width: @height;    border-style: solid;&#125;.triangleBox &#123;    .triangle(top,red);//绘制尖朝上的三角形,后两个参数不写则使用默认值&#125;\n\n命名空间和逻辑判断#card&#123;    //when:进行逻辑判断    //not:取反,and:且,或运算使用逗号    .border(@width,@color,@style) when not(@width &gt; 30px) , (@color &gt;= #666) and (@style = solid)&#123;        border: @width @style @color;    &#125;&#125;#main &#123;    //调用其他作用域的函数（ &#x27;&gt;&#x27; 可以省略 ）    #card &gt; .border(40px, #666, solid); //符合条件才生效    //#card.border(40px, #666, solid);//效果同上&#125;\n\n不定参数.boxShadow(@a,@b,...)&#123;//不定参数    box-shadow: @arguments;//@arguments:所有的参数,包括@a,@b    width: 200px;&#125;#box1&#123;    .boxShadow(0,0,10px,gray);&#125;#box2&#123;    .boxShadow(inset,0,0,5px,gray);&#125;\n\n循环//循环（递归调用函数）.columns(@n,@i:1) when (@i &lt;= @n) &#123;    .column-@&#123;i&#125; &#123;        width: @i*100% / @n;        height: 20px;        background-color: pink;    &#125;    .columns(@n, @i+1)&#125;.columns(4);\n\n属性合并.bg&#123;    width: 200px;    height: 200px;    //+ :属性用逗号隔开    //+_ :属性用空格隔开    background+: #666666;    background+_: url(&quot;@&#123;url&#125;&quot;);    background+_: no-repeat;    background+_: center;    box-shadow+: 0 0 5px greenyellow;    box-shadow+: 0 0 10px #000;    background-size: 100px;&#125;\n\n相当于\n.bg &#123;  width: 200px;  height: 200px;  background: #666666 url(&quot;@&#123;url&#125;&quot;) no-repeat center;  box-shadow: 0 0 5px greenyellow,0 0 10px #000;  background-size: 100px;&#125;\n\n继承.linkBtn &#123;    display: block;    width: 200px;    height: 80px;&#125;.linkBtn &#123;    color: white;    background-color: skyblue;&#125;.link:extend(.linkBtn) &#123;    text-decoration: none;    border: 4px solid orange;&#125;\n\n使用混合也可以实现相同的效果，但混合是相当于把代码再复制一份，而继承不是，上述代码转CSS如下：\n.linkBtn,.link &#123;  display: block;  width: 200px;  height: 80px;&#125;.linkBtn,.link &#123;  color: white;  background-color: skyblue;&#125;.link &#123;  text-decoration: none;  border: 4px solid orange;&#125;\n\n导入导入其他less文件\n@import &quot;./assets/style.less&quot;@import (reference) &quot;./assets/style.less&quot;//添加reference后，未被调用的代码不加载\n\n\n\n参考视频\n","categories":["样式","less"],"tags":["less"]},{"title":"nvm管理nodejs版本","url":"/2022/07/23/nvm%E7%AE%A1%E7%90%86nodejs%E7%89%88%E6%9C%AC/","content":"nvm安装地址：nvm-windows\n选择nvm-setup.exe下载安装，安装时设置nvm安装目录（D:\\nvm）和nodejs的链接目录（D:\\nodejs）。\n需要将D:\\nodejs添加到环境变量\nnvm镜像源配置淘宝镜像源（cmd运行）\nnvm node_mirror https://npmmirror.com/mirrors/node/nvm npm_mirror https://npmmirror.com/mirrors/npm/\n\nnvm管理nodejs需管理员身份运行cmd\n\n查看当前所有nodejs版本\nnvm ls\n\n安装指定版本nodejs（只指定大版本时默认安装该大版本的最新版）\nnvm install 16nvm install 16.16.0\n\n使用指定版本的nodejs（需指定完整的版本号）\nnvm use 16.16.0\n\n查看当前node和npm的版本\nnode -vnpm -v\n\n切换npm全局安装位置（需将D:/nodejs/npm_global添加至环境变量）\nnpm config set prefix &quot;D:/nodejs/npm_global&quot;npm config set cache &quot;D:/nodeks/npm_cache&quot;\n\nnrm\n全局安装nrm，管理npm镜像\nnpm i -g nrm\n\n使用淘宝镜像\nnrm lsnrm use taobao\n\n","categories":["nodejs"],"tags":["node","nodejs","nvm","npm","nrm"]},{"title":"vscode","url":"/2022/06/18/vscode/","content":"VS Code安装官网：Visual Studio Code\nvscode又两种版本（user版和system版），默认下载user版。（其他下载中可选择版本，具体区别不明）\n安装时勾选上两个通过Code打开（可以右键文件或文件夹在vscode中打开）\n推荐扩展\nChinese (Simplified)  &#x2F;&#x2F;适用于 VS Code 的中文（简体）语言包\nCode Spell Checker  &#x2F;&#x2F;拼写检查\nESLint  &#x2F;&#x2F;ESLint支持\ngit-commit-plugin  &#x2F;&#x2F;Git Commit模板\nGitLens — Git supercharged  &#x2F;&#x2F;Git历史记录\nGoogle Translate  &#x2F;&#x2F;划词翻译\nIntelliCode  &#x2F;&#x2F;代码提示\nLive Server  &#x2F;&#x2F;实时加载的本地服务器\nmarkdownlint  &#x2F;&#x2F;markdown格式化\nMaterial Icon Theme  &#x2F;&#x2F;图标主题\nopen in browser  &#x2F;&#x2F;右键在浏览器中打开\nPrettier - Code formatter  &#x2F;&#x2F;Prettier格式化\nTabnine AI Autocomplete  &#x2F;&#x2F;代码快速生成\nVue Language Features (Volar)  &#x2F;&#x2F;Vue支持\n\n修改扩展安装位置默认安装位置：C:\\Users\\&#123;用户名&#125;\\.vscode\\extensions\n将extensions文件夹剪切至其他盘（比如：D:\\Microsoft VS Code\\extensions）\n管理员身份运行cmd\nmklink /D &quot;C:\\Users\\&#123;用户名&#125;\\.vscode\\extensions&quot; &quot;D:\\Microsoft VS Code\\extensions&quot;\n\n","categories":["vscode"],"tags":["vscode","extension"]},{"title":"springboot","url":"/2022/05/03/springboot/","content":"创建项目idea创建Spring Initializr项目，自定项目名称，软件包名称改为com.example，java版本为8。\n连不上start.spring.io，可以使用start.aliyun.com。（使用阿里云的服务器创建的springboot版本较低，可自行在pom.xml中修改）\n依赖项选择Web下的Spring Web。\n基本使用src/main/java下新建com.example.controller包，新建java类：BookController：\npackage com.example.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(&quot;/books&quot;)public class BookController &#123;    @GetMapping(&quot;/&#123;id&#125;&quot;)    public String getById(@PathVariable Integer id)&#123;        return &quot;running...&quot;+id;    &#125;&#125;\n\n@RestController：@Controller + @ResponseBody\n@ResponseBody： 可以返回实体对象（返回json数据）\n@PathVariable：使用路径参数\n启动服务执行com.example下的Application即可，springboot内嵌服务器（默认tomcat），端口：8080\n基本配置springboot的配置写在resources下的application.properties：\n# 设置服务器端口server.port = 80\n\n除了properties格式还可以使用yml或yaml文件。\n新建application.yml：\nserver:  port: 80\n\n新建appalication.yaml：\nserver:  port: 80\n\n优先级：properties &gt; yml &gt; yaml\nyaml格式yml和yaml文件都是yaml格式，这是一种数据序列化格式，以数据为中心，重数据轻格式。\n读取yaml数据：\n@Value(&quot;$&#123;server.port&#125;&quot;)private Integer port;\n\n变量引用：\nlastname: wufullname: $&#123;lastname&#125;xian\n\n如果属性值中出现转译字符，需要用双引号包裹：\nlesson: &quot;spring\\nboot&quot;# \\n : 换行\n\n读取所有数据：\n//自动装配到Environment对象@Autowired private Environment env;//使用env.getProperty(&quot;server.port&quot;)\n\n读取数据到类中：\n定义类：（Server）\npackage com.example;import org.springframework.stereotype.Component;//定义为spring管控的类@Component//指定加载的数据@ConfigurationProperties(&quot;server&quot;)public class Server &#123;    //属性名与yml中对应    private Integer port;        // Alt+Ins 自动生成    public Integer getPort() &#123;        return port;    &#125;    public void setPort(Integer port) &#123;        this.port = port;    &#125;    @Override    public String toString() &#123;        return &quot;Server&#123;&quot; +                &quot;port=&quot; + port +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n使用：\n@Autowiredprivate Server server;\n\n整合Mybatis新建项目，依赖项选择sql下的MyBatis Framework 和 MySQL Driver\n使用：\napplication.yml:\nspring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/books    username: root    password: &quot;123456&quot;\n\ncom.example.doamin:Book类\npackage com.example.domain;public class Book &#123;    private Integer id;    private String name;    private String type;    @Override    public String toString() &#123;        return &quot;Book&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, type=&#x27;&quot; + type + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getType() &#123;        return type;    &#125;    public void setType(String type) &#123;        this.type = type;    &#125;&#125;\n\ncom.example.dao:BookDao接口\npackage com.example.dao;import com.example.domain.Book;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;@Mapperpublic interface BookDao &#123;    @Select(&quot;select * from book where id = #&#123;id&#125;&quot;)    public Book getById(Integer id);&#125;\n\n进行测试：\ntest/java/com.example/Boot2MybatisApplicationTests:\npackage com.example;import com.example.dao.BookDao;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass Boot2MybatisApplicationTests &#123;    @Autowired    private BookDao bookDao;    @Test    void contextLoads() &#123;        System.out.println(bookDao.getById(1));    &#125;&#125;\n\n整合Mybatis-Plus使用start.spring.io创建项目，没有提供依赖项MyBatis Plus Framework。（start.aliyun.com有提供）\n可自行上网(https://mvnrepository.com/artifact/org.apache.maven)搜索MyBatis Plus的Maven配置写法。\n使用：（其他写法与Mybatis相同，修改BookDao即可）\ncom.example.dao:BookDao接口\npackage com.example.dao;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.example.domain.Book;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface BookDao extends BaseMapper&lt;Book&gt; &#123;     //通过泛型传入实体类，比如Book对应数据库中的表book（名称不对应运行报错）&#125;\n\n配置表名称前缀：\napplication.yml添加：\nmybatis-plus:  global-config:    db-config:      table-prefix: tb- # 此时对应表名称tb-book\n\n测试：\npackage com.example;import com.example.dao.BookDao;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass Boot3MybatisPlusApplicationTests &#123;    @Autowired    private BookDao bookDao;    @Test    void contextLoads() &#123;        System.out.println(bookDao.selectById(2));    &#125;&#125;\n\n整合Druid创建项目（使用mybatis和mysql）\nmvn网站搜索Druid（选择Druid Spring Boot Starter）\n自行选择一个版本，复制其maven配置（添加到dependencies下）\n在application.yml配置：\nspring:  datasource:    druid:      driver-class-name: com.mysql.cj.jdbc.Driver      url: jdbc:mysql://localhost:3306/books      username: root      password: &quot;123456&quot;\n\nidea快捷键Alt + 7 ：显示类结构\nCtrl + h ：显示类层次结构\nAlt + Ins ：快速生成方法\nAlt + Enter : 自动生成对象实例接收返回值\ndemo创建一个demo项目，使用用spring web、mybatis plus、mysql driver。\n使用druid数据源，pom.xml加入：\n&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;  &lt;version&gt;1.2.9&lt;/version&gt;&lt;/dependency&gt;\n\napplication.yml：\nspring:  datasource:    druid:      driver-class-name: com.mysql.cj.jdbc.Driver      url: jdbc:mysql://localhost:3306/books      username: root      password: &quot;123456&quot;server:  port: 80mybatis-plus:  global-config:    db-config:      id-type: auto # 向数据库添加数据时id自动递增  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 开启mybatis-plus运行日志\n\n创建表（book）结构如下：\n\n\n\nid\nname\ntype\ndescription\n\n\n\n1\nspringboot\n计算机\nSpring Boot 是 Pivotal 团队在 Spring 的基础上提供的一套全新的开源框架。\n\n\n使用Lombok简化实体类开发是一个java类库，提供了一组注解，简化POJO实体类开发\npom.xml加入：\n&lt;dependency&gt;  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;  &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;\n\n使用：\npackage com.example.domain;import lombok.Data;//自动生成getter、setter、toString、hashCode等方法@Datapublic class Book &#123;    private Integer id;    private String name;    private String type;    private String description;&#125;\n\n数据层开发com.example.Dao/BookDao：\npackage com.example.Dao;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.example.domain.Book;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface BookDao extends BaseMapper&lt;Book&gt; &#123;&#125;\n\n分页查询定义配置类：com.example.config/MPConfig:\npackage com.example.config;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;//定义为配置类@Configurationpublic class MPConfig &#123;    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor()&#123; //mybatisPlus的拦截器        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); //提供分页功能的拦截器        return interceptor;    &#125;&#125;\n\n测试：\n@Testvoid getPage() &#123;    IPage&lt;Book&gt; page = new Page&lt;&gt;(1, 5);    bookDao.selectPage(page, null);    System.out.println(page.getTotal()); //数据总数    System.out.println(page.getCurrent()); //当前页    System.out.println(page.getPages()); //总页数    System.out.println(page.getSize()); //每页条数    System.out.println(page.getRecords()); //查询结果&#125;\n\n条件查询//两种写法@Testvoid getBy() &#123;    QueryWrapper&lt;Book&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.like(&quot;name&quot;, &quot;安全&quot;); //查询name属性中含有“安全”的结果    bookDao.selectList(queryWrapper);&#125;@Testvoid getBy2() &#123;    LambdaQueryWrapper&lt;Book&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    queryWrapper.like(Book::getName, &quot;安全&quot;); //同上    bookDao.selectList(queryWrapper);&#125;@Testvoid getBy3() &#123;    String name = null;    LambdaQueryWrapper&lt;Book&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //在前面多传一个boolean参数（如果为false则不进行条件查询，而是输出表中所有结果）    queryWrapper.like(name != null,Book::getName, name);     bookDao.selectList(queryWrapper);&#125;\n\n业务层开发com.example.service/BookService：\npackage com.example.service;import com.example.domain.Book;import java.util.List;public interface BookService &#123;    Boolean save(Book book);    Boolean update(Book book);    Boolean delete(Book book);    Book getById(Integer id);    List&lt;Book&gt; getAll();&#125;\n\ncom.example.service.impl/BookServiceImpl:\npackage com.example.service.impl;import com.example.Dao.BookDao;import com.example.domain.Book;import com.example.service.BookService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class BookServiceImpl implements BookService &#123;    @Autowired    private BookDao bookDao;    @Override    public Boolean save(Book book) &#123;        return bookDao.insert(book) &gt; 0;    &#125;    @Override    public Boolean update(Book book) &#123;        return bookDao.updateById(book) &gt; 0;    &#125;    @Override    public Boolean delete(Book book) &#123;        return bookDao.deleteById(book) &gt; 0;    &#125;    @Override    public Book getById(Integer id) &#123;        return bookDao.selectById(id);    &#125;    @Override    public List&lt;Book&gt; getAll() &#123;        return bookDao.selectList(null);    &#125;&#125;\n\n测试：\n@Autowiredprivate BookService bookService;@Testvoid getById()&#123;    System.out.println(bookService.getById(1));&#125;\n\n快速开发（基于Mybatis-Plus）自动生成基本的业务代码（增删改查）\ncom.example.service/IBookService：\npackage com.example.service;import com.baomidou.mybatisplus.extension.service.IService;import com.example.domain.Book;public interface IBookService extends IService&lt;Book&gt; &#123;&#125;\n\ncom.example.service.impl/IBookServiceImpl:\npackage com.example.service.impl;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.example.Dao.BookDao;import com.example.domain.Book;import com.example.service.IBookService;import org.springframework.stereotype.Service;@Servicepublic class IBookServiceImpl extends ServiceImpl&lt;BookDao, Book&gt; implements IBookService &#123;&#125;\n\n测试：\n@Autowiredprivate IBookService iBookService;@Testvoid getAll() &#123;    System.out.println(iBookService.list());&#125;\n\n表现层开发com.example.controller/BookController:\npackage com.example.controller;import com.example.domain.Book;import com.example.service.IBookService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;@RestController@RequestMapping(&quot;books&quot;)public class BookController &#123;    @Autowired    private IBookService iBookService;    @GetMapping    public List&lt;Book&gt; getAll() &#123;        return iBookService.list();    &#125;    @GetMapping(&quot;&#123;id&#125;&quot;)    public Book getById(@PathVariable Integer id) &#123;        return niBookService.getById(id);    &#125;        @PostMapping    public Boolean save(@RequestBody Book book) &#123;        return iBookService.save(book);    &#125;    @PutMapping    public Boolean update(@RequestBody Book book) &#123;        return iBookService.updateById(book);    &#125;    @DeleteMapping(&quot;&#123;id&#125;&quot;)    public Boolean delete(@PathVariable Integer id) &#123;        Book book = new Book();        book.setId(id);        return iBookService.removeById(book);    &#125;&#125;\n\n使用接口测试工具进行测试\n消息一致性处理统一前后端交互的数据格式。\n返回结果封装成一个R对象\ncom.example.controller.utils/R:\npackage com.example.controller.utils;import lombok.Data;@Datapublic class R &#123;    private Boolean flag;    private Object data;    public R() &#123;    &#125;    public R(Boolean flag) &#123;        this.flag = flag;    &#125;    public R(Boolean flag, Object data) &#123;        this.flag = flag;        this.data = data;    &#125;&#125;\n\ncom.example.controller/BookController:\npackage com.example.controller;import com.example.controller.utils.R;import com.example.domain.Book;import com.example.service.IBookService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;@RestController@RequestMapping(&quot;books&quot;)public class BookController &#123;    @Autowired    private IBookService iBookService;    @GetMapping    public R getAll() &#123;        return new R(true, iBookService.list());    &#125;    @GetMapping(&quot;&#123;id&#125;&quot;)    public R getById(@PathVariable Integer id) &#123;        return new R(true, iBookService.getById(id));    &#125;    @PostMapping    public R save(@RequestBody Book book) &#123;        return new R(iBookService.save(book));    &#125;    @PutMapping    public R update(@RequestBody Book book) &#123;        return new R(iBookService.updateById(book));    &#125;    @DeleteMapping(&quot;&#123;id&#125;&quot;)    public R delete(@PathVariable Integer id) &#123;        return new R(iBookService.removeById(id));    &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n\n参考视频\n","categories":["springboot"],"tags":["springboot","java","mybatis","druid"]},{"title":"vue3使用tsx","url":"/2022/04/29/vue3%E4%BD%BF%E7%94%A8tsx/","content":"技术栈vue3+ts+vite\n安装@vitejs&#x2F;plugin-vue-jsxnpm i @vitejs/plugin-vue-jsx -D\n\n使用vite.config.ts中导入：\nimport &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import vueJsx from &#x27;@vitejs/plugin-vue-jsx&#x27;;export default defineConfig(&#123;  plugins: [vue(),vueJsx()]&#125;)\n\n修改tsconfig.json:（添加jsxFactory和jsxFragmentFactory）\n&#123;  &quot;compilerOptions&quot;: &#123;    &quot;jsx&quot;: &quot;preserve&quot;,    &quot;jsxFactory&quot;: &quot;h&quot;,    &quot;jsxFragmentFactory&quot;: &quot;Fragment&quot;,  &#125;,&#125;\n\ntsxsrc目录内新建tsx文件：（如：App.tsx）\nconst renderDom = () =&gt; &#123;  return (      &lt;div&gt;        hello,tsx!      &lt;/div&gt;  )&#125;export default renderDom\n\n在.vue文件中导入并使用：\n&lt;template&gt;  &lt;renderDom&gt;&lt;/renderDom&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import renderDom from &quot;./App.tsx&quot;; //导入后当成组件使用即可&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n\n展示数据变量写在单个花括号内，展示ref对象的值需要加上.value\nimport &#123;ref, Ref&#125; from &quot;vue&quot;;const text: Ref&lt;string&gt; = ref(&#x27;&#x27;)const renderDom = () =&gt; &#123;  return (      &lt;div&gt;        &lt;input type=&quot;text&quot; v-model=&#123;text.value&#125;/&gt;        &lt;span&gt;&#123;text.value&#125;&lt;/span&gt;      &lt;/div&gt;  )&#125;export default renderDom\n\nv-show和v-iftsx支持v-show，不支持v-if\n要想实现v-if的效果，需使用编程的方法\nlet flag = falseconst renderDom = () =&gt; &#123;  return (      &lt;div&gt;        &#123; flag ? &lt;div&gt;罗小黑&lt;/div&gt; : &lt;div&gt;罗小白&lt;/div&gt;&#125;      &lt;/div&gt;  )&#125;export default renderDom\n\nv-for使用Array.map()\nconst arr = [1,2,3,4]const renderDom = () =&gt; &#123;  return (      &lt;div&gt;        &#123; arr.map(item =&gt; &#123;          return &lt;div&gt;$&#123;item&#125;&lt;/div&gt;        &#125;) &#125;      &lt;/div&gt;  )&#125;export default renderDom\n\nv-bind和v-ontsx不支持v-bind和v-on\n绑定数据直接使用即可\n绑定事件使用onXXX（如onClick）即可，函数传参使用bind，不能使用事件修饰符（需自己使用js实现）\nconst arr = [1, 2, 3, 4]const clickEvent = (item: number) =&gt; &#123;  console.log(`点击了第$&#123;item&#125;个`)&#125;const renderDom = () =&gt; &#123;  return (      &lt;div&gt;        &#123;arr.map(item =&gt; &#123;          return &lt;div data-num=&#123;item&#125; onClick=&#123;clickEvent.bind(this, item)&#125;&gt;$&#123;item&#125;&lt;/div&gt;        &#125;)&#125;      &lt;/div&gt;  )&#125;export default renderDom\n\n接收props参数和emit&lt;template&gt;\t&lt;renderDom title=&quot;这是标题&quot; @getNum=&quot;getNum&quot;&gt;&lt;/renderDom&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import renderDom from &quot;./App.tsx&quot;; //导入后当成组件使用即可    const getNum = (num: number) =&gt; &#123;  console.log(num)&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n\ninterface Props &#123;  title: string&#125;const clickEvent = (ctx: any) =&gt; &#123;  ctx.emit(&#x27;getNum&#x27;, 20)&#125;const renderDom = (props: Props, ctx: any) =&gt; &#123;  return (      &lt;div&gt;        &lt;div&gt;&#123;props.title&#125;&lt;/div&gt;        &lt;button onClick=&#123;clickEvent.bind(this,ctx)&#125;&gt;按钮&lt;/button&gt;      &lt;/div&gt;  )&#125;export default renderDom\n\n\n\n参考视频\n","categories":["vue3"],"tags":["vue3","tsx","vite","jsx"]},{"title":"webpack配置","url":"/2022/03/07/webpack%E9%85%8D%E7%BD%AE/","content":"webpack.config.js入口和出口文件const path = require(&#x27;path&#x27;)//引入path模块module.exports = &#123;    entry: &#x27;./src/index.js&#x27;,//打包的入口文件    output: &#123;//出口        filename: &quot;bundle.js&quot;,//出口文件名        path: path.resolve(__dirname, &quot;./dist&quot;),//出口文件路径需要绝对路径        clean: true,//打包前清理dist文件夹    &#125;&#125;\n\n生成HTML文件安装html-webpack-plugin插件\nnpm i html-webpack-plugin -D\n\n该模块用于自动生成HTML文件。在webpack.config.js中引入：\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); //通过 npm 安装\n\n通过plugins配置插件：\nplugins: [    new HtmlWebpackPlugin(&#123;//可不传配置项（默认配置）        template: &quot;./index.html&quot;,//以index.html为模板生成html文件        filename: &quot;app.html&quot;,        inject: &#x27;body&#x27;,//指定script标签写在body标签中（默认为head）    &#125;)]\n\n代码有修改后自动打包：\nwebpack --watch\n\n开发环境安装webpack-dev-server插件\nnpm i webpack-dev-server -D\n\n//开发模式mode: &quot;development&quot;,devtool: &#x27;inline-source-map&#x27;,//精确显示代码位置（比如报错时）devServer: &#123;//开发服务器    static:&#x27;./dist&#x27;&#125;,\n\n命令行执行：\nwebpack-dev-server\n\n无需打包，通过浏览器访问8080端口实时查看页面效果\n资源模块Resource资源加载资源导出url\nmodule:&#123;    rules: [        &#123;            test:/\\.png$/,//匹配.png文件            type: &quot;asset/resource&quot;,//加载资源导出url            generator: &#123;//指定打包的路径（可省略）                filename: &#x27;images/[contenthash][ext]&#x27;//[contenthash]:哈希值作为文件名，[ext]:扩展名            &#125;        &#125;    ]&#125;\n\n示例：在index.js中导入png图片\nimport imgsrc from &#x27;../asset/微信.png&#x27;//图片url(http://localhost:8080/images/a2769eaec65049f8919b.png)const img = document.createElement(&#x27;img&#x27;)img.src = imgsrcdocument.body.appendChild(img)\n\n也可再output中使用assetModuleFilename指定打包路径，优先级低于rules中的配置\noutput: &#123;//出口    filename: &quot;bundle.js&quot;,//出口文件名    path: path.resolve(__dirname, &quot;./dist&quot;),//出口文件路径需要绝对路径    clean: true,//打包前清理dist文件夹    assetModuleFilename: &quot;images/[contenthash][ext]&quot;,//[contenthash]:哈希值作为文件名，[ext]:扩展名&#125;,\n\ninline资源导出为Data URL base64格式\n&#123;    test: /\\.svg$/,    type: &quot;asset/inline&quot;,//导出为Data URL base64格式&#125;,\n\n示例：导入svg图片\nimport logoSvg from &#x27;./asset/logo.svg&#x27;//(data:image/svg+xml;base64,PHN2ZyB4bWxucz......)const img2 = document.createElement(&#x27;img&#x27;)img2.src = logoSvgimg2.style.cssText=&#x27;width:400px;height:600px&#x27;document.body.appendChild(img2)\n\nsource资源导出文件源码\n&#123;    test: /\\.txt$/,    type: &quot;asset/source&quot;,//导出文件源码&#125;\n\n示例：导入源码\nimport helloTxt from &#x27;./asset/hello.txt&#x27;//txt的文本内容const block = document.createElement(&#x27;div&#x27;)block.style.cssText = &#x27;width:200px;height:200px;border:1px solid gray&#x27;block.textContent = helloTxtdocument.body.appendChild(block)\n\n通用资源类型自动选择资源类型，小于maxSize用inline类型，大于则用resource类型\n&#123;    test: /\\.jpg$/,    type: &quot;asset&quot;,//自动选择资源类型，小于maxSize用inline类型，大于则用resource类型    parser: &#123;//自定义条件（可省略）        dataUrlCondition:&#123;            maxSize: 4 * 1024//默认为4 * 1024        &#125;    &#125;&#125;\n\n示例：导入jpg图片\nimport jpgMap from &#x27;./asset/头像.jpg&#x27;//因为大于4k所以是url格式const block = document.createElement(&#x27;div&#x27;)block.style.cssText = &#x27;width:200px;height:200px;border:1px solid gray&#x27;block.textContent = helloTxtdocument.body.appendChild(block)\n\nloader加载CSS安装loader\nnpm i css-loader -Dnpm i style-loader -D\n\n在module &gt; rules中配置\n&#123;    test: /\\.css$/,    //css-loader写在style-loader后面，先加载    //如果需要CSS预处理语言，安装相应的loader，写在css-loader后面    use: [&#x27;style-loader&#x27;,&#x27;css-loader&#x27;],//css-loader允许打包css文件，style-loader将样式加到html页面上&#125;\n\n抽离和压缩CSS安装插件\nnpm i mini-css-extract-plugin -Dnpm i css-minimizer-webpack-plugin -D\n\n引入插件\nconst MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)const CssMinimizerPlugin = require(&#x27;css-minimizer-webpack-plugin&#x27;)\n\n在plugin中使用MiniCssExtractPlugin（用于以link标签的形式在html中导入css文件）\nnew MiniCssExtractPlugin(&#123;\tfilename:&#x27;styles/[contenthash].css&#x27;//自定义打包路径&#125;)\n\n&#123;    test: /\\.css$/,    //&#x27;style-loader&#x27;换为MiniCssExtractPlugin    use: [MiniCssExtractPlugin.loader,&#x27;css-loader&#x27;],//css-loader允许打包css文件，style-loader将样式加到html页面上&#125;\n\n新配置项optimization中使用CssMinimizerPlugin（用于压缩css文件）\noptimization: &#123;    minimizer: [        new CssMinimizerPlugin()    ]&#125;,mode:&#x27;production&#x27;//生产环境下才会压缩（会有其他报错）\n\nbabel-loader如果浏览器不支持ES6语法，使用babel-loader，将ES6转为ES5\n安装babel-loader，@babel&#x2F;core，@babel&#x2F;preset-env\nnpm i babel-loader @babel/core @babel/preset-env -Dnpm i @babel/runtime -Dnpm i @babel/plugin-transform-runtime -D\n\nmodule &gt; rules中配置\n&#123;    test:/\\.js$/,    exclude: /node_modules/,//排除node_modules中的js文件    use:&#123;        loader:&#x27;babel-loader&#x27;,        options: &#123;            presets:[&#x27;@babel/preset-env&#x27;],            plugins: [                [                    &#x27;@babel/plugin-transform-runtime&#x27;                ]            ]        &#125;    &#125;&#125;\n\n代码分离多入口entry中设置多入口文件，修改output中的filename\nentry: &#123;    //两个文件都引入了lodash模块    index: &#x27;./src/index.js&#x27;,    another: &#x27;./src/another.js&#x27;&#125;,//打包的入口文件output: &#123;//出口    filename: &quot;[name].bundle.js&quot;,//出口文件名（[name]:入口文件的键值）    path: path.resolve(__dirname, &quot;./dist&quot;),//出口文件路径需要绝对路径    clean: true,//打包前清理dist文件夹    assetModuleFilename: &quot;images/[contenthash][ext]&quot;,//[contenthash]:哈希值作为文件名，[ext]:扩展名&#125;,\n\n防止重复optimization: &#123;    splitChunks: &#123;        chunks: &quot;all&quot;//自动抽离公共代码模块    &#125;&#125;\n","categories":["工程化"],"tags":["webpack"]},{"title":"vue3使用router","url":"/2022/05/02/vue3%E4%BD%BF%E7%94%A8router/","content":"初始化vue3项目npm init vite@latest\n\n使用vue+ts\nvue-router基本使用安装vue-routernpm i vue-router\n\n基本使用新建src/index.ts:\nimport &#123;createRouter, createWebHashHistory, createWebHistory, RouteRecordRaw&#125; from &quot;vue-router&quot;;const routes: RouteRecordRaw[] = [  &#123;    path: &#x27;/&#x27;,    component: () =&gt; import(&#x27;../components/Login.vue&#x27;)  &#125;,  &#123;    path:&#x27;/reg&#x27;,    component: ()=&gt; import(&#x27;../components/Register.vue&#x27;)  &#125;]export default createRouter(&#123;  history: createWebHistory(), //路由模式  routes&#125;)\n\nmain.ts中导入：\nimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import Router from &#x27;./router/index&#x27;createApp(App).use(Router).mount(&#x27;#app&#x27;)\n\nrouter-view和router-linkApp.vue中：\n&lt;template&gt;  &lt;!--replace：不产生历史记录--&gt;  &lt;router-link to=&quot;/&quot; replace&gt;登录&lt;/router-link&gt;  &lt;router-link to=&quot;/reg&quot;&gt;注册&lt;/router-link&gt;  &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt;\n\n编程式导航&lt;template&gt;  &lt;router-link to=&quot;/&quot;&gt;登录&lt;/router-link&gt;  &lt;router-view&gt;&lt;/router-view&gt;  &lt;button @click=&quot;goto&quot;&gt;去注册&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;useRouter&#125; from &quot;vue-router&quot;;const router = useRouter()const goto = () =&gt; &#123;  router.push(&#x27;/reg&#x27;)  // router.replace(&#x27;/&#x27;) //不产生历史记录  // router.go(1) //前进  // router.go(-1) //后退  // router.back() //后退&#125;&lt;/script&gt;\n\n路由传参和vue2中一样（query、params、动态路由参数）\n传params参数必须使用命名路由，params参数刷新页面后丢失，动态路由参数和query不会\n路由模式vue2使用mode设置路由模式，vue3改为history\n对应关系：\n\n\n\nvue2\nvue3\n\n\n\nhistory\ncreateWebHistory\n\n\nhash\ncreateWebHashHistory\n\n\nabstact\ncreateMemoryHistory\n\n\nhash原理//获取当前hash值location.hash //输出：&#x27;#/&#x27;//设置hash值location.hash = &#x27;/reg&#x27; //或者&#x27;#/reg&#x27;\n\n通过onhashchange监听hash的变化:\nwindow.addEventListener(&#x27;hashchange&#x27;,(event)=&gt;&#123; //hash发生变化时触发\tconsole.log(event) //HashChangeEvent对象（包含很多属性，比如：newURL、oldURL等）&#125;)\n\nhistory原理通过onpopstate监听url的变化:\nwindow.addEventListener(&#x27;popstate&#x27;,(event)=&gt;&#123; //路径发生变化时触发\tconsole.log(event) //PopStateEvent对象（其中的state属性就包含路径信息）&#125;)\n\nhistory.state //&#123;back: &#x27;/reg&#x27;, current: &#x27;/&#x27;, forward: &#x27;/reg&#x27;, replaced: false, position: NaN, …&#125;history.pushState(&#123;&#125;,&#x27;&#x27;,&#x27;/reg&#x27;) //此方法只会改变当前地址栏的路径，并不会更新页面内容//需要在Javascript代码中调用history.back()或用户点击浏览器的回退按钮\n\n命名视图和重定向定义多个组件：\n&#123;  path: &#x27;/&#x27;,  //重定向（可使用字符串、对象、函数三种写法）  //redirect:&#x27;/user1&#x27;,  redirect: to =&gt; &#123;    return &#123;      path: &#x27;user1&#x27;    &#125;  &#125;，  //别名  //alias:[&#x27;user&#x27;,...],  children: [    &#123;      path: &#x27;user1&#x27;,      components:&#123;        default: () =&gt; import(&#x27;../components/A.vue&#x27;),      &#125;    &#125;,    &#123;      path: &#x27;user2&#x27;,      components:&#123;        bbb: () =&gt; import(&#x27;../components/B.vue&#x27;),        ccc: () =&gt; import(&#x27;../components/C.vue&#x27;)      &#125;    &#125;  ],&#125;\n\n&lt;template&gt;  &lt;!--加载default--&gt;  &lt;router-view&gt;&lt;/router-view&gt;  &lt;!--加载对应的name--&gt;  &lt;router-view name=&#x27;bbb&#x27;&gt;&lt;/router-view&gt;  &lt;router-view name=&#x27;ccc&#x27;&gt;&lt;/router-view&gt;&lt;/template&gt;\n\n路由过渡动画安装animate.css：npm install animate.css --save\n设置路由元信息（meta），准备好animate.css的类名\n&#123;  path: &#x27;/&#x27;,  component: () =&gt; import(&#x27;../components/Login.vue&#x27;)，  meta: &#123;    transition: &#x27;animate__bounceIn&#x27;  &#125;&#125;,&#123;  path:&#x27;/reg&#x27;,  component: ()=&gt; import(&#x27;../components/Register.vue&#x27;)，  meta: &#123;    transition: &#x27;animate__fadeIn&#x27;  &#125;&#125;\n\n使用：\n&lt;template&gt;  &lt;router-link to=&quot;/&quot;&gt;登录&lt;/router-link&gt;  &lt;router-link to=&quot;/reg&quot;&gt;注册&lt;/router-link&gt;  &lt;router-view #default=&quot;&#123;route,Component&#125;&quot;&gt;    &lt;transition :enter-active-class=&quot;`animate__animated $&#123;route.meta.transition&#125;`&quot;&gt;      &lt;component :is=&quot;Component&quot;&gt;&lt;/component&gt;    &lt;/transition&gt;  &lt;/router-view&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#x27;animate.css&#x27;&lt;/script&gt;\n\nrouter-view： 可以使用作用域插槽的写法\ntransition：定义过度动画\ncomponent（动态组件）：通过is属性指定组件\n滚动行为scrollBehavior：创建Router时可定义的方法（返回值为滚动条的位置）\nexport default createRouter(&#123;  history: createWebHistory(),  //保存滚动条的位置  scrollBehavior: (to,from,savedPosition)=&gt;&#123;    if(savedPosition)&#123;      return savedPosition    &#125;else &#123;      return &#123;        top:0      &#125;    &#125;  &#125;,  routes&#125;)\n","categories":["vue3"],"tags":["vue3","router","vue-router"]},{"title":"二叉树","url":"/2022/05/19/%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"搜索二叉树一种特殊有序的二叉树。如果一棵树不为空，并且如果它的根节点左子树不为空，那么它左子树上面的所有节点的值都小于它的根节点的值，如果它的右子树不为空，那么它右子树任意节点的值都大于他的根节点的值，它的左右子树也是二叉搜索树。\n验证是否是搜索二叉树leetcode上的题目：验证二叉搜索树\n通过二叉树的中序遍历判断\nvar isValidBST = function (root) &#123;  let pre = -Infinity  return valid(root)  function valid(root) &#123;    if (!root) return true    if (!valid(root.left)) return false    if (root.val &lt;= pre) return false    pre = root.val    return valid(root.right)  &#125;&#125;;\n\n完全二叉树叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。\n宽度优先遍历使用队列实现\nfunction TreeNode(val, left, right) &#123;  this.val = (val === undefined ? 0 : val)  this.left = (left === undefined ? null : left)  this.right = (right === undefined ? null : right)&#125;let root = new TreeNode(5)root.left = new TreeNode(1)root.right = new TreeNode(4)root.right.left = new TreeNode(3)root.right.right = new TreeNode(6)function traverse(root) &#123;  const queue = []  queue.push(root)  while (queue.length) &#123;    root = queue.shift()    console.log(root.val)    if (root.left) queue.push(root.left)    if (root.right) queue.push(root.right)  &#125;&#125;traverse(root) //5 1 4 3 6\n\n验证完全二叉树使用宽度优先遍历。如果遇到有右节点无左节点的返回false；语遇到叶子节点之后的所有节点都必须是叶子节点，否则返回false。\n二叉树最大深度leetcode上的题目：二叉树的最大深度\n递归解决：（树的最大深度等于左右子树的最大深度加一）\nvar maxDepth = function (root) &#123;  if (!root) return 0  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1&#125;;\n\n满二叉树除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。\n递归解决：（所有节点的左右子树是满二叉树且深度相等）\nfunction TreeNode(val, left, right) &#123;  this.val = (val === undefined ? 0 : val)  this.left = (left === undefined ? null : left)  this.right = (right === undefined ? null : right)&#125;let root = new TreeNode(5)root.left = new TreeNode(1)root.right = new TreeNode(4)root.right.left = new TreeNode(3)root.right.right = new TreeNode(6)root.left.left = new TreeNode(6)root.left.right = new TreeNode(6)function isFull(root) &#123;  return depth(root) &gt;= 0  function depth(root) &#123;    if (!root) return 0    let leftDepth = depth(root.left)    let rightDepth = depth(root.right)    if (leftDepth !== -1 &amp;&amp; leftDepth === rightDepth)      return leftDepth + 1    else       return -1  &#125;&#125;console.log(isFull(root)) //true\n\n平衡二叉树任意节点的子树的高度差都小于等于 1\nleetcode上的题目：平衡二叉树\n递归解决：\nvar isBalanced = function (root) &#123;  return depth(root) &gt;= 0  function depth(root) &#123;    if (!root) return 0    let leftDepth = depth(root.left)    let rightDepth = depth(root.right)    if (leftDepth !== -1 &amp;&amp; rightDepth !== -1 &amp;&amp; Math.abs(leftDepth - rightDepth) &lt;= 1) &#123;      return Math.max(leftDepth, rightDepth) + 1    &#125; else &#123;      return -1    &#125;  &#125;&#125;;\n\n二叉树共同祖先leetcode上的题目：二叉树的最近公共祖先\n递归解决：\nvar lowestCommonAncestor = function (root, p, q) &#123;  if (!root || root === p || root === q) &#123;    return root  &#125;  let left = lowestCommonAncestor(root.left, p, q)  let right = lowestCommonAncestor(root.right, p, q)  //if (!left &amp;&amp; !right) return null  if (left &amp;&amp; right) return root  return left ? left : right&#125;;\n\n前驱节点、后继节点二叉树的前驱节点：就是中序遍历中该节点的前一个节点\n二叉树的后继节点：就是中序遍历中该节点的后一个节点\n序列化和反序列化leetcode上的题目：二叉树的序列化与反序列化\n//序列化var serialize = function (root) &#123;  if (!root) return &#x27;#_&#x27;  let result = root.val + &#x27;_&#x27;  result += serialize(root.left)  result += serialize(root.right)  return result&#125;;//反序列化var deserialize = function (data) &#123;  const arr = data.split(&#x27;_&#x27;)  function createTree(arr) &#123;    const val = arr.shift()    if (val === &#x27;#&#x27;) &#123;      return null    &#125;    const head = new TreeNode(val)    head.left = createTree(arr)    head.right = createTree(arr)    return head  &#125;  return createTree(arr)&#125;;\n","categories":["数据结构"],"tags":["二叉树"]},{"title":"实用网站","url":"/2022/03/22/%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99/","content":"前端面试web前端面试 - 面试官系列\n大厂面试题每日一题\nJavaScriptES6ECMAScript 6 入门-阮一峰\nTypeScriptTypeScript入门教程\nGit廖雪峰的官方网站-Git教程\n博客山月行\n冴羽的博客\n站点MDN\n","categories":["网站"],"tags":["ES6","git","JavaScript","面试题"]},{"title":"古典密码Vigenere算法","url":"/2022/04/08/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81Vigenere%E7%AE%97%E6%B3%95/","content":"代码如下（html文件）：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Title&lt;/title&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;style&gt;    #root &#123;      width: 60%;      margin: auto;    &#125;    .header &#123;      width: 360px;      margin: auto;    &#125;    .main &#123;      display: flex;      justify-content: left;      padding-top: 20px;    &#125;    .area &#123;      width: 40%;      padding-right: 80px;    &#125;    .area textarea &#123;      width: 100%;      height: 120px;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;root&quot;&gt;  &lt;div class=&quot;header&quot;&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;请输入密钥&quot; v-model.lazy.trim=&quot;key&quot; @blur=&quot;setKey&quot;&gt;    &lt;button @click=&quot;encryption&quot;&gt;加密&lt;/button&gt;    &lt;button @click=&quot;decrypt&quot;&gt;解密&lt;/button&gt;  &lt;/div&gt;  &lt;div class=&quot;main&quot;&gt;    &lt;div class=&quot;area&quot;&gt;      &lt;textarea placeholder=&quot;请输入明文/密文&quot; v-model.lazy.trim=&quot;put&quot;&gt;&lt;/textarea&gt;    &lt;/div&gt;    &lt;div class=&quot;area&quot;&gt;      &lt;textarea placeholder=&quot;加密/解密的结果&quot; v-model.lazy.trim=&quot;out&quot;&gt;&lt;/textarea&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;&lt;script&gt;  Vue.config.productionTip = false;   //阻止 vue 在启动时生成生产提示  new Vue(&#123;    el: &quot;#root&quot;,    data: &#123;      key: &#x27;&#x27;,      put: &#x27;&#x27;,//输入      out: &#x27;&#x27;,//输出    &#125;,    computed: &#123;      table() &#123;        const obj = &#123;&#125;        let c1 = &#x27;&#x27;, c2 = &#x27;&#x27;, r = &#x27;&#x27;        for (let i = 97; i &lt; 123; i++) &#123;          c1 = String.fromCharCode(i)          obj[c1] = &#123;&#125;          for (let n = 97; n &lt; 123; n++) &#123;            let res = n + i - 97            c2 = String.fromCharCode(n)            r = String.fromCharCode(res &gt; 122 ? res - 26 : res)            obj[c1][c2] = r          &#125;        &#125;        return obj      &#125;    &#125;,    methods: &#123;      setKey() &#123;        if (!/^[a-z|A-Z]+$/.test(this.key)) &#123;          this.key = &#x27;&#x27;        &#125;      &#125;,      //加密按钮回调      encryption() &#123;        let &#123;put, key&#125; = this        key = key.toLowerCase()        let out = []        let n = 0        const l = key.length - 1        if (put &amp;&amp; key) &#123;          for (let i = 0; i &lt; put.length; i++) &#123;            if (/[a-z]/.test(put[i])) &#123;              out.push(this.table[key[n]][put[i]])            &#125; else if (/[A-Z]/.test(put[i])) &#123;              let char = this.table[key[n]][put[i].toLowerCase()]              out.push(char.toUpperCase())            &#125; else &#123;              out.push(put[i])            &#125;            n === l ? n = 0 : n++          &#125;          this.out = out.join(&#x27;&#x27;)        &#125;      &#125;,      //解密按钮回调      decrypt() &#123;        let &#123;put, key&#125; = this        key = key.toLowerCase()        let out = []        let n = 0        const l = key.length - 1        if (put &amp;&amp; key) &#123;          for (let i = 0; i &lt; put.length; i++) &#123;            if (/[a-z]/.test(put[i])) &#123;              out.push(this.decryptUtil(key[n], put[i]))            &#125; else if (/[A-Z]/.test(put[i])) &#123;              let char = this.decryptUtil(key[n], put[i].toLowerCase())              out.push(char.toUpperCase())            &#125; else &#123;              out.push(put[i])            &#125;            n === l ? n = 0 : n++          &#125;          this.out = out.join(&#x27;&#x27;)        &#125;      &#125;,      //解密      decryptUtil(key, value) &#123;        for (let i = 97; i &lt; 123; i++) &#123;          if (this.table[key][String.fromCharCode(i)] === value) &#123;            return String.fromCharCode(i)          &#125;        &#125;      &#125;    &#125;  &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n","categories":["信息安全","古典密码"],"tags":["Vue","JavaScript","Vigenere"]},{"title":"手写vue-lazyload","url":"/2022/04/03/%E6%89%8B%E5%86%99vue-lazyload/","content":"vue-lazyloadmain.js中引入vue-lazyload：\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import VueLazyload from &quot;vue-lazyload&quot;;Vue.use(VueLazyload,&#123;  loading:&#x27;http://localhost:3000/img/loading.gif&#x27;, //图片加载中显示的图片  error:&#x27;http://localhost:3000/img/error-img.png&#x27;, //图片加载错误显示的图片  preLoad:1 //超出1倍屏幕高度的图片先不加载&#125;)\n\n.vue文件中使用：\n使用指令v-lazy代替img标签的src属性，表示该图片使用懒加载\n&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;div v-for=&quot;(item,index) in imgData&quot; :key=&quot;index&quot;&gt;      &lt;div class=&quot;img&quot;&gt;        &lt;img v-lazy=&quot;item.img&quot; alt=&quot;img&quot;&gt;      &lt;/div&gt;      &lt;div class=&quot;content&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &#x27;axios&#x27;export default &#123;  name: &#x27;App&#x27;,  data() &#123;    return &#123;      imgData: []    &#125;  &#125;,  mounted() &#123;    this.getImgs()  &#125;,  methods: &#123;    async getImgs() &#123;      const res = await axios.get(&#x27;http://localhost:3000/imgs&#x27;)      this.imgData = res.data    &#125;  &#125;&#125;&lt;/script&gt;\n\n自定义指令实现v-lazy手写插件vue-lazyload新建文件modules/vue-lazyload/index.js:\nexport default &#123; //默认暴露一个带有install方法的对象  install(Vue,options)&#123; //Vue：Vue构造器，options：使用插件时传入的配置对象      &#125;&#125;\n\nmain.js中引入自己的插件：\nimport VueLazyload from &quot;./modules/vue-lazyload&quot;;\n\n自定义指令export default &#123;  install(Vue, options) &#123;    //自定义指令,参数一：自定义指令名，参数二：定义该指令功能的对象    Vue.directive(&#x27;lazy&#x27;, &#123;      //指令定义对象可以调用一些钩子函数：比如bind、inserted      //钩子函数的参数，el：指令所绑定的元素，binding：一个对象，vnode：虚拟节点      //bind：只调用一次，指令第一次绑定到元素时调用      bind(el,binding,vnode)&#123;      &#125;    &#125;)  &#125;&#125;\n\n功能实现的类接下来就需要在bind钩子函数中实现功能逻辑，为了更好的扩展性，将功能封装成一个类：\n创建modules/vue-lazyload/lazy.js：\nexport default function (Vue) &#123; //暴露一个函数，接收Vue构造器  return class Lazy &#123; //返回一个类，接收options    constructor(options) &#123;      this.options = options    &#125;      //实现功能的函数    bindLazy(el, binding) &#123;    &#125;  &#125;&#125;\n\nmodules/vue-lazyload/index.js:\nimport lazy from &#x27;./lazy&#x27; //导入lazy.jsexport default &#123;  install(Vue, options) &#123;    const LazyClass = lazy(Vue)    const lazyload = new LazyClass(options)    Vue.directive(&#x27;lazy&#x27;, &#123;      bind: lazyload.bindLazy.bind(lazyload) //绑定函数，注意修改this指向    &#125;)  &#125;&#125;\n\n准备一个函数，用于获取dom的最近的滚动父节点（overflow：scroll）\n创建modules/vue-lazyload/util.js:\nexport function getScrollParent(el) &#123;  let _parent = el.parentNode  while (_parent) &#123;      //getComputedStyle：获取目标的所有css属性    const overflow = getComputedStyle(_parent)[&#x27;overflow&#x27;] //获取overflow属性值    if (/(scroll)|(auto)/.test(overflow)) &#123;      return _parent    &#125;    _parent = _parent.parentNode  &#125;&#125;\n\nlazy.js中使用Vue.nextTick:\nimport &#123;getScrollParent&#125; from &#x27;./util&#x27;export default function (Vue) &#123;  return class Lazy &#123;    constructor(options) &#123;      this.options = options      this.isAddScrollListener = false     &#125;    bindLazy(el, binding) &#123;      Vue.nextTick(() =&gt; &#123;        const scrollParent = getScrollParent(el)        if (scrollParent &amp;&amp; !this.isAddScrollListener) &#123; //如果还没有绑定事件          scrollParent.addEventListener(&#x27;scroll&#x27;,this.handleScroll.bind(this))        &#125;      &#125;)    &#125;    //滚动事件    handleScroll()&#123;    &#125;  &#125;&#125;\n\n图片实例的类创建modules/vue-lazyload/lazyimg.js:\nexport default class Lazyimg &#123;  constructor(&#123;el, src, options, imgRender&#125;) &#123;    this.el = el    this.src = src    this.options = options    this.imgRender = imgRender    this.loaded = false //已经加载过    this.state = &#123;      loading: false, //加载成功      error: false //加载失败    &#125;  &#125;i  //图片是否在指定范围内  checkIsVisible() &#123;    const &#123;top&#125; = this.el.getBoundingClientRect() //获取元素距顶部的距离    return top &lt; window.innerHeight * (this.options.preLoad || 1.3) //判断是否在范围内，preLoad默认1.3  &#125;  //加载图片（未完成，第二个参数先写死成loading，参数一为该图片实例）  loadImg() &#123;    this.imgRender(this,&#x27;loading&#x27;) //加载图片，图片加载中时显示的图片  &#125;&#125;\n\nlazy.js:每次触发bind时创建一个图片实例，保存到数组\nimport &#123;getScrollParent&#125; from &#x27;./util&#x27;import &#123;throttle&#125; from &#x27;lodash&#x27; //节流import Lazyimg from &quot;./lazyimg&quot;;export default function (Vue) &#123;  return class Lazy &#123;    constructor(options) &#123;      this.options = options      this.isAddScrollListener = false      this.lazyimgPool = [] //图片实例数组    &#125;    bindLazy(el, binding) &#123;      Vue.nextTick(() =&gt; &#123;        const scrollParent = getScrollParent(el)        if (scrollParent &amp;&amp; !this.isAddScrollListener) &#123;          scrollParent.addEventListener(&#x27;scroll&#x27;, throttle(this.handleScroll.bind(this), 200))          this.isAddScrollListener = true        &#125;          //创建一个新的图片实例        const lazyimg = new Lazyimg(&#123;           el,          src: binding.value, //v-lazy指令绑定的值          options: this.options,          imgRender: this.imgRender.bind(this)        &#125;)        this.lazyimgPool.push(lazyimg)        this.handleScroll() //滚动事件在一开始就执行一次      &#125;)    &#125;    //滚动事件    handleScroll() &#123;    &#125;    //图片渲染函数    imgRender() &#123;    &#125;  &#125;&#125;\n\n滚动事件handleScroll() &#123;  let isVisible = false  this.lazyimgPool.forEach(lazyimg =&gt; &#123;    if (!lazyimg.loaded) &#123; //图片还没有加载      isVisible = lazyimg.checkIsVisible() //图片是否出现在指定的范围内（perLoad指定的）      isVisible &amp;&amp; lazyimg.loadImg() //如果出现在范围内，则加载图片    &#125;  &#125;)&#125;\n\n渲染图片imgRender(lazyimg, state) &#123;  const &#123;el, options&#125; = lazyimg  const &#123;loading, error&#125; = options  let src = &#x27;&#x27;  switch (state) &#123;    case &#x27;loading&#x27;: //加载中      src = loading || &#x27;&#x27;      break    case &#x27;error&#x27;: //加载错误      src = error || &#x27;&#x27;      break    default: //加载完成，显示真正的目标图片      src = lazyimg.src  &#125;  el.setAttribute(&#x27;src&#x27;,src) //设置或改变图片的src&#125;\n\n渲染完成util.js中添加：\nexport function imgLoad(src) &#123;  return new Promise(((resolve, reject) =&gt; &#123;    const oImg = new Image()    oImg.src = src    oImg.onload = resolve //加载成功    oImg.onerror = reject //加载失败  &#125;))&#125;\n\nlazy.js:\nloadImg() &#123;  this.imgRender(this, &#x27;loading&#x27;)  imgLoad(this.src).then(() =&gt; &#123;//成功    this.state.loading = true    this.imgRender(this, &#x27;ok&#x27;)     this.loaded = true  &#125;).catch(() =&gt; &#123;//失败    this.state.error = true    this.imgRender(this, &#x27;error&#x27;)    this.loaded = true  &#125;)&#125;\n\n通过IntersectionObserver实现export default &#123;  install(Vue, options) &#123;    Vue.directive(&#x27;lazy&#x27;, &#123;      bind(el, binding) &#123;        init(el, binding.value, options.loading)      &#125;,      inserted(el) &#123;        observer(el)      &#125;    &#125;)  &#125;&#125;// 初始化function init(el, src, loading) &#123;  el.setAttribute(&#x27;data-src&#x27;, src)  el.setAttribute(&#x27;src&#x27;, loading)&#125;// 利用IntersectionObserver监听elfunction observer(el) &#123;  let observer = new IntersectionObserver(entries =&gt; &#123;    if (entries[0].isIntersecting)&#123; //进入视口      let realSrc=el.dataset.src      if (realSrc)&#123;        el.setAttribute(&#x27;src&#x27;,realSrc)        el.removeAttribute(&#x27;data-src&#x27;)      &#125;    &#125;  &#125;)  observer.observe(el)&#125;\n\n生成观察器实例：let observer = new IntersectionObserver(callback,option)\n接收两个参数，callback：可见性变化时的回调函数，option：可选的配置项\ncallback：\n一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。\nlet io = new IntersectionObserver(  entries =&gt; &#123;    console.log(entries);  &#125;)\n\nenteries：是一个数组，每个成员是IntersectionObserverEntry对象，如果同时有多个被观察的对象的可见性发生变化，enteries数组就有多个成员。\nIntersectionObserverEntry对象的部分属性：\n\nisIntersecting：是否可见\ntime：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒\nboundingClientRect：目标元素的矩形区域信息\nintersectionRatio：目标元素的可见比例，完全可见时为1，完全不可见时小于等于0\nintersectionRect：目标元素与视口（或根元素）的交叉区域的信息\ntarget：目标元素\nrootBounds：根元素的矩形区域的信息\n\noption对象属性：\n\nthreshold：数组，决定何时触发回调函数，比如，[0, 0.25, 0.5, 0.75, 1]就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。\nroot、rootMargin：root属性指定目标元素所在的容器节点（即根元素）。注意，容器元素必须是目标元素的祖先节点。rootMargin属性。后者定义根元素的margin，用来扩展或缩小rootBounds这个矩形的大小，从而影响intersectionRect交叉区域的大小。它使用CSS的定义方法，比如10px 20px 30px 40px，表示 top、right、bottom 和 left 四个方向的值。\n\n参考文档\n参考视频\n","categories":["手写","vue"],"tags":["vue","vue-lazyload","图片懒加载","插件","自定义指令","IntersectionObserver"]},{"title":"手写flat","url":"/2022/04/18/%E6%89%8B%E5%86%99flat/","content":"手写flat（数组扁平化）Array.prototype._flat=function (depth=1)&#123;  function flatten(arr,depth)&#123;    if(depth&lt;=0) return [...arr]    return arr.reduce((pre,cur)=&gt;&#123;      if (Array.isArray(cur)) pre.push(...flatten(cur,depth-1)) //是数组，递归      else pre.push(cur) //不是数组，直接加入pre      return pre    &#125;,[])  &#125;  return flatten(this,depth)&#125;\n\nconst arr=[1,[2,3],[4,[5,6]],7]console.log(arr._flat()) //[1, 2, 3, 4, [5, 6], 7]console.log(arr._flat(1)) //[1, 2, 3, 4, [5, 6], 7]console.log(arr._flat(2)) //[1, 2, 3, 4, 5, 6, 7]console.log(arr._flat(Infinity)) //[1, 2, 3, 4, 5, 6, 7]\n\n代码简化：\nArray.prototype._flat = function (depth = 1) &#123;  function flatten(arr, depth) &#123;    return depth &lt;= 0 ?        [...arr] : arr.reduce((pre, cur) =&gt; Array.isArray(cur) ?            [...pre, ...flatten(cur, depth - 1)] : [...pre, cur], [])  &#125;  return flatten(this, depth)&#125;\n\n\n\n参考视频\n","categories":["JavaScript","手写"],"tags":["flat"]},{"title":"排序","url":"/2022/05/13/%E6%8E%92%E5%BA%8F/","content":"选择排序第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。\n以此类推，直到全部待排序的数据元素的个数为零。\n算法的时间复杂度为O(n^2)、额外空间复杂度为O(1)。\nfunction swap(arr, i, j) &#123;  let num = arr[i]  arr[i] = arr[j]  arr[j] = num&#125;const arr = [3, 44, 635, 7, 45, 34, 65, 2, 34, 6262, 432, 4]function selectSort(arr) &#123;  if (!Array.isArray(arr) || arr.length &lt; 2) return  let len = arr.length  for (let i = 0; i &lt; len; i++) &#123;    let index = i    for (let j = i + 1; j &lt; len; j++) &#123;      index = arr[index] &gt; arr[j] ? j : index    &#125;    swap(arr, i, index)  &#125;&#125;console.log(arr) //[3, 44, 635, 7, 45, 34, 65, 2, 34, 6262, 432, 4]selectSort(arr)console.log(arr) //[2, 3, 4, 7, 34, 34, 44, 45, 65, 432, 635, 6262]\n\n冒泡排序首先从数组的第一个元素开始到数组最后一个元素为止，对数组中相邻的两个元素进行比较，如果位于数组左端的元素大于数组右端的元素，则交换这两个元素在数组中的位置。这样操作后数组最右端的元素即为该数组中所有元素的最大值。\n接着对该数组除最右端的n-1个元素进行同样的操作，再接着对剩下的n-2个元素做同样的操作，直到整个数组有序排列。\n算法的时间复杂度为O(n^2)、额外空间复杂度为O(1)。\nfunction bubbleSort(arr) &#123;  if (!Array.isArray(arr) || arr.length &lt; 2) return  const len = arr.length  for (let i = len - 1; i &gt; 0; i--) &#123;    for (let j = 0; j &lt; i; j++) &#123;      arr[j] &gt; arr[j + 1] ? swap(arr, j, j + 1) : null    &#125;  &#125;&#125;console.log(arr) //[3, 44, 635, 7, 45, 34, 65, 2, 34, 6262, 432, 4]bubbleSort(arr)console.log(arr) //[2, 3, 4, 7, 34, 34, 44, 45, 65, 432, 635, 6262]\n\n插入排序将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增 1 的有序表。\n算法的时间复杂度为O(n^2)、额外空间复杂度为O(1)。\nfunction insertSort(arr) &#123;  if (!Array.isArray(arr) || arr.length &lt; 2) return  const len = arr.length  for (let i = 1; i &lt; len; i++) &#123;    let j = i    while (j &gt;= 0 &amp;&amp; arr[j - 1] &gt; arr[j]) &#123;      swap(arr, j - 1, j)      j--    &#125;  &#125;&#125;console.log(arr) //[3, 44, 635, 7, 45, 34, 65, 2, 34, 6262, 432, 4]insertSort(arr)console.log(arr) //[2, 3, 4, 7, 34, 34, 44, 45, 65, 432, 635, 6262]\n\n简化写法\nfunction insertSort2(arr) &#123;  if (!Array.isArray(arr) || arr.length &lt; 2) return  const len = arr.length  for (let i = 1; i &lt; len; i++) &#123;    for (let j = i - 1; j &gt; -1 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123;      swap(arr, j, j + 1)    &#125;  &#125;&#125;console.log(arr) //[3, 44, 635, 7, 45, 34, 65, 2, 34, 6262, 432, 4]insertSort2(arr)console.log(arr) //[2, 3, 4, 7, 34, 34, 44, 45, 65, 432, 635, 6262]\n\n对数器生成随机长度和随机值的数组，用于测试排序算法是否正确\nfunction randomArray(maxLen, maxVal) &#123;  const arr = []  const len = Math.floor(Math.random() * maxLen) + 1  for (let i = 0; i &lt; len; i++) &#123;    arr.push(Math.floor(Math.random() * maxVal))  &#125;  return arr&#125;function copy(arr) &#123;  const newArr = []  for (let i = 0; i &lt; arr.length; i++) &#123;    newArr.push(arr[i])  &#125;  return newArr&#125;//是否升序function isSorted(arr) &#123;  if (arr.length &lt; 2) return true  for (let i = 1; i &lt; arr.length; i++) &#123;    if (arr[i - 1] &gt; arr[i]) return false  &#125;  return true&#125;function testSort(sortFun) &#123;  for (let i = 0; i &lt; 1000; i++) &#123;    const arr = randomArray(10, 1000)    const backup = copy(arr)    sortFun(arr)    if (!isSorted(arr)) &#123;      console.log(&#x27;排序出错&#x27;)      console.log(&#x27;排序前:&#x27; + backup)      console.log(&#x27;排序后:&#x27; + arr)      return    &#125;  &#125;  console.log(&#x27;排序成功&#x27;)&#125;testSort(selectSort) //排序成功testSort(bubbleSort) //排序成功testSort(insertSort) //排序成功testSort(insertSort2) //排序成功\n\n归并排序将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。\n算法的时间复杂度为O(n*log n)、额外空间复杂度为O(n)。\nfunction merge(arr, l, m, r) &#123;  const help = []  let p1 = l  let p2 = m + 1  while (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;    arr[p1] &lt;= arr[p2] ? help.push(arr[p1++]) : help.push(arr[p2++])  &#125;  while (p1 &lt;= m) &#123;    help.push(arr[p1++])  &#125;  while (p2 &lt;= r) &#123;    help.push(arr[p2++])  &#125;  for (let i = 0; i &lt; help.length; i++) &#123;    arr[l + i] = help[i]  &#125;&#125;function mergeSortProcess(arr, l, r) &#123;  if (l === r) return  let mid = l + Math.floor((r - l) / 2)  mergeSortProcess(arr, l, mid)  mergeSortProcess(arr, mid + 1, r)  merge(arr, l, mid, r)&#125;function mergeSort(arr) &#123;  if (!Array.isArray(arr) || arr.length &lt; 2) return  let l = 0  let r = arr.length + 1  mergeSortProcess(arr, l, r)&#125;testSort(mergeSort) //排序成功\n\n快速排序荷兰国旗问题给定一个数组arr，数组的最后一个数为num，将arr划分为三个区域，左边的数都小于num，中间等于num，右边都大于num。\n要求额外空间复杂度O(1)，时间复杂度O(n)。\nfunction partition(arr, l, r) &#123;  let num = arr[r]  let i = l  while (i &lt;= r) &#123;    if (arr[i] &lt; num) &#123;      swap(arr, l++, i++)    &#125; else if (arr[i] === num) &#123;      i++    &#125; else &#123;      swap(arr, i, r--)    &#125;  &#125;  return [l, r]&#125;let arr = [1, 8, 7, 4, 5, 6, 1, 8, 4, 9, 5]//返回一个长度为二的数组，表示中间区域的左右边界console.log(partition(arr, 0, 10)) //[4, 5]console.log(arr) //[1, 4, 4, 1, 5, 5, 8, 6, 9, 7, 8]\n\n实现快速排序递归调用上面（荷兰国旗问题中）的方法，随机选择一个数作为num，划分为小于、等于、大于三个部分后，对左右两个区域执行相同的操作。\n算法的时间复杂度为O(n*log n)、额外空间复杂度为O(log n)。\nfunction quickSortProcess(arr, l, r) &#123;  if (l &gt;= r) return  //在l~r范围中随机取一个数和r位置的数交换  swap(arr, r, l + Math.floor(Math.random() * (r - l + 1)))  const part = partition(arr, l, r)  quickSortProcess(arr, l, part[0] - 1)  quickSortProcess(arr, part[1] + 1, r)&#125;function quickSort(arr) &#123;  if (!Array.isArray(arr) || arr.length &lt; 2) return  let l = 0  let r = arr.length - 1  quickSortProcess(arr, l, r)&#125;testSort(quickSort) //排序成功\n\n堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。（小顶堆或大顶堆，下面代码中使用的是大顶堆）\n算法的时间复杂度为O(n*log n)、额外空间复杂度为O(1)。\nfunction parentIndex(index) &#123;  if (!index) return index  return Math.floor((index - 1) / 2)&#125;//比父节点大则与父节点交换function heapInsert(arr, index) &#123;  while (arr[index] &gt; arr[parentIndex(index)]) &#123;    swap(arr, index, parentIndex(index))    index = parentIndex(index)  &#125;&#125;//比两个子节点中最大的一个小，则与其交换function heapify(arr, index, heapSize) &#123;  let left = index * 2 + 1  while (left &lt; heapSize) &#123;    let max = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left    max = arr[index] &lt; arr[max] ? max : index    if (max === index) break    swap(arr, index, max)    index = max    left = index * 2 + 1  &#125;&#125;function heapSort(arr) &#123;  let heapSize = arr.length  //生成大根堆（父节点大于子节点）,该循环时间复杂度为O(n*log n)  for (let i = 0; i &lt; heapSize; i++) &#123;    heapInsert(arr, i)  &#125;  //该循环时间复杂度为O(n*log n)  while (heapSize) &#123;    swap(arr, 0, --heapSize)    heapify(arr, 0, heapSize)  &#125;&#125;testSort(heapSort) //排序成功\n\n优化写法：（优化前一个循环：只需要使用heapify方法即可将一个数组转化为堆结构，且时间复杂度为O(n)）\nfunction heapSort(arr) &#123;  let heapSize = arr.length  //该循环时间复杂度为O(n)  for (let i = heapSize - 1; i &gt;= 0; i--) &#123;    heapify(arr, i, heapSize)  &#125;  while (heapSize) &#123;    swap(arr, 0, --heapSize)    heapify(arr, 0, heapSize)  &#125;&#125;testSort(heapSort) //排序成功\n\n稳定性假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]&#x3D;r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。\n\n不稳定的排序算法：选择排序、快速排序、堆排序等\n稳定的排序算法：冒泡排序、插入排序、归并排序等\n\n目前没有发现时间复杂度为O(n*log n)、额外空间复杂度低于O(n)且具有稳定性的排序算法。\n一般情况下，快速排序更常用，因为其常数项时间更低。额外空间要求很少时使用堆排序；要求稳定性时使用归并排序。\n还可以使用综合排序的方法提高效率。（比如在快排过程中的一些样本量比较少的步骤中使用插入排序）\n","categories":["算法"],"tags":["选择排序","冒泡排序","插入排序","归并排序","快速排序","堆排序"]},{"title":"算法与数据结构基础","url":"/2022/05/17/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/","content":"时间复杂度常数时间的操作\n常见的算术运算(+、-、*、&#x2F;、%等)\n常见的位运算(&gt;&gt;、&gt;&gt;&gt;、&lt;&lt;、|、&amp;、^、~等)\n赋值、比较、自增、自减操作等\n数组寻址操作\n\n总之，执行时间固定的操作都是常数时间的操作。反之，执行时间不固定的操作，都不是常数时间的操作。\n估算时间复杂度\n想象该算法流程所处理的数据状况，要按照最差情况来。\n把整个流程彻底拆分为一个个基本动作，保证每个动作都是常数时间的操作。\n如果数据量为N，看看基本动作的数量和N是什么关系。\n当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。记为:O(忽略掉系数的高阶项)\n\n比如：常数时间的操作的次数为xN^2+yN+z,则时间复杂度为O(N^2)\n常见的时间复杂度O(1)、O(N)、O(logN)、O(N*logN)、O(N^2)、O(N^3)、O(N^k)、O(2^N)、O(3^N)、O(k^N)、O(N!)\n额外空间复杂度你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。作为输入参数的空间,不算额外空间。作为输出结果的空间，也不算额外空间。因为这些都是必要的、和现实目标有关的。所以都不算。但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是额外空间。如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。\n最优解一般情况下，认为解决一个问题的算法流程,在时间复杂度的指标上，一定要尽可能的低，先满足了时间复杂度最低这个指标之后，使用最少的空间的算法流程，叫这个问题的最优解。一般说起最优解都是忽略掉常数项这个因素的,因为这个因素只决定了实现层次的优化和考虑，而和怎么解决整个问题的思想无关。\n异或运算\n不申请额外的存储空间，交换两个整数的值：\nlet a = 1let b = -1a = a ^ bb = a ^ ba = a ^ bconsole.log(a) //-1console.log(b) //1\n\n一个数组中有一个数出现了奇数次，其余的数都出现偶数次，找出那个数：\nlet arr = [1,3,2,1,4,3,3,4,2]let eor = 0arr.forEach(value =&gt; &#123;  eor ^= value&#125;)console.log(eor) //3\n\n参考视频\n","categories":["算法"],"tags":["时间复杂度"]},{"title":"数据可视化","url":"/2022/03/20/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/","content":"canvascanvas基本使用canvas标签\n &lt;!--canvas：画布，html5新增--&gt;&lt;!--有默认宽高：300 * 150--&gt;&lt;!--浏览器默认canvas标签是一张图片--&gt;&lt;!--给canvas添加文本和子节点无效--&gt;&lt;!--需要通过js操作画布显示内容--&gt;&lt;!--不要通过样式设置canvas的宽高，而通过标签的属性来设置--&gt;&lt;canvas width=&quot;500px&quot; height=&quot;300px&quot;&gt;&lt;/canvas&gt;\n\n通过js操作canvas\nlet canvas = document.querySelector(&#x27;canvas&#x27;)// 获取画布上下文let ctx = canvas.getContext(&#x27;2d&#x27;)// 绘制线段(起点)ctx.moveTo(100, 200)ctx.lineTo(200, 250)//终点（第二个点）ctx.lineTo(150, 300)//第三点ctx.closePath()//连接起点和第三个点ctx.fillStyle = &#x27;red&#x27;//设置填充的颜色ctx.fill()//填充ctx.strokeStyle = &#x27;blue&#x27;//设置线段颜色ctx.lineWidth = &#x27;5&#x27;//设置线段宽度ctx.stroke()//画出线/三角形边框\n\n绘制矩形const canvas = document.querySelector(&#x27;canvas&#x27;)const ctx = canvas.getContext(&#x27;2d&#x27;)//绘制矩形：参数为 左上点坐标和宽高ctx.strokeRect(100,200,300,100)//填充矩形：默认黑色ctx.fillRect(100,400,300,100)\n\n绘制圆形const canvas = document.querySelector(&#x27;canvas&#x27;)const ctx = canvas.getContext(&#x27;2d&#x27;)//开始绘制圆形ctx.beginPath()//画圆:arc(x,y,r,sAngle,eAngle,counterclockwise);//x,y:圆心，r：半径，sAngle：起始弧度，eAngle：结束弧度，(0到2PI绘制一个完整的圆)//counterclockwise：可选。规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针。ctx.arc(300, 200, 100, 0, 2 * Math.PI)//设置填充颜色ctx.fillStyle = &#x27;red&#x27;ctx.fill()//完成绘制ctx.stroke()\n\n清除画布与绘制文字const canvas = document.querySelector(&#x27;canvas&#x27;)const ctx = canvas.getContext(&#x27;2d&#x27;)ctx.fillRect(200,100,300,200)//清除画布(一个矩形范围内)ctx.clearRect(0,0,700,500)//设置字体ctx.font=&#x27;20px 微软雅黑&#x27;ctx.fillStyle=&#x27;red&#x27;//文字颜色//绘制文字(参数：文本内容和起始位置)ctx.fillText(&#x27;数据可视化&#x27;,50,20)\n\nsvg基本使用&lt;!--默认宽高：300*150,可通过样式设置宽高--&gt;&lt;!--在svg内部使用相应的标签绘图--&gt;&lt;svg class=&quot;box&quot;&gt;  &lt;!--画线:属性包括两点的坐标，stroke：线的颜色（必选），stroke-width：线的宽度--&gt;  &lt;line x1=&quot;100&quot; y1=&quot;100&quot; x2=&quot;200&quot; y2=&quot;300&quot; stroke=&quot;red&quot; stroke-width=&quot;5&quot;&gt;&lt;/line&gt;  &lt;!--折线：points：各个点的坐标--&gt;  &lt;!--会自动填充颜色（黑色），fill-opacity：填充颜色透明度--&gt;  &lt;polyline points=&quot;300 300,50 100,120 400&quot; stroke=&quot;green&quot; fill-opacity=&quot;0&quot;&gt;&lt;/polyline&gt;  &lt;!--矩形：默认填充黑色,fill:设置填充颜色--&gt;  &lt;rect x=&quot;400&quot; y=&quot;200&quot; width=&quot;150&quot; height=&quot;50&quot; fill=&quot;pink&quot;&gt;&lt;/rect&gt;  &lt;!--圆形：自动填充黑色，style：设置样式，r：半径，cx、cy：圆心坐标--&gt;  &lt;circle r=&quot;50&quot; cx=&quot;100&quot; cy=&quot;100&quot; style=&quot;stroke: skyblue;fill: none&quot;&gt;&lt;/circle&gt;  &lt;!--椭圆：rx：水平半径，ry：垂直半径--&gt;  &lt;ellipse rx=&quot;100&quot; ry=&quot;50&quot; cx=&quot;400&quot; cy=&quot;400&quot; style=&quot;stroke: skyblue;fill: none&quot;&gt;&lt;/ellipse&gt;  &lt;!--多边形--&gt;  &lt;polygon points=&quot;300 100,400 200,350 300&quot; stroke=&quot;blue&quot; fill=&quot;none&quot;&gt;&lt;/polygon&gt;  &lt;!--任意图形--&gt;  &lt;!--d:M:起点，L：线终点，Z：连接起点--&gt;  &lt;path d=&quot;M 10 10 L 120 70 L 30 140 L 60 340 L 432 110 Z&quot; fill=&quot;none&quot; stroke=&quot;red&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n\nEChartsECharts官网\n引入ECharts&lt;!--引入ECharts--&gt;&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/echarts/5.3.1/echarts.min.js&quot;&gt;&lt;/script&gt;\n\nimport引入：\nimport * as echarts from &#x27;echarts&#x27;\n\n基本使用&lt;!--准备一个容器--&gt;&lt;div style=&quot;width: 800px;height: 500px&quot; id=&quot;main&quot;&gt;&lt;/div&gt;\n\n初始化echarts实例：\nconst myCharts = echarts.init(document.getElementById(&#x27;main&#x27;));\n\n绘制柱状图\nmyCharts.setOption(&#123;  //标题  title:&#123;    text:&#x27;数据可视化&#x27;,//主标题    subtext:&#x27;echarts基本使用&#x27;,//副标题    textAlign:&#x27;center&#x27;,//居中对齐    left:&#x27;center&#x27;,//title 组件离容器左侧的距离。  &#125;,  //x轴配置  xAxis:&#123;    //数据    data:[&#x27;衣服&#x27;,&#x27;食品&#x27;,&#x27;游戏&#x27;,&#x27;电影&#x27;],  &#125;,  //y轴配置  yAxis: &#123;    axisLine:&#123;//线      show:true    &#125;,    axisTick:&#123;//刻度      show:true    &#125;  &#125;,  //系列的设置：图表的类型和数据  series:[    &#123;      //图标类型      type:&#x27;bar&#x27;,//bar：柱状图，line：折线图      data:[10,30,40,20],//数据      color:&#x27;pink&#x27;,//颜色    &#125;  ]&#125;)\n\n一个容器显示多个图表在series中配置多个图表\nseries: [      &#123;        //图标类型        type: &#x27;bar&#x27;,//bar：柱状图，line：折线图        data: [10, 30, 40, 20],//数据        color: &#x27;pink&#x27;,//颜色      &#125;,      &#123;        type: &#x27;line&#x27;,        data: [10, 30, 40, 20],//数据        color: &#x27;gray&#x27;      &#125;,      &#123;        type: &#x27;pie&#x27;,//pie:饼图        data: [&#123;name: &#x27;衣服&#x27;, value: 10&#125;, &#123;name: &#x27;食品&#x27;, value: 30&#125;, &#123;name: &#x27;游戏&#x27;, value: 40&#125;, &#123;name: &#x27;电影&#x27;, value: 20&#125;],        width: 300,//包括文字内容的大小范围        height: 150,        left: 500,//距离左侧的距离        radius: 50,//半径      &#125;    ]\n\ndataset数据集准备数据集（二维数组）\n//数据集const data = [  [&#x27;衣服&#x27;, 10, 20, &#x27;饮料&#x27;, 22],  [&#x27;食品&#x27;, 30, 10, &#x27;电器&#x27;, 44],  [&#x27;游戏&#x27;, 40, 40, &#x27;小说&#x27;, 11],  [&#x27;电影&#x27;, 20, 30, &#x27;音乐&#x27;, 33],]\n\n在echarts的配置对象中设置字符集\n//设置字符集dataset:&#123;  //数据源  source:data,&#125;,\n\nseries中的data换成encode，指定使用的数据的索引值\nseries: [  &#123;    //图标类型    type: &#x27;bar&#x27;,//bar：柱状图，line：折线图    // data: [10, 30, 40, 20],//数据    color: &#x27;pink&#x27;,//颜色    encode: &#123;      x: 0,      y: 1,    &#125;  &#125;,  &#123;    type: &#x27;line&#x27;,    // data: [10, 30, 40, 20],//数据    color: &#x27;gray&#x27;,    encode: &#123;      x: 0,      y: 2,    &#125;  &#125;,  &#123;    type: &#x27;pie&#x27;,//pie:饼图    // data: [&#123;name: &#x27;衣服&#x27;, value: 10&#125;, &#123;name: &#x27;食品&#x27;, value: 30&#125;, &#123;name: &#x27;游戏&#x27;, value: 40&#125;, &#123;name: &#x27;电影&#x27;, value: 20&#125;],    width: 300,//包括文字内容的大小范围    height: 150,    left: 500,//距离左侧的距离    radius: 50,//半径    encode: &#123;      //饼图旁边的文字      itemName: 3,      value: 4,    &#125;  &#125;]\n\n组件提示组件//提示组件(鼠标悬浮时显示)tooltip:&#123;  textStyle:&#123;    //文字颜色    color:&#x27;red&#x27;  &#125;&#125;\n\n系列切换组件给图表添加name属性\nseries: [  &#123;    name:&#x27;柱状图&#x27;,    type: &#x27;bar&#x27;,    encode: &#123;      x: 0,      y: 1,    &#125;  &#125;,  &#123;    name:&#x27;折线图&#x27;,    type: &#x27;line&#x27;,    encode: &#123;      x: 0,      y: 2,    &#125;  &#125;,],//系列切换组件legend:&#123;  data:[&#x27;柱状图&#x27;,&#x27;折线图&#x27;],  right: &#x27;20%&#x27;&#125;\n\n工具栏组件// 工具栏组件toolbox: &#123;  show: true,  feature: &#123;    dataZoom: &#123;      yAxisIndex: &quot;none&quot;    &#125;,    dataView: &#123;      readOnly: false    &#125;,    magicType: &#123;      type: [&quot;line&quot;, &quot;bar&quot;]    &#125;,    restore: &#123;&#125;,    saveAsImage: &#123;&#125;  &#125;&#125;,\n\n双坐标两个x轴\nmyCharts.setOption(&#123;  title: &#123;    text: &#x27;echarts坐标系&#x27;,    left: &#x27;center&#x27;,    textAlign: &#x27;center&#x27;,  &#125;,  //多个坐标系，使用数组  xAxis: [    &#123;      data: [&#x27;衣服&#x27;, &#x27;食品&#x27;, &#x27;游戏&#x27;, &#x27;电影&#x27;],    &#125;,    &#123;&#125;,  ],  yAxis: &#123;&#125;,  series: [    &#123;      type: &#x27;scatter&#x27;,//散点图      data: [        [11, 87],        [34, 45],        [64, 23],        [43, 54],        [12, 40],      ],      xAxisIndex: 1,//使用第二个x轴    &#125;,    &#123;      type: &#x27;bar&#x27;,      data: [10, 30, 40, 20],      xAxisIndex: 0,//使用第一个x轴    &#125;  ]&#125;)\n","categories":["数据可视化"],"tags":["Echarts","canvas","svg"]},{"title":"查找","url":"/2022/05/14/%E6%9F%A5%E6%89%BE/","content":"二分法const arr = [1, 2, 3, 4, 6, 8, 11, 17, 23, 24, 30]function find(arr, num) &#123;  if (!Array.isArray(arr) || arr.length === 0) &#123;    return false  &#125;  let l = 0  let r = arr.length - 1  while (l &lt;= r) &#123;    let mid = Math.floor((l + r) / 2)    if (arr[mid] === num) &#123;      return true    &#125; else if (arr[mid] &lt; num) &#123;      l = mid + 1    &#125; else &#123;      r = mid - 1    &#125;  &#125;  return false&#125;console.log(find(arr,3))//trueconsole.log(find(arr,13))//falseconsole.log(find(arr,23))//trueconsole.log(find(arr,33))//false\n","categories":["算法"],"tags":["二分法"]},{"title":"链表","url":"/2022/05/16/%E9%93%BE%E8%A1%A8/","content":"单链表反转function Node(value, next) &#123;  this.value = value  this.next = next&#125;const n1 = new Node(1)n1.next = new Node(2)n1.next.next = new Node(3)function reverse(head) &#123;  let pre = null  let next = null  while (head) &#123;    next = head.next    head.next = pre    pre = head    head = next  &#125;  return pre&#125;let n2 = reverse(n1)while (n2) &#123;  console.log(n2.value) //3 2 1  n2 = n2.next&#125;\n\n双向链表反转function DoubleNode(value,last,next)&#123;  this.value = value  this.last = last  this.next = next&#125;let n1 = new DoubleNode(1,null)n1.next = new DoubleNode(2,n1)n1.next.next = new DoubleNode(3,n1.next)function reverseDouble(head)&#123;  let pre = null  let next = null  while (head)&#123;    next = head.next    head.next = pre    head.last = next    pre = head    head = next  &#125;  return pre&#125;\n\nK 个一组翻转链表leetcode上的题目： K 个一组翻转链表\nvar reverseKGroup = function(head, k) &#123;  let start = head  let end = getGroupEnd(start,k)  if(!end)&#123;    return start  &#125;  head = end  reverse(start,end)  let lastEnd = start  while(start.next)&#123;    start = start.next    end = getGroupEnd(start,k)    if(!end)&#123;      return head    &#125;    reverse(start,end)    lastEnd.next = end    lastEnd = start  &#125;  return head&#125;;function getGroupEnd(start,k)&#123;  while(--k &gt; 0 &amp;&amp; start)&#123;    start = start.next  &#125;  return start&#125;function reverse(start,end)&#123;  let cur = start  let pre = null  let next = null  while(start !== end)&#123;    next = start.next    start.next = pre    pre = start    start = next  &#125;  next = start.next  start.next = pre  cur.next = next&#125;\n\n有序链表合并leetcode上的题目：合并两个有序链表\nvar mergeTwoLists = function (list1, list2) &#123;  if (!list1 || !list2) &#123;    return list1 ? list1 : list2  &#125;  let head = list1.val &lt; list2.val ? list1 : list2  let cur1 = head.next  let cur2 = head === list1 ? list2 : list1  let pre = head  while (cur1 &amp;&amp; cur2) &#123;    if (cur1.val &lt; cur2.val) &#123;      pre.next = cur1      cur1 = cur1.next    &#125; else &#123;      pre.next = cur2      cur2 = cur2.next    &#125;    pre = pre.next  &#125;  pre.next = cur1 ? cur1 : cur2  return head&#125;;\n\n快慢指针快慢指针：快指针每次沿链表向前移动2，慢指针每次向前移动1次。\n应用：判断单链表是否为回文链表：（leetcode上的题目：回文链表）\n思路：遍历链表，将值拷贝到一个栈中；再次遍历链表，对比每次出栈的值是否相同即可。\n优化：使用快慢指针，在遍历到一半时开始进行比较即可，节省一半的额外空间。\nvar isPalindrome = function(head) &#123;  if(!head || !head.next) return true  let fast = head  let slow = head  const stack = []  while(fast &amp;&amp; fast.next)&#123;    stack.push(slow.val)    fast = fast.next.next    slow = slow.next  &#125;  if(fast) slow = slow.next  while(slow)&#123;    if(stack.pop() !== slow.val) return false    slow = slow.next  &#125;  return true&#125;;\n\n继续优化：只使用O(1)的额外空间复杂度，慢指针在走的过程中将前半部分的链表反转\nvar isPalindrome = function(head) &#123;  if(!head || !head.next) return true  let fast = head,slow = head,cur = head  let pre = null  while(fast &amp;&amp; fast.next)&#123;    fast = fast.next.next    slow = slow.next    cur.next = pre    pre = cur    cur = slow  &#125;  if(fast) slow = slow.next  while(slow)&#123;    if(slow.val !== pre.val) return false    slow = slow.next    pre = pre.next  &#125;  return true&#125;;\n\n注：上面未将链表的反转部分还原\n环形链表leetcode上的题目：环形链表 II\n返回链表开始入环的第一个节点，如果链表无环，则返回 null。\nvar detectCycle = function(head) &#123;  if(!head || !head.next || !head.next.next) return null  let fast = head.next.next, slow = head.next  while(fast !== slow)&#123;    fast = fast.next?.next    slow = slow.next    if(!fast) return null  &#125;  fast = head  while(fast !== slow)&#123;    fast = fast.next    slow = slow.next  &#125;  return slow&#125;;\n\n假设环外有a个节点，环内有b个节点，则第a+nb个节点一定是入口节点。使用快慢指针判断有环无环，快慢指针相遇时在第nb个节点，再走a步即可。\n","categories":["数据结构"],"tags":["链表"]},{"title":"防抖节流","url":"/2022/03/09/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/","content":"防抖function debounce(fn, duration = 500) &#123;//自定义防抖函数,默认0.5秒内没有再次触发该函数时执行    let timer    return function (...args) &#123;        timer &amp;&amp; clearTimeout(timer)        timer = setTimeout(() =&gt; &#123;            typeof fn === &#x27;function&#x27; &amp;&amp; fn.apply(this, args)        &#125;, duration)    &#125;&#125;const input = document.getElementById(&#x27;input&#x27;)input.addEventListener(&#x27;input&#x27;, debounce(event =&gt; &#123;    console.log(event.target.value)&#125;));\n\n节流function throttle(fn, duration = 1000) &#123; //自定义节流函数，1秒内只触发一次    let time = 0    return function (...args) &#123;        if (new Date() - time &gt; duration) &#123;            typeof fn === &#x27;function&#x27; &amp;&amp; fn.apply(this, args)            time = new Date()        &#125;    &#125;&#125;const btn = document.getElementById(&#x27;btn&#x27;)btn.addEventListener(&#x27;click&#x27;, throttle(event =&gt; &#123;    console.log(event.target.innerText)&#125;));\n\n","categories":["JavaScript","手写"],"tags":["JavaScript"]},{"title":"css高级","url":"/2022/07/27/css%E9%AB%98%E7%BA%A7/","content":"样式初始化/* 样式初始化 */* &#123;  /* 清除默认的外边框和内边框 */  margin: 0;  padding: 0;  /* 统一盒子模型 */  box-sizing: border-box;&#125;/* 和字体相关的样式写在body中,因为默认会被继承 */body &#123;  font-family: &#x27;Lato&#x27;, sans-serif;  font-weight: 400;  font-size: 16px;  /* 当前字体尺寸的1.7倍 */  line-height: 1.7;  color: #777;    padding: 30px;&#125;\n\n背景图&#x2F;裁剪区域html文件中导入样式文件，并准备一个容器。\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;!-- Lato字体 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://fonts.googleapis.com/css?family=Lato:100,300,400,700,900&quot; /&gt;    &lt;!-- 基础样式 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;style/style.css&quot; /&gt;    &lt;!-- 页面图标 --&gt;    &lt;link rel=&quot;shortcut icon&quot; href=&quot;img/favicon.ico&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;header class=&quot;header&quot;&gt;header content...&lt;/header&gt;  &lt;/body&gt;&lt;/html&gt;\n\n.header &#123;  height: 95vh;  /* 可指定多个背景图 */  /* linear-gradient函数用于创建一个颜色线性渐变的图片*/  /* url指定图片路径 */  background-image: linear-gradient(      to right bottom,      rgba(126, 213, 111, 0.8),      rgba(40, 180, 131, 0.8)    ),    url(../img/background.png);  /* 保持图像的纵横比并完全覆盖背景区域 */  background-size: cover;  /* 窗口缩放时图片顶部保持不动 */  background-position: top;  /* clip-path:指定元素的可视区域 */  /* polygon函数用于创建一个多边形,从右上角开始顺时针指定顶点 */  clip-path: polygon(0 0, 100% 0, 100% 80%, 0 100%);&#125;\n\n","categories":["css"],"tags":["css","style"]},{"title":"发布npm包","url":"/2022/08/06/%E5%8F%91%E5%B8%83npm%E5%8C%85/","content":"注册账号\n在npm官网注册\n\n登录账号（需要npm镜像源为npm官方源）\nnpm config get registry //查看当前镜像源nrm use npm //使用npm官方镜像源（如果安装了nrm）npm config set registry https://registry.npmjs.org/ //使用npm官方镜像npm login //登录（输入账号密码、邮箱和验证码）npm adduser //效果同上\n\n查看当前账号\nnpm whoami\n\npackage.jsonname和version是必须的\n&#123;  &quot;name&quot;: &quot;xxx&quot;,  //包名（要避免与npm上已有的包重名）  &quot;version&quot;: &quot;0.0.1&quot;, //版本号  //&quot;private&quot;: true, //为true时，npm将拒绝发布该程序包  &quot;type&quot;: &quot;module&quot;, //使用es模块加载（默认值为commonjs）  &quot;keywords&quot;: [], //关键词  &quot;repository&quot;: &#123; //关联的远程仓库    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;https://github.com/xxx/xxx.git&quot; //远程仓库url  &#125;,  &quot;files&quot;: [ //指定要发布的文件夹或文件（默认发布所有文件，package.json始终会被发布）    &quot;dist&quot;  ],  &quot;main&quot;: &quot;./dist/xxx.umd.js&quot;, //指定通过name被导入时的入口文件  &quot;module&quot;: &quot;./dist/xxx.es.js&quot;, //指定通过name被es模块导入时的入口文件  &quot;types&quot;: &quot;./dist/types/index.d.ts&quot;, //类型声明文件  &quot;exports&quot;: &#123; //定义导出的内容（main和module的替代品）    &quot;.&quot;: &#123;      &quot;types&quot;: &quot;./dist/types/index.d.ts&quot;,      &quot;import&quot;: &quot;./dist/icons.es.js&quot;,      &quot;require&quot;: &quot;./dist/icons.umd.js&quot;    &#125;  &#125;,  &quot;license&quot;: &quot;MIT&quot; //开源协议&#125;\n\n发布\n发布前需切换至官方镜像源\nnpm publish// 再次发布前需要将version版本号加一\n\n当发布name以@开头的包时，npm默认发布私有包（私有包需要收费），使用如下命令发布为公开包\nnpm publish --access public\n\n发布beta版本（修改version，如0.0.1-beta.1）\nnpm publish --tag=beta\n\n发布成功后登录npm官网即可看到自己发布的包\n\n\n作废和撤销\n作废npm包，表示不在维护更新\nnpm deprecate &lt;package-name&gt; &quot;&lt;message&gt;&quot;\n\n撤销发布包（只能删除24小时内发布的最后一个版本）\nnpm unpublish &lt;package-name&gt; --force\n\n","categories":["前端工程化"],"tags":["npm","package.json"]},{"title":"js继承","url":"/2022/10/17/js%E7%BB%A7%E6%89%BF/","content":"原型链继承function Parent () &#123;  this.name = &#x27;kevin&#x27;;&#125;Parent.prototype.getName = function () &#123;  console.log(this.name);&#125;function Child () &#123;&#125;// 子类的原型指向父类的实例Child.prototype = new Parent();var child1 = new Child();console.log(child1.getName()) // kevin\n\n缺点：\n\n引用（对象）类型的属性被所有实例共享\nfunction Parent () &#123;  this.names = [&#x27;kevin&#x27;, &#x27;daisy&#x27;];&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();child1.names.push(&#x27;yayu&#x27;);console.log(child1.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]var child2 = new Child();console.log(child2.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]\n\n在创建 Child 的实例时，不能向Parent传参\n\n\n构造函数继承function Parent (name) &#123;  this.names = [name, &#x27;daisy&#x27;];&#125;function Child (name) &#123;  // 调用父类构造函数  Parent.call(this, name);&#125;var child1 = new Child(&#x27;kevin1&#x27;);child1.names.push(&#x27;yayu&#x27;);console.log(child1.names); // [&quot;kevin1&quot;, &quot;daisy&quot;, &quot;yayu&quot;]var child2 = new Child(&#x27;kevin2&#x27;);console.log(child2.names); // [&quot;kevin2&quot;, &quot;daisy&quot;]\n\n优点：\n\n避免了引用（对象）类型的属性被所有实例共享\n\n可以在 Child 中向 Parent 传参\n\n\n缺点：只能继承父类的实例属性和方法，不能继承原型属性或者方法。\n组合继承融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。\nfunction Parent (name) &#123;  this.name = name;  this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];&#125;Parent.prototype.getName = function () &#123;  console.log(this.name)&#125;function Child (name, age) &#123;  Parent.call(this, name); // 第二次调用父构造函数  this.age = age;&#125;Child.prototype = new Parent(); // 第一次调用父构造函数Child.prototype.constructor = Child; // 修改为正确的constructor指向var child1 = new Child(&#x27;kevin&#x27;, &#x27;18&#x27;);child1.colors.push(&#x27;black&#x27;);console.log(child1.name); // kevinconsole.log(child1.age); // 18console.log(child1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]var child2 = new Child(&#x27;daisy&#x27;, &#x27;20&#x27;);console.log(child2.name); // daisyconsole.log(child2.age); // 20console.log(child2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]\n\n缺点：会调用两次父构造函数。所以，在上述例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为colors，属性值为[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]。\n原型式继承就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。\nfunction createObj(o) &#123;  function F()&#123;&#125;  F.prototype = o;  return new F();&#125;\n\n缺点：因为Object.create方法实现的是浅拷贝，多个实例的引用类型属性指向相同的内存，存在篡改的可能。\nvar person = &#123;  name: &#x27;kevin&#x27;,  friends: [&#x27;daisy&#x27;, &#x27;kelly&#x27;]&#125;var person1 = createObj(person);var person2 = createObj(person);person1.name = &#x27;person1&#x27;;console.log(person2.name); // kevinperson1.friends.push(&#x27;taylor&#x27;);console.log(person2.friends); // [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]\n\n注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = &#39;person1&#39;，给person1添加了 name 值，并非修改了原型上的 name 值。\n寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。\nfunction createObj (o) &#123;  var clone = Object.create(o);  clone.sayName = function () &#123;    console.log(&#x27;hi&#x27;);  &#125;  return clone;&#125;\n\n缺点：跟上面讲的原型式继承一样。\n寄生组合式继承function Parent (name) &#123;  this.name = name;  this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];&#125;Parent.prototype.getName = function () &#123;  console.log(this.name)&#125;function Child (name, age) &#123;  Parent.call(this, name);  this.age = age;&#125;// 关键的三步var F = function () &#123;&#125;;F.prototype = Parent.prototype;Child.prototype = new F();// 上面三步相当于// Child.prototype = Object.create(Parent.prototype)Child.prototype.constructor = Childvar child1 = new Child(&#x27;kevin&#x27;, &#x27;18&#x27;);console.log(child1);\n\n优点：只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。\nclass继承利用babel工具进行转换，我们会发现extends实际采用的也是寄生组合继承方式。\nclass Animal &#123;  constructor(name) &#123;    this.name = name;  &#125;  hello() &#123;    console.log(&quot;hello&quot;);  &#125;&#125;class Dog extends Animal &#123;  constructor(name, say) &#123;    super(name); // 通过super调用父构造函数    this.say = say;  &#125;&#125;\n\n\n\n参考\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"层叠上下文","url":"/2022/10/17/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/","content":"层叠上下文我们假定用户正面向（浏览器）视窗或网页，而 HTML 元素沿着其相对于用户的一条虚构的 z 轴排开，层叠上下文就是对这些 HTML 元素的一个三维构想。众 HTML 元素基于其元素属性按照优先级顺序占据这个空间。\n层叠水平\n层叠水平决定了同一个层叠上下文中元素在z轴上的显示顺序。\n\n普通元素的层叠水平优先由层叠上下文决定，因此，层叠水平的比较只有在当前层叠上下文元素中才有意义。\n\n\n注意：千万不要把层叠水平和CSS的z-index属性混为一谈。某些情况下z-index确实可以影响层叠水平，但是，只限于定位元素以及flex盒子的孩子元素；而层叠水平所有的元素都存在。\n层叠顺序元素发生层叠时候有着特定的垂直显示顺序，层叠顺序从小到大如下：\n\nbackground &#x2F; border\n负z-index\nblock块级水平盒子\nfloat浮动盒子\ninline &#x2F; inline-block水平盒子\nz-index: auto &#x2F; z-index: 0 &#x2F; 不依赖z-index的层叠上下文\n正z-index\n\n生成层叠上下文\nHTML中的根元素&lt;html&gt;&lt;/html&gt;本身就具有层叠上下文，称为“根层叠上下文”；\n普通元素设置position属性为非static值并设置z-index属性为具体数值，产生层叠上下文；\n父元素的display属性值为flex|inline-flex|grid，子元素z-index属性值不为auto的时候，子元素为层叠上下文元素；\n元素的opacity属性值不是1；\n以下任意属性值不为none的元素：\ntransform\nfilter\nbackdrop-filter\nperspective\nclip-path\nmask &#x2F; mask-image &#x2F; mask-border\n\n\n元素mix-blend-mode属性值不是normal；\n元素的isolation属性值是isolate；\nwill-change指定的属性值为上面任意一个；\n元素的-webkit-overflow-scrolling属性值设置为touch。\n\n层叠上下文的特点\n谁大谁上：当具有明显的层叠水平标示的时候，如识别的z-indx值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。通俗讲就是官大的压死官小的。\n后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。\n在层叠上下文中，子元素同样也按照上面解释的规则进行层叠。重要的是，其子级层叠上下文的 z-index 值只在父级中才有意义。子级层叠上下文被自动视为父级层叠上下文的一个独立单元。\n层叠上下文可以包含在其他层叠上下文中，并且一起创建一个层叠上下文的层级。\n每个层叠上下文都完全独立于它的兄弟元素：当处理层叠时只考虑子元素。\n每个层叠上下文都是自包含的：当一个元素的内容发生层叠后，该元素将被作为整体在父级层叠上下文中按顺序进行层叠。\n\n总结\n先看要比较的两个元素是否处于同一个层叠上下文中。如果是，谁的层叠水平大，谁在上面。 \n如果两个元素不在同一层叠上下文中，请先比较他们所处的层叠上下文的层叠水平。 当两个元素层叠水平相同、层叠顺序相同时，在DOM结构中后面的元素层叠等级在前面元素之上。\n\n参考\n","categories":["css"],"tags":["css","z-index"]},{"title":"块级格式化上下文","url":"/2022/10/18/%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/","content":"BFC的概念块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。\n通俗理解\nBFC 是一个独立的布局环境,可以理解为一个容器,在这个容器中按照一定规则进行物品摆放,并且不会影响其它环境中的物品。\n如果一个元素符合触发 BFC 的条件，则 BFC 中的元素布局不受外部影响。\n浮动元素会创建 BFC，则浮动元素内部子元素主要受该浮动元素影响，所以两个浮动元素之间是互不影响的。\n\n生成BFC\n根元素或包含根元素的元素\n浮动元素 float ＝ left | right | inherit（≠ none）\n绝对定位元素 position ＝ absolute 或 fixed\ndisplay ＝ inline-block | flex | inline-flex | table-cell | table-caption\noverflow ＝ hidden | auto | scroll (≠ visible)\n\nBFC的特性\nBFC 是一个独立的容器，容器内子元素不会影响容器外的元素。反之亦如此。\n盒子从顶端开始垂直地一个接一个地排列，盒子之间垂直的间距是由 margin 决定的。\n在同一个 BFC 中，两个相邻的块级盒子的垂直外边距会发生重叠。\nBFC 区域不会和 float box 发生重叠。\nBFC 能够识别并包含浮动元素，当计算其区域的高度时，浮动元素也可以参与计算了。\n\nBFC的作用清除浮动\n浮动元素会脱离文档流(绝对定位元素也会脱离文档流)，导致无法计算准确的高度，这种问题称为高度塌陷。\n解决高度塌陷问题的前提是能够识别并包含浮动元素，也就是清除浮动。\n\n清除方法：创建BFC\n&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;Sibling&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;Sibling&quot;&gt;&lt;/div&gt;&lt;/div&gt;\n\n.container &#123;   overflow: hidden; /* 生成BFC */  background-color: green; &#125; .container .Sibling &#123;   float: left;   margin: 10px;  background-color: lightgreen;  &#125;\n\n注意：通过 overflow: hidden 创建 BFC，固然可以解决高度塌陷的问题，但是大范围应用在布局上肯定不是最合适的，毕竟 overflow: hidden 会造成溢出隐藏的问题，尤其是与 JS 的交互效果会有影响。\n改进：使用clear: both\n&lt;div class=&quot;container clearfix&quot;&gt;  &lt;div class=&quot;Sibling&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;Sibling&quot;&gt;&lt;/div&gt;&lt;/div&gt;\n\n.container &#123;   background-color: green; &#125; .container .Sibling &#123;   float: left;   margin: 10px;  background-color: lightgreen;  &#125;.clearfix::after &#123;  content: &quot;&quot;;  display: block;  clear: both; // 清除浮动&#125;\n\n避免外边距折叠外边距折叠（Margin collapsing）只会发生在属于同一BFC的块级元素之间。如果它们属于不同的 BFC，它们之间的外边距则不会折叠。所以通过创建一个不同的 BFC ，就可以避免外边距折叠。\n参考\n","categories":["css"],"tags":["css","BFC"]},{"title":"闭包与作用域","url":"/2022/10/20/%E9%97%AD%E5%8C%85%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/","content":"闭包一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。\n也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。\nfunction init() &#123;    var name = &quot;Mozilla&quot;; // name 是一个被 init 创建的局部变量    function displayName() &#123; // displayName() 是内部函数，一个闭包        alert(name); // 使用了父函数中声明的变量    &#125;    displayName();&#125;init();\n\ndisplayName() 没有自己的局部变量。然而，由于闭包的特性，它可以访问到外部函数的变量\n作用\n创建私有变量\n延长变量的生命周期\n\n\n一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的。\n\n柯里化函数柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用。\n// 使用闭包柯里化一个计算矩形面积的函数function getArea(width) &#123;  return height =&gt; &#123;    return width * height  &#125;&#125;getArea(10)(20) // 200\n\n模拟私有方法在JavaScript中，没有支持声明私有变量，但我们可以使用闭包来模拟私有方法\nvar Counter = (function() &#123;  var privateCounter = 0;  function changeBy(val) &#123;    privateCounter += val;  &#125;  return &#123;    increment: function() &#123;      changeBy(1);    &#125;,    decrement: function() &#123;      changeBy(-1);    &#125;,    value: function() &#123;      return privateCounter;    &#125;  &#125;&#125;)();var Counter1 = makeCounter();var Counter2 = makeCounter();console.log(Counter1.value()); /* logs 0 */Counter1.increment();Counter1.increment();console.log(Counter1.value()); /* logs 2 */Counter1.decrement();console.log(Counter1.value()); /* logs 1 */console.log(Counter2.value()); /* logs 0 */\n\n上述通过使用闭包来定义公共函数，并令其可以访问私有函数和变量，这种方式也叫模块方式。\n两个计数器 Counter1 和 Counter2 是维护它们各自的独立性的，每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境，不会影响另一个闭包中的变量。\n注意如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。\n作用域作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。\n换句话说，作用域决定了代码区块中变量和其他资源的可见性。\n我们在全局是无法获取到（闭包除外）函数内部的变量。\n我们一般将作用域分成：\n\n全局作用域\n函数作用域\n块级作用域\n\n全局作用域任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问\n// 全局变量var greeting = &#x27;Hello World!&#x27;;function greet() &#123;  console.log(greeting);&#125;// 打印 &#x27;Hello World!&#x27;greet();\n\n函数作用域函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问。\nfunction greet() &#123;  var greeting = &#x27;Hello World!&#x27;;  console.log(greeting);&#125;// 打印 &#x27;Hello World!&#x27;greet();// 报错： Uncaught ReferenceError: greeting is not definedconsole.log(greeting);\n\n可见上述代码中在函数内部声明的变量或函数，在函数外部是无法访问的，这说明在函数内部定义的变量或者方法只是函数作用域。\n块级作用域ES6引入了let和const关键字,和var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量。\n&#123;  // 块级作用域中的变量  let greeting = &#x27;Hello World!&#x27;;  var lang = &#x27;English&#x27;;  console.log(greeting); // Prints &#x27;Hello World!&#x27;&#125;// 变量 &#x27;English&#x27;console.log(lang);// 报错：Uncaught ReferenceError: greeting is not definedconsole.log(greeting);\n\n词法作用域词法作用域，又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，JavaScript 遵循的就是词法作用域。\nvar a = 2;function foo()&#123;    console.log(a)&#125;function bar()&#123;    var a = 3;    foo();&#125;bar()\n\n由于JavaScript遵循词法作用域，相同层级的 foo 和 bar 就没有办法访问到彼此块作用域中的变量，所以输出2。\n作用域链当在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。\n如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错。\n","categories":["JavaScript"],"tags":["JavaScript","闭包","作用域链"]},{"title":"vue3性能提升","url":"/2022/10/20/vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/","content":"响应式vue2中采用 defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式\nvue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历\n\n可以监听动态属性的添加\n可以监听到数组的索引和数组length属性\n可以监听删除属性\n\ndefineProperty\n检测不到对象属性的添加和删除\n数组API方法无法监听到\n需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题\n\n源码体积相比Vue2，Vue3整体体积变小了，除了移出一些不常用的API，最重要的是Tree shanking\n任何一个函数，如ref、reavtived、computed等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小\nTree shakingTree shaking是基于ES6模板语法（import与exports），主要是借助ES6模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量\nTree shaking无非就是做了两件事：\n\n编译阶段利用ES6 Module判断哪些模块已经加载\n判断那些模块和变量未被使用或者引用，进而删除对应代码\n\n通过Tree shaking，Vue3给我们带来的好处是：\n\n减少程序体积（更小）\n减少程序执行时间（更快）\n便于将来对程序架构进行优化（更友好）\n\n编译阶段回顾Vue2，我们知道每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把用到的数据property记录为依赖，当依赖发生改变，触发setter，则会通知watcher，从而使关联的组件重新渲染。\nVue3在编译阶段，做了进一步优化。主要有如下：\n\ndiff算法优化\n静态提升\n事件监听缓存\nSSR优化\n\ndiff算法优化一个组件结构如下：\n&lt;template&gt;\t&lt;div id=&quot;content&quot;&gt;    &lt;p class=&quot;text&quot;&gt;静态文本&lt;/p&gt;    &lt;p class=&quot;text&quot;&gt;静态文本&lt;/p&gt;    &lt;p class=&quot;text&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;    &lt;p class=&quot;text&quot;&gt;静态文本&lt;/p&gt;    ...    &lt;p class=&quot;text&quot;&gt;静态文本&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;\n\n可以看到，组件内部只有一个动态节点，剩余一堆都是静态节点，所以这里很多 diff 和遍历其实都是不需要的，造成性能浪费。\nvue3在diff算法中相比vue2增加了静态标记。\n关于这个静态标记，其作用是为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较。\n静态类型枚举如下\nexport const enum PatchFlags &#123;  TEXT = 1,  // 动态的文本节点  CLASS = 1 &lt;&lt; 1,  // 2 动态的 class  STYLE = 1 &lt;&lt; 2,  // 4 动态的 style  PROPS = 1 &lt;&lt; 3,  // 8 动态属性，不包括类名和样式  FULL_PROPS = 1 &lt;&lt; 4,  // 16 动态 key，当 key 变化时需要完整的 diff 算法做比较  HYDRATE_EVENTS = 1 &lt;&lt; 5,  // 32 表示带有事件监听器的节点  STABLE_FRAGMENT = 1 &lt;&lt; 6,   // 64 一个不会改变子节点顺序的 Fragment  KEYED_FRAGMENT = 1 &lt;&lt; 7, // 128 带有 key 属性的 Fragment  UNKEYED_FRAGMENT = 1 &lt;&lt; 8, // 256 子节点没有 key 的 Fragment  NEED_PATCH = 1 &lt;&lt; 9,   // 512  DYNAMIC_SLOTS = 1 &lt;&lt; 10,  // 动态 solt  HOISTED = -1,  // 特殊标志是负整数表示永远不会用作 diff  BAIL = -2 // 一个特殊的标志，指代差异算法&#125;\n\n静态提升Vue3中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用。\n这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用。\n事件监听缓存默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化。\n开启事件侦听器缓存后没有了静态标记，也就是说下次diff算法的时候直接使用。\nSSR优化当静态内容大到一定量级时候，会用createStaticVNode方法在客户端去生成一个static node，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染。\n","categories":["vue3"],"tags":["vue3","proxy"]},{"title":"OSI七层模型和TCP/IP协议","url":"/2022/10/20/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8CTCPIP%E5%8D%8F%E8%AE%AE/","content":"OSIOSI （Open System Interconnect）模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。\nOSI将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰。\nOSI主要划分了七层，如下\n应用层应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用\n该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP协议等\n在应用层交互的数据单元我们称之为报文\n表示层表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 OSI参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务\n该层提供的服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异\n会话层会话层就是负责建立、管理和终止表示层实体之间的通信会话\n该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法\n传输层传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题\n传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层\n其中，主要的传输层协议是TCP和UDP\n网络层两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网\n网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送\n在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层\n在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层\n数据链路层数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议\n在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP数据报组装成帧，在两个相邻节点间的链路上传送帧\n每一帧的数据可以分成：报头head和数据data两部分:\n\nhead 标明数据发送者、接受者、数据类型，如 MAC地址\ndata 存储了计算机之间交互的数据\n\n通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源\n物理层作为OSI 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送\n该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）\n该层主要是和硬件有关，与软件关系不大\n传输过程\n应用层报文被传送到运输层\n在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用\n应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变\n运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报\n网络层数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧\n在物理层数据帧被封装成比特流，之后通过传输介质传送到对端\n对端再一步步解开封装，获取到传送的数据\n\nTCP&#x2F;IP协议TCP&#x2F;IP，传输控制协议&#x2F;网际协议，是指能够在多个不同网络间实现信息传输的协议簇。\n\nTCP（传输控制协议）\n一种面向连接的、可靠的、基于字节流的传输层通信协议\n\nIP（网际协议）\n用于封包交换数据网络的协议\n\n\nTCP&#x2F;IP协议不仅仅指的是TCP和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇，只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以通称为TCP&#x2F;IP协议族（英语：TCP&#x2F;IP Protocol Suite，或TCP&#x2F;IP Protocols）\n划分TCP&#x2F;IP协议族按层次分别了五层体系或者四层体系：\n五层体系的协议结构是综合了 OSI 和 TCP&#x2F;IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。\n五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构，包括应用层、传输层、网络层（网际互联层）、网络接口层。\n五层体系应用层TCP/IP 模型将 OSI参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务\n如：FTP、Telnet、DNS、SMTP 等\n传输层该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能\n传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）\n其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输\n网络层负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机\n在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组或包进行传送\n数据链路层数据链路层在两个相邻节点传输数据时，将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧\n物理层保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境\n四层体系TCP&#x2F;IP 的四层结构则如下表所示：\n\n\n\n层次名称\n单位\n功 能\n协 议\n\n\n\n网络接口层\n帧\n负责实际数据的传输，对应OSI参考模型的下两层\nHDLC（高级链路控制协议）PPP（点对点协议） SLIP（串行线路接口协议）\n\n\n网络层\n数据报\n负责网络间的寻址数据传输，对应OSI参考模型的第三层\nIP（网际协议） ICMP（网际控制消息协议）ARP（地址解析协议） RARP（反向地址解析协议）\n\n\n传输层\n报文段\n负责提供可靠的传输服务，对应OSI参考模型的第四层\nTCP（控制传输协议） UDP（用户数据报协议）\n\n\n应用层\n\n负责实现一切与应用程序相关的功能，对应OSI参考模型的上三层\nFTP（文件传输协议） HTTP（超文本传输协议） DNS（域名服务器协议）SMTP（简单邮件传输协议）NFS（网络文件系统协议）\n\n\n","categories":["计算机网络"],"tags":["HTTP","OSI","TCP","IP"]},{"title":"TCP三次握手和四次挥手","url":"/2022/10/20/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","content":"三次握手三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。\n主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。\n过程如下：\n\n第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态\n第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1作为ACK的值，此时服务器处于 SYN_RCVD 的状态\n第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接\n\n每一次握手的作用如下：\n\n第一次握手：客户端发送网络包，服务端收到了 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。\n第二次握手：服务端发包，客户端收到了 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常\n第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常\n\n通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了\n为什么不是两次握手?如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到\n并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源\n四次挥手tcp终止一个连接，需要经过四次挥手\n过程如下：\n\n第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认\n第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态\n第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态\n第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态\n\n四次挥手原因服务端在收到客户端断开连接Fin报文后，并不会立即关闭连接，而是先发送一个ACK包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送FIN报文断开连接，因此需要四次挥手\n","categories":["计算机网络"],"tags":["TCP"]},{"title":"http请求和状态码","url":"/2022/10/20/http%E8%AF%B7%E6%B1%82%E5%92%8C%E7%8A%B6%E6%80%81%E7%A0%81/","content":"HTTP 请求方法根据 HTTP 标准，HTTP 请求可以使用多种请求方法。\nHTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。\nHTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。\n\n\n\n序号\n方法\n描述\n\n\n\n1\nGET\n请求指定的页面信息，并返回实体主体。\n\n\n2\nHEAD\n类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。\n\n\n3\nPOST\n向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。\n\n\n4\nPUT\n从客户端向服务器传送的数据取代指定的文档的内容。\n\n\n5\nDELETE\n请求服务器删除指定的页面。\n\n\n6\nCONNECT\nHTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。\n\n\n7\nOPTIONS\n允许客户端查看服务器的性能。（预检请求）\n\n\n8\nTRACE\n回显服务器收到的请求，主要用于测试或诊断。\n\n\n9\nPATCH\n是对 PUT 方法的补充，用来对已知资源进行局部更新 。\n\n\n跨域资源共享 CORS同源策略同源策略(Same Origin Policy)是一种约定，它是浏览器最核心也是最基本的安全功能。同源策略会阻止一个域的javascrip脚本和另一个域的内容进行交互，是用于隔离潜在恶意文件的关键安全机制。\n当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域。\n如果不是浏览器发起请求，就不会受到同源策略的影响。\n同源策略目的就是为了保证用户信息的安全，防止恶意的网站窃取用户数据。如果网页之间不满足“同源”的要求，那么它们之间：\n\n不能共享Cookie、LocalStorage、SessionStorage、IndexDB\n不能获取DOM\nAJAX请求不能发送\n\n同源策略并不是浏览器不让请求发出去、或者后端拒绝返回数据。实际情况是请求正常发出去了，后端也正常相应了，只不过数据到了浏览器后浏览器不去作用加载而是丢弃了。\n不受同源策略影响的标签：\n\nimg\nscript\nstyle\nlink\niframe 引入资源可以允许不同域引入，但操作对应源里的dom是有跨域问题的\n\n跨域解决方法\n前端nginx反向代理\n后端设置CORS允许跨域（Access-Control-Allow-Origin）\njsonp：只适用于get请求\n\nCORS步骤一：客户端（浏览器）请求\n当浏览器发出跨域请求时，浏览器会添加一个带有当前源（方案、主机和端口）的 Origin 标头。\n步骤二：服务器响应\n在服务器端，当服务器看到此标头并希望允许访问时，它需要在响应中添加一个 Access-Control-Allow-Origin 标头，指定请求来源（或 * 以允许任何来源。）\n步骤三：浏览器收到响应\n当浏览器看到带有适当 Access-Control-Allow-Origin 标头的响应时，浏览器允许与客户端站点共享响应数据。\nCORS解决带cookie跨域问题出于隐私原因，CORS 通常用于“匿名请求”——请求未识别请求者的请求。如果您想在使用 CORS（可以识别发送者）时发送 cookie，您需要向请求和响应添加额外的标头。\n\n请求\n添加credentials: &#39;include&#39;到请求参数中即可实现带cookie进行跨域请求\nfetch(&#x27;https://example.com&#x27;, &#123;  mode: &#x27;cors&#x27;,  credentials: &#x27;include&#x27;&#125;)\n\n响应\nAccess-Control-Allow-Origin必须设置特定的值 (不能使用通配符*) 并且必须设置Access-Control-Allow-Credentials 为 true.\nHTTP/1.1 200 OKAccess-Control-Allow-Origin: https://example.comAccess-Control-Allow-Credentials: true\n\nCORS相关字段（1）Access-Control-Allow-Origin\n该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。\n（2）Access-Control-Allow-Credentials\n该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。\n（3）Access-Control-Expose-Headers\n该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。\n简单请求和非简单请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。\n只要同时满足以下两大条件，就属于简单请求。\n\n请求方法是以下三种方法之一：\nHEADGETPOST\n\nHTTP的头信息不超出以下几种字段：AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n\n\n预检请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。\n非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。\n浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。\n预检请求实际上是对服务端的一种权限请求\nOPTIONS /cors HTTP/1.1Origin: http://api.aaa.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.ccc.comConnection: keep-aliveUser-Agent: Mozilla/5.0...\n\n预检请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。\n除了Origin字段，”预检”请求的头信息包括两个特殊字段。\n（1）Access-Control-Request-Method\n该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。\n（2）Access-Control-Request-Headers\n该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。\n预检请求的回应服务器收到预检请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。\n\nHTTP&#x2F;1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache&#x2F;2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text&#x2F;html; charset&#x3D;utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout&#x3D;2, max&#x3D;100Connection: Keep-AliveContent-Type: text&#x2F;plain \n\n上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。\n如果浏览器否定了预检请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息：\nXMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.\n\n一旦服务器通过了预检请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。\n服务器回应的其他CORS相关字段如下：\n（1）Access-Control-Allow-Methods\n该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。\n（2）Access-Control-Allow-Headers\n如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。\n（3）Access-Control-Allow-Credentials\n该字段与简单请求时的含义相同。\n（4）Access-Control-Max-Age\n该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求\nHTTP状态码TTP状态码（英语：HTTP Status Code），用以表示网页服务器超文本传输协议响应状态的3位数字代码。\n它由 RFC 2616规范定义的，并得到 RFC 2518、RFC 2817、RFC 2295、RFC 2774与 RFC 4918等规范扩展。\n简单来讲，http状态码的作用是服务器告诉客户端当前请求响应的状态，通过状态码就能判断和分析服务器的运行状态。\n1xx代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。\n\n100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应\n101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级\n\n2xx代表请求已成功被服务器接收、理解、并接受。\n\n200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回\n201（已创建）：请求成功并且服务器创建了新的资源\n202（已创建）：服务器已经接收请求，但尚未处理\n203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源\n204（无内容）：服务器成功处理请求，但没有返回任何内容\n205（重置内容）：服务器成功处理请求，但没有返回任何内容\n206（部分内容）：服务器成功处理了部分请求\n\n3xx表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。\n\n300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择\n301（永久重定向）：永久重定向会缓存。请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置\n302（临时重定向）： 临时重定向不会缓存。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求\n303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码\n304（使用缓存）：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，没有内容部分\n305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理\n307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求\n\n4xx代表了客户端看起来可能发生了错误，妨碍了服务器的处理。\n\n400（错误请求）： 参数有误，请求无法被服务器识别\n401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。\n403（禁止）： 服务器拒绝请求\n404（未找到）： 服务器找不到请求的网页\n405（方法禁用）： 禁用请求中指定的方法\n406（不接受）： 无法使用请求的内容特性响应请求的网页\n407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理\n408（请求超时）： 服务器等候请求时发生超时\n\n5xx表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生。\n\n500（服务器内部错误）：服务器遇到错误，无法完成请求\n501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码\n502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应\n503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）\n504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求\n505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本\n\n","categories":["计算机网络"],"tags":["http","CORS"]},{"title":"HTTP和HTTPS","url":"/2022/10/20/HTTP%E5%92%8CHTTPS/","content":"HTTPHTTP (HyperText Transfer Protocol)，即超文本运输协议，是实现网络通信的一种规范。\nHTTP是一个传输协议，即将数据由A传到B或将B传输到A，并且 A 与 B 之间能够存放很多第三方，如： A&lt;&#x3D;&gt;X&lt;&#x3D;&gt;Y&lt;&#x3D;&gt;Z&lt;&#x3D;&gt;B。\n传输的数据并不是计算机底层中的二进制包，而是完整的、有意义的数据，如HTML 文件, 图片文件, 查询结果等超文本，能够被上层应用识别。\n在实际应用中，HTTP常被用于在Web浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密。\n特点如下：\n\n支持客户&#x2F;服务器模式\n简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快\n灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记\n无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间\n无状态：HTTP协议无法根据之前的状态进行本次的请求处理\n\nHTTP1.0中如果需要建立长连接，需要设置一个非标准的Connection字段 Connection: keep-alive；\n在HTTP1.1中，默认支持长连接（Connection: keep-alive），即在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，建立一次连接，多次请求均由这个连接完成。\n不同版本对比HTTP1.0\n浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接\n\nHTTP1.1\n引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用\n在同一个TCP连接里面，客户端可以同时发送多个请求\n虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着\n新增了一些请求方法\n新增了一些请求头和响应头\n\nHTTP2.0\n二进制分帧：采用二进制格式而非文本格式，解析起来更高效\n完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行（复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应）\n首部压缩：使用报头压缩，降低开销\n服务器推送，允许服务端推送资源给客户端\n\nHTTPSHTTP在通信过程中，存在以下问题：\n\n通信使用明文（不加密），内容可能被窃听\n不验证通信方的身份，因此有可能遭遇伪装\n\n而HTTPS的出现正是解决这些问题，HTTPS是建立在SSL之上，其安全性由SSL来保证\n在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能\n区别\nHTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL&#x2F;TLS协议进行了加密处理，相对更安全\nHTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443\nHTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP\nHTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高\n\nSSLSSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议\nHTTPS &#x3D; HTTP + TLS/SSL\nSSL的功能主要依赖于四种手段：\n\n对称加密：采用协商的密钥对数据加密\n非对称加密：实现身份认证和密钥协商\n摘要算法：验证信息的完整性\n数字签名：身份验证\n\n对称加密对称加密指的是加密和解密使用的秘钥都是同一个，是对称的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。\n非对称加密非对称加密，存在两个秘钥，一个叫公钥，一个叫私钥。两个秘钥是不同的，公钥可以公开给任何人使用，私钥则需要保密。\n公钥和私钥都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。\n混合加密在HTTPS通信过程中，采用的是对称加密+非对称加密，也就是混合加密。\n在对称加密中讲到，如果能够保证了密钥的安全，那整个通信过程就可以说具有了机密性。\n而HTTPS采用非对称加密解决秘钥交换的问题。\n具体做法是发送密文的一方使用对方的公钥进行加密处理“对称密钥”，然后对方用自己的私钥解密拿到“对称密钥”。\n这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。\n为什么使用混合加密融合了对称加密和非对称加密两者的优点：\n\n对称加密只使用一个密钥，运算速度快，但密钥必须保密，无法做到安全的密钥交换。\n非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，但速度慢，不适合直接加密信息。所以用来解决对称密钥的交换问题。\n\n但在网络传输过程中，数据有可能被篡改，并且黑客可以伪造身份发布公钥，如果你获取到假的公钥，那么混合加密也并无多大用处，你的数据扔被黑客解决。\n因此，在上述加密的基础上仍需加上完整性、身份验证的特性，来实现真正的安全，实现这一功能则是摘要算法和数字签名。\n摘要算法实现完整性的手段主要是摘要算法，也就是常说的散列函数、哈希函数。\n可以理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。\n摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性。\n比如，你发了条消息：“转账 1000 元”，然后再加上一个 SHA-2 的摘要。网站收到后也计算一下消息的摘要，把这两份“指纹”做个对比，如果一致，就说明消息是完整可信的，没有被修改。\n数字签名数字签名能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。\n原理其实很简单，就是用私钥加密，公钥解密。\n签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的。\n和消息本身一样，因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么判断这个公钥就是你的公钥。\n这时候就需要一个第三方，就是证书验证机构。\nCA验证机构数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场。\nCA 对公钥的签名认证要求包括序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”。\n流程如下：\n\n服务器的运营人员向数字证书认证机构提出公开密钥的申请\n数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名\n然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起\n服务器会将这份由数字证书认证机构颁发的数字证书发送给客户端，以进行非对称加密方式通信\n\n接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，则证明：\n\n认证服务器的公开密钥的是真实有效的数字证书认证机构\n服务器的公开密钥是值得信赖的\n\n总结可以看到，HTTPS与HTTP虽然只差一个SSL，但是通信安全得到了大大的保障，通信的四大特性都以解决，解决方式如下：\n\n机密性：混合算法\n完整性：摘要算法\n身份认证：数字签名\n不可否定：数字签名\n\n同时引入第三方证书机构，确保公开秘钥的安全性\n","categories":["计算机网络"],"tags":["http","SSL","https"]},{"title":"DNS域名解析","url":"/2022/10/21/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/","content":"DNSDNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器。\n简单来讲，DNS相当于一个翻译官，负责将域名翻译成ip地址。\n\nIP 地址：一长串能够唯一地标记网络上的计算机的数字\n域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识\n\n域名域名是一个具有层次的结构，从上到下一次为根域名、顶级域名、二级域名、三级域名…\n例如www.xxx.com，www为三级域名、xxx为二级域名、com为顶级域名，系统为用户做了兼容，域名末尾的根域名.一般不需要输入。\n在域名的每一层都会有一个域名服务器：\n\n根域名服务器\n顶级域名服务器：com域名服务器、cn域名服务器、edu域名服务器…\n权限域名服务器：abc.com域名服务器、y.abc.com域名服务器…\n本地域名服务器：任何一台主机在网络地址配置时，都会配置一个域名服务器作为默认域名服务器\n\n查询方式递归查询\n本地域名服务器向根域名服务器发起请求\n根域名服务器向顶级域名服务器发起请求\n顶级域名服务器向权限域名服务器发起请求\n权限域名服务器将 IP 地址逐级返回给本地域名服务器\n\n迭代查询\n首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器\n本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址\n本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址\n\n域名缓存在域名服务器解析的时候，使用缓存保存域名和IP地址的映射。\n计算机中DNS的记录也分成了两种缓存方式：\n\n浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗\n操作系统缓存：操作系统的缓存其实是用户自己配置的 hosts 文件\n\n查询过程解析域名的过程如下：\n\n首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表\n若没有命中，则继续搜索操作系统的 DNS 缓存\n若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果\n若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询\n本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来\n操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起\n至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起\n\n","categories":["计算机网络"],"tags":["DNS"]},{"title":"UDP和TCP","url":"/2022/10/21/UDP%E5%92%8CTCP/","content":"UDPUDP（User Datagram Protocol），用户数据包协议，是一个简单的面向数据报的通信协议，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层\n也就是说无论应用层交给UDP多长的报文，它统统发送，一次发送一个报文\n而对接收方，接到后直接去除首部，交给上面的应用层就完成任务\nUDP报头包括4个字段，每个字段占用2个字节（即16个二进制位），标题短，开销小\n特点如下：\n\nUDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务\n传输途中出现丢包，UDP 也不负责重发\n当包的到达顺序出现乱序时，UDP没有纠正的功能。\n并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为\n\nTCPTCP（Transmission Control Protocol），传输控制协议，是一种可靠、面向字节流的通信协议，把上面应用层交下来的数据看成无结构的字节流来发送\n可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着，TCP会根据当前网络的拥塞状态来确定每个报文段的大小\nTCP报文首部有20个字节，额外开销大\n特点如下：\n\nTCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。\n此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。\n根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）\n\n区别UDP与TCP两者的都位于传输层。\n两者区别如下表所示：\n\n\n\n\nTCP\nUDP\n\n\n\n可靠性\n可靠\n不可靠\n\n\n连接性\n面向连接\n无连接\n\n\n报文\n面向字节流\n面向报文\n\n\n效率\n传输效率低\n传输效率高\n\n\n双共性\n全双工\n一对一、一对多、多对一、多对多\n\n\n流量控制\n滑动窗口\n无\n\n\n拥塞控制\n慢开始、拥塞避免、快重传、快恢复\n无\n\n\n\nTCP 是面向连接的协议，建立连接3次握手、断开连接四次挥手，UDP是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取\nTCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方\nTCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用\nTCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信\n\n\n全双工通信：又称为双向同时通信，即通信的双方可以同时发送和接收信息的信息交互方式\n\n两者应用场景如下：\n\n\n\n应用层协议\n应用\n传输层协议\n\n\n\nSMTP\n电子邮件\nTCP\n\n\nLELNET\n远程终端接入\nTCP\n\n\nHTTP\n万维网\nTCP\n\n\nFTP\n文件传输\nTCP\n\n\nDNS\n域名转换\nUDP\n\n\nTFTP\n文件传输\nUDP\n\n\nSNMP\n网络管理\nUDP\n\n\nNFS\n远程文件服务器\nUDP\n\n\nTCP 应用场景适用于对效率要求低，对准确性要求高或者要求有链接的场景，而UDP 适用场景为对效率要求高，对准确性要求低的场景。\n","categories":["计算机网络"],"tags":["TCP","UDP"]},{"title":"js模块化","url":"/2022/10/21/js%E6%A8%A1%E5%9D%97%E5%8C%96/","content":"cjs (commonjs)commonjs 是 Node 中的模块规范，通过 require 及 exports 进行导入导出 (进一步延伸的话，module.exports 属于 commonjs2)\n同时，webpack 也对 cjs 模块进行解析，因此 cjs 模块可以运行在 node 环境及 webpack 环境下的，但不能在浏览器中直接使用。但如果你写前端项目在 webpack 中，也可以理解为它在浏览器和 Node 都支持。\n// sum.jsexports.sum = (x, y) =&gt; x + y;// index.jsconst &#123; sum &#125; = require(&quot;./sum.js&quot;);\n\n由于 cjs 为动态加载，可直接 require 一个变量\nrequire(`./$&#123;a&#125;`);\n\nesm (es module)esm 是 tc39 对于 ESMAScript 的模块话规范，正因是语言层规范，因此在 Node 及 浏览器中均会支持。\n它使用 import/export 进行模块导入导出.\n// sum.jsexport const sum = (x, y) =&gt; x + y;// index.jsimport &#123; sum &#125; from &quot;./sum&quot;;\n\nesm 为静态导入，正因如此，可在编译期进行 Tree Shaking，减少 js 体积。\n如果需要动态导入，tc39 为动态加载模块定义了 API: import(module) 。\nconst ms = await import(&quot;https://cdn.skypack.dev/ms@latest&quot;);ms.default(1000);\n\n目前，在浏览器与 node.js 中均原生支持 esm。\n动态 import标准用法的 import 导入的模块是静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。下面的是你可能会需要动态导入的场景：\n\n当静态导入的模块很明显的降低了代码的加载速度且被使用的可能性很低，或者并不需要马上使用它。\n当静态导入的模块很明显的占用了大量系统内存且被使用的可能性很低。\n当被导入的模块，在加载时并不存在，需要异步获取。\n当导入模块的说明符，需要动态构建。（静态导入只能使用静态说明符）\n当被导入的模块有副作用（这里说的副作用，可以理解为模块中会直接运行的代码），这些副作用只有在触发了某些条件才被需要时。（原则上来说，模块不能有副作用，但是很多时候，你无法控制你所依赖的模块的内容）\n\n请不要滥用动态导入（只有在必要情况下采用）。静态框架能更好的初始化依赖，而且更有利于静态分析工具和 Tree Shaking 发挥作用。\n与cjs比较\ncjs 模块输出的是一个值的拷贝，esm 输出的是值的引用\ncjs 模块是运行时加载，esm 是编译时加载\n\numd一种兼容 cjs 与 amd 的模块，既可以在 node&#x2F;webpack 环境中被 require 引用，也可以在浏览器中直接用 CDN 被 script.src 引入。\n(function (root, factory) &#123;  if (typeof define === &quot;function&quot; &amp;&amp; define.amd) &#123;    // AMD    define([&quot;jquery&quot;], factory);  &#125; else if (typeof exports === &quot;object&quot;) &#123;    // CommonJS    module.exports = factory(require(&quot;jquery&quot;));  &#125; else &#123;    // 全局变量    root.returnExports = factory(root.jQuery);  &#125;&#125;)(this, function ($) &#123;  // ...&#125;);\n","categories":["JavaScript"],"tags":["cjs","esm","umd"]},{"title":"vite特点","url":"/2022/10/21/vite%E7%89%B9%E7%82%B9/","content":"","categories":["前端工程化"],"tags":["vite"]},{"title":"正则","url":"/2022/10/21/%E6%AD%A3%E5%88%99/","content":""}]