[{"title":"ArrayBuffer","url":"/2022/04/09/ArrayBuffer/","content":"ArrayBuffer存储固定btye（字节）的二进制数据，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。\n使用：\nconst buf = new ArrayBuffer(32) //生成一段32字节的连续内存空间，每个字节的值默认都是 0。\n\nbtyeLength二进制数组的字节长度\nconst buffer = new ArrayBuffer(32)buffer.byteLength // 32\n\nslice截取\nconst buffer = new ArrayBuffer(32)const newBuffer = buffer.slice(2,6) //拷贝第2至5个字节\n\nisView表示参数是否为ArrayBuffer的视图实例。\nconst buffer = new ArrayBuffer(8);ArrayBuffer.isView(buffer) // falseconst v = new Int32Array(buffer);ArrayBuffer.isView(v) // true\n\nTypedArray视图TypedArray一共包括九种：\n\nInt8Array：8 位有符号整数，长度 1 个字节。\nUint8Array：8 位无符号整数，长度 1 个字节。\nUint8ClampedArray：8 位无符号整数，长度 1 个字节，溢出处理不同。\nInt16Array：16 位有符号整数，长度 2 个字节。\nUint16Array：16 位无符号整数，长度 2 个字节。\nInt32Array：32 位有符号整数，长度 4 个字节。\nUint32Array：32 位无符号整数，长度 4 个字节。\nFloat32Array：32 位浮点数，长度 4 个字节。\nFloat64Array：64 位浮点数，长度 8 个字节。\n\n以上九种构造函数统称为TypedArray视图，数组的大部分方法它们都能使用。（concat不能）\n特点：\n\n每个数组成员的类型相同\n每个数组成员的默认值为0\n\n使用：\nconst b = new ArrayBuffer(8);// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾const v1 = new Int32Array(b);// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾const v2 = new Uint8Array(b, 2);// 创建一个指向b的Int16视图，开始于字节2，长度为2const v3 = new Int16Array(b, 2, 2);\n\n参数1：ArrayBuffer对象，参数2：视图开始的字节数，必须为每个成员字节数的整数倍（可选），参数3：视图的长度（可选）\n上面三个视图指向同一个ArrayBuffer对象，只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。\nTypedArray视图还可以不接收ArrayBuffer生成：\n\n数字（长度）：const f64a = new Float64Array(8) //8个Float64  \n普通数组：const typedArray = new Uint8Array([1, 2, 3, 4])\n另一个TypedArray\n\nDataView视图使用：\nconst buffer = new ArrayBuffer(24);const dv = new DataView(buffer);\n\n参数1：ArrayBuffer对象，参数2：视图开始的字节数（可选），参数3：视图的长度（可选）\nDataView实例提供 8 个方法读取内存：（参数：开始的字节序号）\n\ngetInt8：读取 1 个字节，返回一个 8 位整数。\ngetUint8：读取 1 个字节，返回一个无符号的 8 位整数。\ngetInt16：读取 2 个字节，返回一个 16 位整数。\ngetUint16：读取 2 个字节，返回一个无符号的 16 位整数。\ngetInt32：读取 4 个字节，返回一个 32 位整数。\ngetUint32：读取 4 个字节，返回一个无符号的 32 位整数。\ngetFloat32：读取 4 个字节，返回一个 32 位浮点数。\ngetFloat64：读取 8 个字节，返回一个 64 位浮点数。\n\nDataView 视图提供 8 个方法写入内存：（参数1：开始的字节序号，参数2：写入的数据）\n\nsetInt8：写入 1 个字节的 8 位整数。\nsetUint8：写入 1 个字节的 8 位无符号整数。\nsetInt16：写入 2 个字节的 16 位整数。\nsetUint16：写入 2 个字节的 16 位无符号整数。\nsetInt32：写入 4 个字节的 32 位整数。\nsetUint32：写入 4 个字节的 32 位无符号整数。\nsetFloat32：写入 4 个字节的 32 位浮点数。\nsetFloat64：写入 8 个字节的 64 位浮点数。\n\nget和set方法还可接收最后一个参数：false：表示使用大端字节序（默认），true：表示使用小端字节序\n\n大端字节序：从多字节数据类型的第一个字节开始读取（或存储）\n小端字节序：从多字节数据类型的最后一个字节开始读取（或存储）\n\n参考文献\n","categories":["ES6"],"tags":["ES6","ArrayBuffer","TypedArray","DataView"]},{"title":"Echarts的容器宽高使用rem，渲染出的图表很小的问题","url":"/2022/03/06/Echarts%E7%9A%84%E5%AE%B9%E5%99%A8%E5%AE%BD%E9%AB%98%E4%BD%BF%E7%94%A8rem%EF%BC%8C%E6%B8%B2%E6%9F%93%E5%87%BA%E7%9A%84%E5%9B%BE%E8%A1%A8%E5%BE%88%E5%B0%8F%E7%9A%84%E9%97%AE%E9%A2%98/","content":"主要是因为div还没有创建出来echarts就已经加载了，因为获取不到宽高，所以会缩小在一起。参考了几篇文章，我在echarts配置后加入如下代码，解决了问题：\nmyChart.setOption(option); //延迟resize setTimeout(function ()&#123;\t myChart.resize() &#125;,200)//随屏幕大小改变 window.addEventListener(&#x27;resize&#x27;,function()&#123;\t myChart.resize() &#125;)\nCSDN:https://blog.csdn.net/cjhsyc/article/details/122584331参考文章：https://www.cnblogs.com/xxxx0130/p/14182677.htmlhttps://blog.csdn.net/weixin_40180205/article/details/106116073\n","categories":["数据可视化","Echarts"],"tags":["Echarts"]},{"title":"MongoDB","url":"/2022/04/10/MongoDB/","content":"安装（win系统）下载下载地址\n下载zip压缩包，并解压。\n创建服务在mongodb目录下创建两个目录data和logs，分别用于存放数据和日志（和bin目录同级）\n管理员身份运行cmd，进入mongodb下的bin目录。\ncmd下进行安装：（两个path后输入自己新建的两个目录的地址，logs目录后需要加上mongodb.log）\nmongod --install --dbpath D:\\MongoDB\\data --logpath D:\\MongoDB\\logs\\mongodb.log\n\n没有报错即为成功\n验证：键盘点击win+R，输入services.msc，能找到MongoDB即可\n启动服务cmd中：\nnet start mongodb #启动mongo #进入mongodbexit #退出\n\n\n\n基本使用MongoDB/bin下打开cmd：输入mongo开始使用\n\n查看数据库：show databases\n选择数据库：use test1（隐式创建：选择不存在的数据库不会报错，如果之后该数据库有数据时会自动创建）\n查看集合：show collections\n创建集合：db.createCollection(&#39;集合名&#39;)\n删除集合：db.集合名.drop()\n\n增删改查\n插入数据：db.集合名.insert(JSON数据)\nuse test2db.c1.insert(&#123;uname:&#x27;luo&#x27;,age:18&#125;) #注：集合不存在则隐式创建#注：MongoDB会给每条数据添加一个_id(全球唯一)\n\n一次性插入多条数据：插入数组即可\n多次插入数据：mongodb支持部分js语法，所以可以使用循环：\nfor(var i=0;i&lt;3;i++)&#123;    db.c1.insert(&#123;uname:&#x27;a&#x27;+i,age:i&#125;) &#125;\n\n查询数据：db.集合名.find()\ndb.c1.find() #查询所有数据#输出：&#123; &quot;_id&quot; : ObjectId(&quot;6252c272dbdf6baae7f71b64&quot;), &quot;uname&quot; : &quot;luo&quot;, &quot;age&quot; : 18 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;6252e60235f4e186f4e8dbfa&quot;), &quot;uname&quot; : &quot;a0&quot;, &quot;age&quot; : 0 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;6252e60235f4e186f4e8dbfb&quot;), &quot;uname&quot; : &quot;a1&quot;, &quot;age&quot; : 1 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;6252e60235f4e186f4e8dbfc&quot;), &quot;uname&quot; : &quot;a2&quot;, &quot;age&quot; : 2 &#125;#注：MongoDB会给每条数据添加一个_id(全球唯一)\n\n格式化输出数据：db.集合名.find().pretty()\n条件查询：db.集合名.find(条件)\ndb.c1.find(&#123;age:1&#125;) #age=1的数据db.c1.find(&#123;uname:&#x27;a0&#x27;,age:0&#125;) #多条件查询\n\n其他运算符：db.集合名.find(&#123;键:&#123;运算符:值&#125;)\n\n\n\n运算符\n作用\n\n\n\n$gt\n大于\n\n\n$gte\n大于等于\n\n\n$lt\n小于\n\n\n$lte\n小于等于\n\n\n$ne\n不等于\n\n\n$in\nin\n\n\n$nin\nnot in\n\n\ndb.c1.find(&#123;age:&#123;&amp;gt:1&#125;) #age&gt;1的数据db.c1.find(&#123;age:&#123;&amp;in:[0,2]) #age=0或2的值\n\n查询列：（传入第二个参数）\ndb.c1.find(&#123;&#125;,&#123;age:1&#125;) #只显示age列db.c1.find(&#123;&#125;,&#123;age:0&#125;) #显示除了age列的其他列#注：无论何时_id都会显示\n\n修改数据：db.集合名.update(条件,新数据)\ndb.c1.update(&#123;uname:&#x27;luo&#x27;&#125;,&#123;uname:&#x27;zhang&#x27;&#125;) #不只是修改uname，而是直接用新数据替换（所以修改后age没有了）#注：默认只修改符合条件的第一条数据\n\n其他运算符：\n\n\n\n修改器\n作用\n\n\n\n$inc\n递增\n\n\n$rename\n修改列名\n\n\n$set\n修改列值\n\n\n$unset\n删除列\n\n\ndb.c1.update(&#123;uname:&#x27;luo&#x27;&#125;,&#123;$set:&#123;uname:&#x27;zhang&#x27;&#125;&#125;) #只修改uname，所以age还在db.c1.update(&#123;uname:&#x27;luo&#x27;&#125;,&#123;$inc:&#123;age:3&#125;&#125;) #age增加3（负数为减）db.c1.update(&#123;uname:&#x27;luo&#x27;&#125;,&#123; #同时进行多种修改\t$set:&#123;uname:&#x27;zhang&#x27;&#125;,\t$inc:&#123;age:3&#125;&#125;)\n\n是否新增：第三个参数（true：未匹配到数据则新插入一条数据，false：默认值，不新增）\n是否修改多条：第四个参数（true：修改所有匹配的数据，false：默认值，修改匹配到的第一条数据）\n\n删除数据：db.集合名.remove(条件)\n是否只删除一条：第二个参数（true：只删除第一条数据，false：默认值，删除所有匹配的数据）\n\n\n排序和分页\n排序：db.集合名.find().sort(&#123;键：值&#125;)\ndb.c1.find().sort(&#123;age:0&#125;) #根据age进行排序，1表示升序，-1表示降序\n\n分页：db.集合名.find().skip(数字).limit(数字)\ndb.c1.find().limit(2) #查询两条数据，limit：限制查询的数量db.c1.find().skip(1) #skip：跳过指定的数量db.c1.find().skip(1).limit(2) #一起使用时，skip写在前面db.c1.find().count() #count:计数，显示结果的条数\n\n聚合查询db.集合名.aggregate([\t&#123;管道:&#123;表达式&#125;&#125;\t...])\n\n常用管道\n$group\t将集合中的文档分组，用于统计结果$match\t过滤数据，只要输出符合条件的文档$sort\t聚合数据进一步排序$skip\t跳过指定文档数$limit\t限制集合数据返回文档数\n\n常用表达式\n$sum\t总和$avg\t平均$min\t最小值$max\t最大值\n\n\n分组\ndb.c1.aggregate([\t&#123;\t\t$group:&#x27;$sex&#x27;,  # $group：分组，按sex进行分组，sex前需加上$符\t\tsum:&#123;$sum:&#x27;$age&#x27;&#125; # $sum：总和，同一组的age的总和，age前需加上$符，并将结果显示在sum列中\t&#125;])db.c1.aggregate([\t&#123;\t\t$group:null, # $group为null表示不分组\t\tsum:&#123;$sum:1&#125;, # $sum为1表示统计每组的数据条数\t\tavg:&#123;$avg:&#x27;$age&#x27;&#125; # $avg：平均值\t&#125;])\n\n多个管道\ndb.c1.aggregate([\t&#123;\t\t$group:&#x27;$sex&#x27;,\t\tsum:&#123;$sum:&#x27;$age&#x27;&#125;\t&#125;，\t&#123;\t\t$sort:&#123;sum:1&#125; #sort:排序，sum:1表示按照sum升序\t&#125;])\n\n索引索引是一个排序好的数据结构，可以提高数据查询的效率，但大量索引也会影响数据，因为每次插入和修改数据都需要更新索引\n\n创建索引：db.集合名.createIndex(待创建索引的列)\ndb.c1.createIndex(&#123;uname:1&#125;) #按照name字段升序创建索引db.c1.createIndex(&#123;uname:1,age:1&#125;) #复合索引\n\n自定义索引名：(第二个参数对象中，name:指定索引名)\ndb.c1.createIndex(&#123;uname:1&#125;,&#123;name:&#x27;unameIndex&#x27;&#125;)\n\n唯一索引：(第二个参数对象中，unique:是否唯一)\n#建立唯一索引后，所有数据的uname不能重复db.c1.createIndex(&#123;uname:1&#125;,&#123;unique:true&#125;)\n\n查看索引：db.集合名.getIndexes()\ndb.c1.getIndexes()#结果：[        &#123;                &quot;v&quot; : 2,                &quot;key&quot; : &#123;                        &quot;_id&quot; : 1                &#125;,                &quot;name&quot; : &quot;_id_&quot;        &#125;,        &#123;                &quot;v&quot; : 2,                &quot;key&quot; : &#123; #根据哪个key建立的索引                        &quot;uname&quot; : 1                &#125;,                &quot;name&quot; : &quot;uname_1&quot; #索引名        &#125;]\n\n删除索引：db.集合名.dropIndex(索引名)\n#先通过getIndexes()查看索引名db.c1.dropIndex(&#x27;uname_1&#x27;)db.c1.dropIndexes() #删除全部索引（除系统自带的）\n\n分析（explain）explain()帮助我们查看此次查询的相关数据（是否使用索引查询，查询速度）\n基本使用：\ndb.c1.find(&#123;age:1&#125;).explain()\n\n权限机制开启验证模式\n添加超级管理员（输入mongo进入MongoDB后use admin）\n#创建账号db.createUser(&#123;\t&quot;user&quot;:&quot;账号&quot;,\t&quot;pwd&quot;:&quot;密码&quot;,\t&quot;roles&quot;:[&#123;\t\trole:&quot;角色&quot;,\t\tdb:&quot;所属数据库&quot; #就是admin\t&#125;]&#125;)#比如：db.createUser(&#123;\tuser:&#x27;admin&#x27;,\tpwd:&#x27;123456&#x27;,\troles:[&#123;\t\trole:&#x27;root&#x27;,\t\tdb:&#x27;admin&#x27;\t&#125;]&#125;)\n\n卸载服务（管理员身份运行cmd）\n#在MongoDB/bin目录下执行mongod --remove\n\n安装需要身份验证的MongoDB服务（添加--auth）\nmongod --install --dbpath D:\\MongoDB\\data --logpath D:\\MongoDB\\logs\\mongodb2.log --auth注：.log文件名不能和之前安装时的重复#启动服务net start mongodb\n\n登录\n#进入MongoDBmongo#查看数据库，结果为空，因为没有身份验证show dbs\n\n通过超级管理员登录：\n\n方式一：mongo IP地址:端口/数据库 -u 用户名 -p 密码\n#默认端口：27017mongo 127.0.0.1:27017/admin -u admin -p 123456#即可查看数据库show dbs\n\n方式二：\n#先进入mongo#使用数据库use admin#登录(输出1：表示成功)db.auth(&#x27;admin&#x27;,&#x27;123456&#x27;)\n\n创建其他角色#角色种类超级用户角色:root数据库用户角色：read,readWrite数据库管理角色:dbAdmin,userAdmin集群管理角色:clusterAdmin、clusterManager、clusterMontitor、hostManager;备份恢复角色:backup、restore;所有数据库角色:readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase#角色说明root：只在admin数据库中可用。超级账号，超级权限read：允许用户读取指定数据库readWrite：允许用户读写指定数据库dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除、查看统计或访问system.profile\n\n例：创建角色test1可以读写test1数据库\nuse test1db.createUser(&#123;\tuser:&#x27;test1&#x27;,\tpwd:&#x27;test1&#x27;,\troles:[&#123;\t\trole:&#x27;readWrite&#x27;,\t\tdb:&#x27;test1&#x27;\t&#125;]&#125;)#注：创建的角色信息存在admin数据库下的system.usersuse admindb.system.users.find().pretty()\n\n退出，并登录为test1后，只能读写test1数据库\n\n\n备份还原安装MongoDB Database Tools下载地址\n选择zip进行下载，解压后将bin目录下的内容复制到MongoDB/bin下即可\nmongodump(备份)语法：\n# 导出数据mongodump -h -port -u -p -d -o# 说明# -h\thost \t服务器IP地址(一般不写 默认本机)# -port\t\t \t端口(一般不写 默认27017)# -u\tuser \t账号# -p \tpwd\t \t密码# -d\tdatabase数据库(注意：数据库不写则导出全局)# -o\topen\t备份到指定目录下\n\n备份所有数据：\n# MongoDB/bin下执行，需新建一个备份目录（bak）mongodump -u admin -p 123456 -o D:\\MongoDB\\bak\n\n备份指定数据：\nmongodump -u test1 -p test1 -d test1 -o D:\\MongoDB\\bak2# 注：超级管理员只能备份全部数据库，不能备份单个数据库\n\nmongoerstore（还原）语法：\nmongorestore -h -port -u -p -d --drop 备份数据目录#说明:# -d\t\t不写则还原全部数据库# --drop\t表示先删除数据库再导入\n\n还原所有数据库\nmongorestore -u admin -p 123456 --drop D:\\MongoDB\\bak\n\n还原指定数据库\nmongorestore -u test1 -p test1 -d test1 --drop D:\\MongoDB\\bak2\\test1\n\nmongoose是Node中提供的用来操作MongoDB的模块\nmongoose文档\n安装:\nyarn add mongoose或npm i mongoose\n\n使用：（js文件，node命令运行）\n//导入mongoose const mongoose = require(&#x27;mongoose&#x27;)//连接数据库(参数1：url，参数2：options，参数3：回调函数)const db = mongoose.connect(&#x27;mongodb://admin:123456@localhost/admin&#x27;, &#123;&#125;, error =&gt; &#123;  if (error) &#123;    console.log(&#x27;error:&#x27; + error)  &#125; else &#123;    console.log(&#x27;ok&#x27;)  &#125;&#125;)\n\nSchemaMongoose 的一切始于 Schema。每个 schema 都会映射到一个 MongoDB 集合，并定义这个集合里的文档的构成。\nconst Schema = mongoose.Schema;const mySchema = new Schema(&#123;  name: String,  age: Number,  date: &#123;type: Date, default: Date.now()&#125; //date字段的数据类型是Date，默认值为Date.now&#125;);\n\n允许使用的 SchemaTypes 有:\n\nString\nNumber\nDate\nBuffer\nBoolean\nMixed\nObjectId\nArray\n\nModelModel是从 Schema 编译来的构造函数。 它们的实例就代表着可以从数据库保存和读取的 documents（文档）。 从数据库创建和读取 document 的所有操作都是通过 model 进行的。\n//参数1：集合名（不是s结尾会自动加上s）const model = mongoose.model(&#x27;user&#x27;, mySchema)\n\n添加数据：\nconst insertObj = new model(&#123;  name: &#x27;罗小黑&#x27;,  age: 8&#125;)insertObj.save().then(res =&gt; &#123;  console.log(res)&#125;)\n\n查询数据：\n//查询一条model.findOne(&#123;age: 8&#125;).then(res =&gt; &#123;  console.log(res)&#125;)//查询所有model.find(&#123;age: 8&#125;).then(res =&gt; &#123;  console.log(res)&#125;)//跳过和分页model.find(&#123;age: 8&#125;).skip(1).limit(1).then(res =&gt; &#123;  console.log(res)&#125;)\n\n接口接口就是一个文件（js&#x2F;json&#x2F;php等），主要响应JSON数据或XML数据。\n推荐的JSON数据格式：\n&#123;\tmeta:&#123;\t\tstatus:状态码,\t\tmsg:&#x27;提示信息&#x27;\t&#125;,\tdata:数据&#125;\n\n接口开发规范（Restful API）Restful API：提供了接口设计规则和约束条件（一个规范），统一开发标准，便于团队协作。\n举例：\n列表页:访问-/模块名\t\t\t\t (get)详情页:访问-/模块名/编号\t\t\t(get)添加页:访问-/模块名/create\t\t (get)处理:访问-/模块名\t\t\t\t  (post)修改页:访问-/模块名/编号/edit\t\t(get)处理:访问-/模块名/编号\t\t\t (put)删除:访问-/模块名/编号\t\t\t(delete)HTTP动词: get、post、put、delete\n\n接口开发使用express框架：\nyarn add express\n\n新建http.js\nconst express = require(&#x27;express&#x27;)const app = express()app.listen(3000,()=&gt;&#123;  console.log(&#x27;http://localhost:3000&#x27;)&#125;)app.get(&#x27;/&#x27;,((req, res) =&gt; &#123;  res.send(&#x27;hello!&#x27;)&#125;))\n\n实战练习编写学生添加接口：\n新建models/stu.js:(操作数据库)\nconst mongoose = require(&#x27;mongoose&#x27;)mongoose.connect(&#x27;mongodb://test1:test1@localhost/test1&#x27;, &#123;&#125;, error =&gt; &#123;  if (error) &#123;    console.log(&#x27;数据库连接失败:&#x27; + error)  &#125; else &#123;    console.log(&#x27;数据库连接成功&#x27;)  &#125;&#125;)const Schema = mongoose.Schema;const mySchema = new Schema(&#123;  name: String,  age: Number,  sex: String&#125;);const model = mongoose.model(&#x27;stu&#x27;, mySchema)//添加学生const insert = (data) =&gt; &#123;  const obj = new model(data)  return obj.save().then(res =&gt; &#123;    console.log(&#x27;添加数据成功&#x27;)    return res  &#125;, err =&gt; &#123;    console.log(&#x27;添加数据失败：&#x27; + err)  &#125;)&#125;//获取学生列表const findStus = (skip,limit) =&gt; &#123;  return model.find().skip(skip).limit(limit).then(res =&gt; &#123;    console.log(&#x27;获取数据成功&#x27;)    return res  &#125;, err =&gt; &#123;    console.log(&#x27;获取数据失败：&#x27; + err)  &#125;)&#125;module.exports = &#123;  insert,findStus&#125;\n\n新建constroller/stu.js:(业务逻辑)\nconst path = require(&#x27;path&#x27;)const &#123;insert, findStus&#125; = require(path.resolve(__dirname, &#x27;../models/stu&#x27;))//添加学生const create = async (req, res) =&gt; &#123;  const data = req.body  const result = await insert(data)  if (result) &#123;    res.send(&#123;      meta: &#123;        status: 200,        msg: &#x27;ok&#x27;      &#125;,      data: result    &#125;)  &#125; else &#123;    res.send(&#123;      meta: &#123;        status: 500,        msg: &#x27;error&#x27;      &#125;    &#125;)  &#125;&#125;//获取学生列表const getStus = async (req, res) =&gt; &#123;  const &#123;pageno, pagesize&#125; = req.query //获取页数和每页显示的数量  const result = await findStus((pageno - 1) * pagesize, pagesize)  if (result) &#123;    res.send(&#123;      meta: &#123;        status: 200,        msg: &#x27;ok&#x27;      &#125;,      data: result    &#125;)  &#125; else &#123;    res.send(&#123;      meta: &#123;        status: 500,        msg: &#x27;error&#x27;      &#125;    &#125;)  &#125;&#125;module.exports = &#123;  create,  getStus&#125;\n\n安装body-parser：（在 Express 中没有内置获取表单 POST 请求体的 API , 我们需要添加第三方插件库）\nyarn add body-parser\n\nhttp.js:\nconst express = require(&#x27;express&#x27;)const path = require(&#x27;path&#x27;)const bodyParser = require(&#x27;body-parser&#x27;)const app = express()//配置 body-parser 中间件 (插件, 专门用来解析表单 POST 请求)// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded(&#123;extended: false&#125;))//parse application/jsonapp.use(bodyParser.json())app.listen(3000, () =&gt; &#123;  console.log(&#x27;http://localhost:3000&#x27;)&#125;)app.get(&#x27;/&#x27;, ((req, res) =&gt; &#123;  res.send(&#x27;hello!&#x27;)&#125;))//绝对路径const stu = require(path.resolve(__dirname, &#x27;controller/stu&#x27;))//添加学生app.post(&#x27;/stu&#x27;, stu.create)//获取学生列表app.get(&#x27;/stu&#x27;,stu.getStus)\n\n使用接口调试工具（postman等）进行测试\n接口文档（apiDoc）apiDoc文档\napiDoc是node的一个模块，能够根据注释快速生成接口文档。\n全局安装：\nnpm i apidoc -g\n\n项目根目录新建apidoc.json：\n&#123;  &quot;name&quot;: &quot;接口文档名&quot;,  &quot;version&quot;: &quot;0.1.0&quot;,  &quot;description&quot;: &quot;接口文档描述&quot;,  &quot;title&quot;: &quot;Custom apiDoc browser title&quot;,  &quot;url&quot; : &quot;http://loaclhost:3000&quot;&#125;\n\n编写注释：（在实现业务逻辑的函数前写注释）\n/** * @api &#123;get&#125; /user   学生列表 * @apiName GetUser * @apiGroup User * * @apiParam &#123;Number&#125; pageno     获取第几页 * @apiParam &#123;Number&#125; pagesize   每页显示条数 * * @apiSuccess &#123;Object&#125; meta 状态码&amp;提示 * @apiSuccess &#123;Array&#125; data  数据 */\n\n生成接口文档：apidoc -i 接口注释所在目录 -o 接口文档生成目录\napidoc -i ./controller -o ./apidoc# 根目录执行\n\n生成apidoc目录，该目录下的index.html即为接口文档\n参考视频\n","categories":["MongoDB","Node"],"tags":["MongoDB","mongoose","express","apiDoc"]},{"title":"HTTP缓存","url":"/2022/03/27/HTTP%E7%BC%93%E5%AD%98/","content":"强制缓存对于强制缓存而言，如果浏览器判断所请求的目标资源有效命中，则可直接从强制缓存中返回请求响应，无需与服务器进行任何通信。\nExpires服务器返回资源时在响应头中设置Expires字段，指定过期时间。在过期时间之前，浏览器再次访问该资源，则直接从强制缓存中获取。\nExpires:New Date(&#x27;2022-03-27 15:08:38&#x27;).toUTCString()\n\n缺点这个方式存在一个很大的漏洞，即对本地时间戳过分依赖，如果客户端本地的时间与服务器端的时间不同步，或者对客户端时间进行主动修改，那么对于缓存过期的判断可能就无法和预期相符。\ncache-controlCache-Control 作为响应头，用以控制缓存策略，这也是前端 HTTP 缓存策略的基础。\nmax-agecache-control设置max-age&#x3D;60属性值来控制响应资源的有效期，它是一个以秒为单位的时间长度，表示该资源在被请求到后的60秒内有效，如此便可避免服务器端和客户端时间戳不同步而造成的问题。\ncache-control:max-age=60//滑动时间，单位为秒\n\ncache-control还可以配置一些其他属性值，下面介绍。\nno-store和no-cacheno-store和no-cache是一组互斥属性\nno-store：表示禁止使用缓存\nno-cache：表示强制进行协商缓存\npublic和privatepublic和private是一组互斥属性\npublic：表示响应资源既可以被浏览器缓存，又可以被代理服务器缓存。\nprivate：响应资源只能被浏览器缓存，若未显式指定则默认值为private。\n对于应用程序中不会改变的文件，你通常可以在发送响应头前添加积极缓存（public）。这包括例如由应用程序提供的静态文件，例如图像，CSS 文件和JavaScript文件。\ns-maxages-maxage：表示代理服务器缓存的过期时间。\n协商缓存协商缓存就是在使用本地缓存之前，需要向服务器端发起一次GET请求，与之协商当前浏览器保存的本地缓存是否已经过期。\nlast-modified&#x2F;if-modified-since响应头中设置：\ncache-control:no-cache//进行协商缓存last-modified:xxx//资源最后一次修改的时间\n\n浏览器再次访问时请求头中会加上if-modified-since字段：\nif-modified-since:xxx//值为上次请求时响应头的last-modified的值\n\n服务器判断if-modified-since和此次的last-modified是否一致。如果一致则只需返回状态码304，表示从缓存中获取数据计可。如果不一致，就需要返回新的数据和last-modified。\n缺陷首先，它只是根据资源最后的修改时间戳进行判断的，虽然请求的文件资源进行了编辑，但内容并没有发生任何变化，时间戳也会更新，从而导致协商缓存时关于有效性的判断验证为失效，需要重新进行完整的资源请求。这无疑会造成网络带宽资源的浪费，以及延长用户获取到目标资源的时间。\n其次，标识文件资源修改的时间戳单位是秒，如果文件修改的速度非常快，假设在几百毫秒内完成，那么上述通过时间戳的方式来验证缓存的有效性，是无法识别出该次文件资源的更新的。\netag和if-none-match其内容主要是服务器为不同资源进行哈希运算所生成的一个字符串，只要文件内容编码存在差异，对应的 etag标签值就会不同，因此可以使用etag对文件资源进行更精准的变化感知。\n响应头中设置：\netag:xxx//根据资源进行哈希运算所生成的一个字符串\n\n浏览器再次访问时请求头中会加上if-none-match字段：\nif-none-match:xxx//值为上次请求时响应头的etag的值\n\n服务器判断if-none-match和此次的etag是否一致。如果一致则只需返回状态码304，表示从缓存中获取数据计可。如果不一致，就需要返回新的数据和etag。\n缺陷一方面，服务器对于生成文件资源的etag需要付出额外的计算开销，如果资源的尺寸较大，数量较多且修改比较频繁，那么生成etag的过程就会影响服务器的性能。\n另一方面，etag字段值的生成分为强验证和弱验证，强验证根据资源内容进行生成，能够保证每个字节都相同;弱验证则根据资源的部分属性值来生成，生成速度快但无法确保每个字节都相同，并且在服务器集群场景下，也会因为不够准确而降低协商缓存有效性验证的成功率，所以恰当的方式是根据具体的资源使用场景选择恰当的缓存校验方式。\ncache-control请求头Cache-Control 也可以作为请求头，以最常见的 no-cache 及 max-age=0 为例，二者均会重新向服务器发起请求，哪怕该请求已被强缓存。\n\nCache-Control: no-cache 作为请求头，表示即便在客户端拥有未过期的缓存，也要向服务器请求获得最新的资源。\nCache-Control: max-age=0 作为请求头，将会验证服务器资源的新鲜度，如果缓存未过期，则利用缓存，返回 304 状态码，否则重新获取资源返回 200 状态码。\n\n结论：\n\n只有服务端才能开启缓存，默认是不会走缓存的\n\n走了强缓存就不会再向服务端发送请求了\n\n客户端的请求头中只有设置了cache-control为：’no-store’ | ‘no-cache’ | ‘max-age&#x3D;0’才会生效（也就是客户端不想走强缓存的时候生效），除非后端对这个字段做特殊处理\n\n\n最佳实践关于 http 缓存配置的最佳实践为以下两条：\n\n文件路径中带有 hash 值：一年的强缓存。因为该文件的内容发生变化时，会生成一个带有新的 hash 值的 URL。前端将会发起一个新的 URL 的请求。配置响应头 Cache-Control: public,max-age=31536000,immutable\n文件路径中不带有 hash 值：协商缓存。大部分为 public 下文件。配置响应头 Cache-Control: no-cache 与 etag/last-modified\n\n但是当处理永久缓存时，切记不可打包为一个大的 bundle.js，此时一行业务代码的改变，将导致整个项目的永久缓存失效，此时需要按代码更新频率分为多个 chunk 进行打包，可细粒度控制缓存。\n参考视频\n","categories":["计算机网络"],"tags":["HTTP","cache-control"]},{"title":"axios","url":"/2022/04/08/axios/","content":"axios基本使用安装：\nnpm install axios\n\n发送请求：\naxios(&#123;          url:&#x27;xxx&#x27;,    // 设置请求的地址  method:&quot;GET&quot;, // 设置请求方法  params:&#123;      // get请求使用params进行参数凭借,如果是post请求用data    type: &#x27;&#x27;,    page: 1  &#125;&#125;).then(res =&gt; &#123;    // res为后端返回的数据  console.log(res);   &#125;)\n\n二次封装const requests = axios.create(&#123;    //配置对象    baseURL: process.env.VUE_APP_BASEURL,//基础路径，自动加在端口后    timeout: 5000,//超时的时间    headers:&#123;...&#125;//通用请求头&#125;)\n\n请求拦截器requests.interceptors.request.use(  config =&gt; &#123;    if (store.state.user.token) &#123;        config.headers.token = store.state.user.token    &#125;    return config  &#125;,  error =&gt; &#123;    return Promise.error(error)  &#125;)\n\n响应拦截器requests.interceptors.response.use((res) =&gt; &#123;    //成功的回调    return res.data//返回数据部分&#125;, (err) =&gt; &#123;    //失败的回调    return Promise.reject(new Error(&#x27;失败&#x27;))&#125;)\n\n取消请求方式一：\nconst CancelToken = axios.CancelToken;const source = CancelToken.source(); axios.post(url, &#123;    data&#125;, &#123;    cancelToken: source.token&#125;)// 取消请求 (请求原因是可选的)source.cancel(&#x27;主动取消请求&#x27;);\n\n方式二：\nconst CancelToken = axios.CancelToken;let cancel;axios.get(url, &#123;  cancelToken: new CancelToken(function executor(c) &#123;    cancel = c;  &#125;)&#125;);cancel(&#x27;主动取消请求&#x27;);\n\n简易原理class Axios &#123;    constructor() &#123;    &#125;    request(config) &#123;        return new Promise(resolve =&gt; &#123;            const &#123;url = &#x27;&#x27;, method = &#x27;get&#x27;, data = &#123;&#125;&#125; = config;            // 发送ajax请求            const xhr = new XMLHttpRequest();            //参数3：是否为异步请求，默认为true            xhr.open(method, url, true);            xhr.onload = function() &#123;                console.log(xhr.responseText)                resolve(xhr.responseText);            &#125;            xhr.send(data);        &#125;)    &#125;&#125;//生成axios实例function CreateAxiosFn() &#123;    let axios = new Axios();    let req = axios.request.bind(axios);    return req;&#125;// 得到最后的全局变量axioslet axios = CreateAxiosFn();\n","categories":["axios"],"tags":["axios","xhr","ajax"]},{"title":"Vue解决SEO","url":"/2022/03/27/Vue%E8%A7%A3%E5%86%B3SEO/","content":"SEO：搜索引擎优化seo需要的几个关键点：\n\n多页面\ntitle、描述、关键词\n网站的内容\n\nvue-cli无法实现以上三点：\n\nvue项目是SPA：单页面应用\nvue项目只有一套title、描述、关键词\nvue项目的内容是通过引入js文件加载的，无法通过源代码的HTML文件中直接读取\n\n预渲染在html页面生成之前数据就已经加载完成。预渲染的流程：\n\n读取配置，获取需要预渲染的页面\n\n发布机模拟浏览器环境打开页面\n\n页面脚本触发渲染时机\n\n渲染出当前的页面内容\n\n获取当前所有的DOM结构\n\n生成HTML文件\n\n\nprerender-spa-plugin提供一个预渲染解决方案。\n安装插件prerender-spa-plugin：\nnpm i prerender-spa-plugin\n\n在vue.config.js中进行配置：\nconst path = require(&#x27;path&#x27;)const PrerenderSPAPlugin = require(&#x27;prerender-spa-plugin&#x27;) module.exports = &#123;\tpublicPath:&#x27;./&#x27;,\tconfigureWebpack:&#123;    \tplugins: [\t        new PrerenderSPAPlugin(&#123;          \t\tstaticDir: path.join(__dirname, &#x27;dist&#x27;),          \t\t//将指定的路由分别预渲染为HTML页面(打包后生成多个HTML页面)         \t\troutes: [ &#x27;/&#x27;, &#x27;/about&#x27;, &#x27;/some/deep/nested/route&#x27; ],        \t&#125;)      \t]\t&#125; &#125;\n\nvue-meta-info修改title、描述、关键词。\nnpm i vue-meta-info\n\n在路由对应 的Vue文件中设置对应的meta-info：\n&lt;template&gt;    ...&lt;/template&gt; &lt;script&gt;  export default &#123;    metaInfo: &#123;      title: &#x27;My Example App&#x27;, // 设置title      meta: [&#123;                         name: &#x27;keyWords&#x27;,//关键字        content: &#x27;My Example App&#x27;//描述      &#125;]      /*link: [&#123;//设置link        rel: &#x27;asstes&#x27;,        href: &#x27;https://assets-cdn.github.com/&#x27;      &#125;]*/    &#125;  &#125;&lt;/script&gt; \n\n存在的问题prerender-spa-plugin无法配置动态路由，适合一个项目只需要其中几个页面需要做seo。\nvue-meta-info无法给title、描述和关键字设置动态数据。\n服务器渲染（SSR）在客户端和后端之间再添加一个服务器端（比如node.js）,后端将返回的数据交给服务器端，服务器端将html返回给客户端。\nNUXTNUXT中文官网\n一个基于 Vue.js 的服务端渲染应用框架\n安装:\nnpx create-nuxt-app &lt;项目名&gt;\n\n安装时需要进行一些选择\n目录结构pages：文件夹中放置路由组件。在该文件夹下的组件会在.nuxt文件夹下的router.js中自动配置路由。\ncomponents：文件夹中放置全局组件，使用其中的组件时无需import，可直接使用。因为配置文件nuxt.config.js配置文件中的components: true（改为false后需要手动引入组件）\nstore：store 目录用于组织应用的 Vuex 状态树 文件。 Nuxt.js 框架集成了 Vuex 状态树 的相关功能配置，在 store 目录下创建一个 index.js 文件可激活这些配置。\nNUXT生命周期服务端生命周期nuxtServerInit在store 目录下新建index.js。在vuex的actions模块中使用nuxtServerInit\nexport const state = () =&gt; &#123;&#125;export const mutations = &#123;&#125;export const actions = &#123;  //参数1：vuex上下文  //参数2：nuxt上下文  //只能在index.js中使用，其他的js文件会被当成子模块，子模块中使用nuxtServerInit无效  nuxtServerInit(store, context) &#123;    console.log(&#x27;nuxtServerInit&#x27;)  &#125;&#125;\n\nmiddleware（中间件）根目录下新建middleware目录，添加js文件（name.js）:\nexport default (&#123;store,route,req,res,redirect,query,params&#125;) =&gt; &#123;//可接收很多参数  console.log(&#x27;middleware&#x27;)    if(route.name=&#x27;home&#x27;)&#123;//前往home路由        redirect(&#x27;/login&#x27;)//重定向到login路由    &#125;&#125;\n\n全局middleware：nuxt.config.js中添加：\nrouter:&#123;  middleware:&#x27;name&#x27;,//对应middleware目录下的js文件名&#125;\n\n局部（组件内）middleware：\n&lt;template&gt;  &lt;Tutorial/&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;IndexPage&#x27;,  // middleware:&#x27;name&#x27;,  middleware()&#123;//不需要在middleware目录下写js文件    console.log(&#x27;局部middleware&#x27;)  &#125;&#125;&lt;/script&gt;\n\nvalidate用于校验路由参数\n在组件中使用：\n&lt;template&gt;  &lt;Tutorial/&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;IndexPage&#x27;,  validate(&#123;params,query&#125;)&#123;//接收路由的参数    console.log(&#x27;validate&#x27;)    return /^\\d+$/.test(query.id)//返回值为true时才能正常访问  &#125;&#125;&lt;/script&gt;\n\nasyncData只能在页面组件中使用，在组件每次加载之前调用，一般用来发送请求、获取数据。\nfetch可以在所有组件中使用\n服务端和客户端共有的生命周期beforeCreate&#x2F;created在NUXT服务器和客户端都执行\n客户端生命周期和vue中一致：\n\nbeforeMount&#x2F;mounted\n\nbeforeUpdate&#x2F;updated\n\nbeforeDestroy&#x2F;destroyed\n\n\nNUXT路由nuxt-link&lt;nuxt-link&gt; 的作用和&lt;router-link&gt;一致。为了提高 Nuxt.js 应用程序的响应能力，当链接将显示在视口中时，Nuxt.js 将自动预获取代码分割页面。\nnuxt中不使用路由懒加载。\n子路由在pages目录下新一个和父路由同名的文件夹，该文件夹下的.vue文件为子路由\n&lt;nuxt-child&gt;相当于&lt;router-view&gt;\n动态路由.vue文件以下划线（’_’）开头的为动态路由\n手动配置router.js使用@nuxtjs&#x2F;router\nnpm i @nuxtjs/router\n\nnuxt.config.js中配置：\nmodules:[\t&#x27;@nuxtjs/router&#x27;]\n\n在根目录下创建router.js文件，手动配置路由，与vue中不同的是向外暴露的不是router实例而是一个函数\nimport Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;Vue.use(Router)import MyPage from &#x27;~/components/my-page&#x27;const routes = [&#123;        path: &#x27;/&#x27;,        component: MyPage      &#125;]export function createRouter() &#123;  return new Router(&#123;    mode: &#x27;history&#x27;,    routes  &#125;)&#125;\n\n路由导航守卫在router.js中使用和vue-cli中一样 (全局守卫，路由独享守卫)\nnuxtjs自动生成路由时使用：\n\n中间件：middleware\n\n配置插件\n根目录新建plugins/router.js\nexport default (&#123;app&#125;) =&gt; &#123;  app.router.beforeEach((to,from,next)=&gt;&#123;    console.log(&#x27;beforeEach&#x27;)    next()  &#125;)&#125;\n\nnuxt.config.js中设置：\nplugins:[\t&#x27;@/plugins/router.js&#x27;]\n\n注意导航守卫在服务器端就已经执行，无法获取localStorage和cookie\n解决方法：安装cookie-universal-nuxt\nnpm i cookie-universal-nuxt\n\nnuxt.config.js中:\nmodules:[\t&#x27;cookie-universal-nuxt&#x27;,]\n\n即可正常使用，如：\n\nthis.$cookies.set\nthis.$cookies.get\n\n配置（nuxt.config.js）headhead用于配置title、描述、关键字：\nhead: &#123;  title: &#x27;app&#x27;,  htmlAttrs: &#123;    lang: &#x27;en&#x27;  &#125;,  meta: [    &#123; charset: &#x27;utf-8&#x27; &#125;,//网页编码    &#123; name: &#x27;viewport&#x27;, content: &#x27;width=device-width, initial-scale=1&#x27; &#125;,    &#123; hid: &#x27;description&#x27;, name: &#x27;description&#x27;, content: &#x27;&#x27; &#125;,    &#123; name: &#x27;format-detection&#x27;, content: &#x27;telephone=no&#x27; &#125;  ],  link: [    &#123; rel: &#x27;icon&#x27;, type: &#x27;image/x-icon&#x27;, href: &#x27;/favicon.ico&#x27; &#125;//网页图标  ]&#125;,\n\n如果当前页面的.vue文件没有单独配置head，则使用nuxt.config.js中的head\n在每个页面中单独配置：（使用函数的形式）\n&lt;template&gt;  &lt;div&gt;about&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;About&quot;,  head() &#123;    return &#123;      title: &#x27;about&#x27;,//可以设置为动态数据      meta: [        &#123;hid: &#x27;keywords&#x27;,name:&#x27;keywords&#x27;,content: &#x27;网站关键字&#x27;&#125;,        &#123;hid: &#x27;description&#x27;, name: &#x27;description&#x27;, content: &#x27;网站描述&#x27;&#125;,      ]    &#125;  &#125;&#125;&lt;/script&gt;\n\ncss配置全局的css文件：（比如：初始化css、UI组件库的css文件）\ncss: [  &#x27;@/static/reset.css&#x27;//static下准备样式初始化文件],\n\nplugins配置全局js文件：（比如：axios二次封装、UI组件库）\nplugins: [  &#x27;@/plugins/router.js&#x27;//plugins文件夹下准备全局js文件],\n\nmodulesmodules是Nuxt.js扩展\nnuxt中安装axios(方式一)：\nnpm i @nuxtjs/axios\n\nmodules中配置：\nmodeules:[\t&#x27;@nuxtjs/axios&#x27;]\n\n方式二：\nnpm i axios\n\n由于nuxt项目中没有main.js文件，使用时需要在.vue文件中单独import。\n这里使用方式一：\n在pages下 的页面组件中使用sayncData发送请求：\n&lt;template&gt;  &lt;div&gt;首页&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;IndexPage&#x27;,  data()&#123;    return&#123;      list:[]      &#125;  &#125;,  async asyncData(&#123;$axios&#125;)&#123;//接收一个参数是页面组件上下文    const res = await $axios.get(&#123;url:&#x27;http://xxxxxxxxxxxxx&#x27;&#125;)    return&#123;//asyncData中的this为undefined，需使用return返回数据，返回的数据会合并到组件的data中      list:res.data    &#125;  &#125;&#125;&lt;/script&gt;\n\n在components下的组件使用fetch发送请求获取数据：\n&lt;template&gt;  &lt;div&gt;news&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;News&quot;,  data() &#123;    return &#123;      list: []    &#125;  &#125;,  async fetch() &#123;//也接收一个参数是页面组件上下文，components下的组件接收不到      //fetch函数的this是组件实例，该函数不能直接将数据返回给页面组件，所有可以在components下的组件使用      //如果要在页面组件中使用需要将数据传到vuex中    const res = await this.$axios.get(&#123;url: &#x27;http://xxxxxxxxxxxxx&#x27;&#125;)    this.list = res.data  &#125;&#125;&lt;/script&gt;\n\n配置代理安装aixos和proxy：\nnpm i @nuxtjs/axiosnpm i @nuxtjs/proxy\n\n配置：\nmodules: [  &#x27;@nuxtjs/axios&#x27;,  &#x27;@nuxtjs/proxy&#x27;,],axios: &#123;  proxy: true,//是否可以跨域  baseUrl: &#x27;xxxxxxx&#x27;,  retry: &#123;retries: 3&#125;,//超时重试次数&#125;,proxy: &#123;//配置代理  &#x27;/api&#x27;: &#123;    target: &#x27;http://localhost:8080&#x27;,    pathRewrite: &#123;      &#x27;^/api&#x27;: &#x27;&#x27;    &#125;  &#125;&#125;,\n\naxios二次封装新建plugins/axios,js:\nexport default (&#123;$axios&#125;) =&gt; &#123;  $axios.defaults.timeout = 10000//超时时间  //请求拦截器  $axios.onRequest(config =&gt; &#123;    console.log(config)  &#125;)  //错误拦截器  $axios.onError((error =&gt; &#123;    console.log(error)  &#125;))  //响应拦截器  $axios.onResponse(response =&gt; &#123;    return response.data  &#125;)&#125;\n\n配置:\nplugins: [  &#x27;@/plugins/axios.js&#x27;,],\n\nloading (加载进度条)配置关闭loading：\nloading:false,//默认为true\n\n配置样式：\nloading:&#123;\tcolor:&#x27;blue&#x27;,\theight:&#x27;5px&#x27;&#125;\n\nVuex状态树新建store/index.js：\nexport const state = () =&gt; &#123;//state使用函数，避免返回引用&#125;export const mutations = &#123;&#125;export const actions = &#123;&#125;export const getters = &#123;&#125;\n\n模块：\n新建js文件，模块名就是文件名\nnuxt项目上线\n打包\nnpm run build\n\n将.nuxt、static、nuxt.config.js、package.json四个文件放到服务器中，服务器下载node环境。\n\n服务器安装依赖并启动（依旧是localhost:3000）\nnpm installnpm run start\n\nnginx代理\n\n\n参考视频\n","categories":["vue"],"tags":["Vue","SEO","Nuxt","SSR"]},{"title":"git多人协作流程","url":"/2022/05/03/git%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B/","content":"Fork在github上找到需要参与开发的项目，fork到自己的github仓库中\ngit clone初始化\ngit clone &lt;url&gt; #克隆远程仓库git init #初始化本地版本库\n\n克隆fork来的仓库\ngit remotegit remote -v #显示所有远程仓库git remote show &lt;remote&gt; #查看指定远程仓库git remote add &lt;remote&gt; &lt;url&gt; #添加远程仓库\n\n添加对应的github远程仓库\ngit remote add upstream &lt;url&gt; #添加目标项目的主仓库git remote add origin &lt;url&gt; #添加fork来的的仓库\n\ngit branchgit branch #查看本地所有分支git branch -r #查看远程所有分支git branch -a #查看本地和远程所有分支git branch &lt;新分支名&gt; #基于当前分支，新建一个分支git checkout -b &lt;新分支名&gt; #基于当前分支新建分支，并切换为这个分支git checkout &lt;分支名&gt; #切换到本地某个分支git checkout --orphan &lt;新分支名&gt; #新建一个空分支（会保留之前分支的所有文件）git branch -d &lt;分支名&gt; #删除本地某个分支git branch &lt;新分支名称&gt; &lt;提交ID&gt; #从提交历史恢复某个删掉的某个分支git branch -m &lt;原分支名&gt; &lt;新分支名&gt; #分支更名\n\n新建一个分支\ngit checkout -b new\n\n在该分支上进行开发\ngit add&#x2F;git commit&#x2F;git pushgit add .  #提交全部文件修改到缓存区git add &lt;具体某个文件路径+全名&gt;  #提交某些文件到缓存区git diff  #查看当前代码 add后，会 add 哪些内容git diff --staged  #查看现在 commit 提交后，会提交哪些内容git status  #查看当前分支状态git commit -m &quot;&lt;注释&gt;&quot;  #提交代码到本地仓库，并写提交注释git commit -v  #提交时显示所有diff信息git commit --amend [file1] [file2]  #重做上一次commit，并包括指定文件的新变化git push [remote] [branch] #上传本地指定分支到远程仓库git push [remote] --force #强行推送当前分支到远程仓库，即使有冲突git push [remote] --all #推送所有分支到远程仓库\n\ngit add添加新增文件，git commit提交修改到本地仓库，git push提交到自己的远程仓库\ngit add test.txtgit commit -m &quot;commit test&quot;git push origin new\n\npull requestgithub中使用pull request将修改的内容请求合并到主仓库中\ngit pullgit pull [remote] [branch] #拉取远程仓库的分支与本地当前分支合并git merge &lt;分支名&gt; #合并指定分支到当前分支git merge --abort #合并分支出现冲突时，取消合并，一切回到合并前的状态\n\n在提交到主仓库之前，先拉取主仓库最新的代码\ngit pull upstream main\n\ngit rmgit rm -r --cached . #移除所有文件git rm --cached &lt;文件路径&gt; #移除指定文件git rm --f &lt;文件路径&gt; #移除指定文件并删除该文件（不会放入回收站）\n\n将已经提交过的文件加入git忽略文件：\ngit rm -r --cached . #移除所有文件#将目标文件加入.gitignoregit add . #重新add所有文件\n\n","categories":["git"],"tags":["git","github"]},{"title":"js垃圾回收","url":"/2022/04/06/js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","content":"js垃圾回收机制\n找出不在使用的变量\n释放器内存空间\n固定的时间间隔执行\n\n标记清除当变量进入执行环境是，就标记这个变量为“进入环境“，进入环境的变量所占用的内存就不能释放。当变量离开环境时，则将其标记为“离开环境“。\n被标记为“离开环境”的变量等待垃圾回收。\n全局变量和闭包所形成的特殊的变量不会被标记为“离开环境”：\nfunction f1()&#123;    let a=1    return function f2()&#123;        a++        console.log(a)    &#125;&#125;const f3 = f1()f3() //2f3() //3\n\n在上述代码中，函数执行完之后变量a并没有消失，因为不会被标记清除，也就是不会被垃圾回收。\n解决：\nf3 = null\n\n引用计数根据一个值的引用次数来判断是否进行垃圾回收，如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。\nconst a = new Object() //a的引用数:1const b = new Object() //b的引用数:1let c = a //a的引用数:2let c = b //a的引用数:1,b的引用数:2a.prop = bb.prop = a //a的引用数:2,b的引用数:2\n\n如上所示，a和b的引用数永远都大于0，不会被垃圾回收。所以使用引用计数来进行垃圾回收的浏览器较少。\n解决：(解除引用)\na = nullb = null\n\nV8引擎垃圾回收V8是一个由Google开源的采用C++编写的高性能JavaScript和WebAssembly引擎，应用在 Chrome和Node.js等。\n在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象(大部分对象)，老生代中存放的生存时间久的对象（比如Vue）。\n新生代的内存空间小（16&#x2F;32M），老生代的内存空间大（0.7&#x2F;1.4G）\n新生代的对象被使用很多次之后会被转移到老生代中，老生代使用的垃圾回收机制就是标记清除。\n新生代的垃圾回收机制是Scavenge，Scavenge又是基于cheney算法的：\ncheney算法将内存分为from和to两个区域（各一半），正在使用的对象都存在from中，假如有一个对象被赋值为null（等待垃圾回收）\n\n将需要被回收的对象留在from中，其他数据转移到to中\n将from和to中的所有数据互换\n将to中的数据回收\n\ncheney算法用空间换取时间（有一半内存不能用）\n参考视频\n","categories":["JavaScript"],"tags":["垃圾回收","JavaScript","V8引擎"]},{"title":"js严格模式","url":"/2022/03/09/js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","content":"严格模式使用严格模式&quot;use strict&quot;\n\n变量a = 10console.log(a)//严格模式报错（必须使用var等声明变量）\n\n静默失败 &#x3D;&gt; 报错var b = 2console.log(Object.getOwnPropertyDescriptor(window, &#x27;b&#x27;))/*configurable: false //var声明的变量默认不可删除enumerable: truevalue: 2writable: true*/delete b//未删除，非严格模式下不报错，程序继续进行（静默失败）//严格模式下报错console.log(b)//2\n\n函数参数唯一function test(a,a)&#123;  console.log(a)//undefined(第二个a),严格模式报错&#125;test(10)\n\n实参和形参的映射关系不存在function test1(a) &#123;  a = 20  console.log(arguments[0])//非严格模式:20,严格模式:10&#125;test1(10)function test2(a = 20) &#123;//参数设置初始后自动开启严格模式  a = 30  console.log(arguments[0])//10&#125;test2(10)\n\n函数的this默认指向undefinedfunction test()&#123;  console.log(this)//undefined&#125;test()\n\n不能使用arguments.callee和callerfunction test()&#123;  console.log(arguments.callee === test)//true,严格模式无法使用  console.log(test.caller === out)//true,严格模式无法使用&#125;function out()&#123;  test()&#125;out()\n\n不能使用eval()和with()eval(&#x27;var a=2&#x27;)console.log(a)//2,严格模式无法使用const obj=&#123;  a:3&#125;function test()&#123;  with (obj) &#123;//改变this指向    console.log(a)//3,严格模式无法使用  &#125;&#125;test()\n\neval和arguments不能作为标识符let eval=&#x27;111&#x27;//严格模式报错\n\n\n\n\n\n\n\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"nginx","url":"/2022/03/30/nginx/","content":"前言已准备好如下软件：\n\nVMware\nXshell和Xftp\n\n安装CentOS7.4下载CentOS7.4下载地址\n选择CentOS-7-x86_64-Minimal-1708.iso进行下载\n使用VMware运行虚拟机\n联网修改网卡配置文件：\nvi /etc/sysconfig/network-scripts/ifcfg-ens33\n将ONBOOT=no改为ONBOOT=yes\n保存退出后，执行：（重启网卡）\nsystemctl restart network\n使用ping命令测试可以联网\n重启网卡失败有可能是VMware软件的问题，可卸载重装\n设置静态ip使用Xshell连接虚拟机（Xshell终端的操作更方便）：\n使用ip addr查看ens33的IP地址\n打开Xshell新建连接：\n\n名称随意、主机填写IP地址\n填写用户名（root）和密码、完成连接\n\n修改配置文件：\nvi /etc/sysconfig/network-scripts/ifcfg-ens33\n将BOOTPROTO=dhcp改为BOOTPROTO=static\n添加如下配置ip地址、子网掩码、网关、DNS：（每人的ip地址不同）\nIPADDR=192.168.181.128NETMASK=255.255.255.0GATEWAY=192.168.181.2DNS1=8.8.8.8\n\n查看网关是否正确：\n\nVMware左上角点击编辑\n虚拟网络编辑器\n更改设置\n选择VMnet8\n点击NET设置即可查看网关\n\n重启网卡：systemctl restart network\nping命令测试联网成功（ping 8.8.8.8）\nNginx安装和启动在安装之前可将虚拟机克隆一份：\n\n虚拟机关机\n右键-管理-克隆\n\nnginx官网\n下载地址： nginx-1.21.6\n点击nginx-1.21.6进行下载、完成后通过Xftp将压缩包传到虚拟机上\n也可以直接在虚拟机里使用wget下载\n可参考文章\n安装所需环境：\n\n安装gcc：yum install -y gcc\n\n安装PCRE pcre-devel：yum install -y pcre pcre-devel\n\n安装zlib：yum install -y zlib zlib-devel\n\n\n解压安装nginx：\n\n解压：tar zxvf nginx-1.21.6.tar.gz \n进入 ：cd nginx-1.21.6\n配置并指定安装目录：./configure --prefix=/usr/local/nginx\n编译、安装：make；make install\n\n启动nginx：\n\n进入安装目录：cd /usr/local/nginx/sbin/\n启动：./nginx\n验证：浏览器访问虚拟机的ip地址（需关闭防火墙）\n\n防火墙：\n\n关闭：systemctl stop firewalld.service\n禁止防火墙开机启动：systemctl disable firewalld.service\n\nnginx服务脚本：\n\n创建脚本文件：vi /usr/lib/systemd/system/nginx.service\n\n文件内容：\n[Unit]Description=nginx - web serverAfter=network.target remote-fs.target nss-lookup.target[Service]Type=forkingPIDFile=/usr/local/nginx/logs/nginx.pidExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.confExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.confExecReload=/usr/local/nginx/sbin/nginx -s reloadExecStop=/usr/local/nginx/sbin/nginx -s stopExecQuit=/usr/local/nginx/sbin/nginx -s quitPrivateTmp=true[Install]WantedBy=multi-user.target\n\n保存退出\n\n重新加载系统服务：systemctl daemon-reload\n\n关闭nginx：./nginx -s stop\n\n启动服务：systemctl start nginx.service\n\n查看：systemctl status nginx.service，出现active (running)表示成功\n\n开机启动： systemctl enable nginx.service\n\n重启：reboot，等待一会后浏览器可访问虚拟机ip地址表示脚本成功执行\n\n\nnginx基本使用在修改配置之前克隆一份虚拟机\n目录结构可使用Xftp查看&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;\n\nconf：配置文件\nhtml：静态页面\nlogs：日志\nsbin：nginx的主程序\n\n“_temp”结尾的文件夹是nginx运行时才生成的\n基本运行原理nginx启动后有一个主进程（Master）和多个子进程（Worker）\nMaster校验配置文件，协调子进程\nWorker处理和响应请求\n配置文件（nginx.conf）进入&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;\n使用Xftp时，右键文件可以通过记事本进行编辑\n编辑nginx.conf：（如下是开头的两行）\n#user  nobody;#该符号表示注释worker_processes  1;\n\n先不看带注释的配置：（最小配置文件）\nworker_processes  1; #子进程个数events &#123;    worker_connections  1024; #单个子进程可接受的连接数&#125;http &#123;    include       mime.types; #include：引入其他配置文件；mime.types：指定各种文件后缀的资源类型    default_type  application/octet-stream; #默认类型        sendfile        on; #使用linux的 sendfile(socket, file, len) 高效网络传输，也就是数据0拷贝。        keepalive_timeout  65;        server &#123; #虚拟主机，可以有多个（vhost）        listen       80; #监听的端口号        server_name  localhost; #域名或主机名（可以写多个，用空格隔开）        location / &#123; #uri            root   html; #根目录（html相当于/usr/local/nginx/html/）            index  index.html index.htm; #默认页        &#125;        error_page   500 502 503 504  /50x.html; #服务器错误时的页面        location = /50x.html &#123;            root   html;        &#125;    &#125;&#125;\n\n虚拟主机配置多个server：\nserver &#123;     listen       80;     server_name  www.my.com; #(需在阿里云购买域名)    location / &#123;        root   /www/www; #在虚拟机上创建对应的目录和目录下的资源        index  index.html index.htm;     &#125;    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   html;    &#125;&#125;server &#123;     listen       80;     server_name  *.my.com; # *号表示通配符（匹配所有的三级域名），域名解析时先匹配前面的server，再匹配第二个    location / &#123;        root   /www/video;        index  index.html index.htm;     &#125;    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   html;    &#125;&#125;\n\n修改配置后重新加载nginx：ststemctl reload nginx\nserver_name:还可以使用正则表达式进行匹配\n可以修改本机的hosts文件进行server_name的测试：C:\\Windows\\System32\\drivers\\etc\\hosts（需管理员权限）\n在最后添加：192.168.181.128 x.com,前者为虚拟机ip地址，后者为自定义域名\n修改后可以在本机通过域名访问虚拟机ip地址\n反向代理反向代理服务器（比如nginx）位于用户和目标服务器（比如Tomcat）之间，用户无法直接访问Tomcat，而由nginx接收请求，然后转发给Tomcat，返回数据给nginx后，再返回给用户。\nproxy_pass配置反向代理：\nserver &#123;    listen       80;    server_name  localhost;    location / &#123; #在这里配置proxy_pass，且不需要root和index    \tproxy_pass  http://www.qq.com; #指定服务器        #root   html;        #index  index.html index.htm;    &#125;    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   html;    &#125;&#125;\n\n重新加载nginx：systemctl reload nginx\n浏览器再次访问虚拟机ip会重定向到腾讯网（外网服务器）(301：重定向，地址栏改变)\n测试代理内网服务器：\n\n克隆一份虚拟机（刚安装配置好nginx的状态）\n\n修改配置文件：vi /etc/sysconfig/network-scripts/ifcfg-ens33\n\n修改IPADDR=192.168.181.128为IPADDR=192.168.181.129\n\n重启网卡：systemctl restart network\n\nXshell连接192.168.181.129\n\n修改&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;index.html\n\nXshell连接192.168.181.128\n\n修改配置：proxy_pass http://192.168.181.129 ; #指定服务器\n\n重新加载nginx：systemctl reload nginx\n\n浏览器访问192.168.181.128，显示192.168.181.129上的index.html（地址栏不变）\n\n\n负载均衡反向代理多个服务器，当nginx接收到请求时，通过轮询的方式将请求转发给服务器（轮流）\n作用：通过负载均衡，将多个请求分摊到多台服务器上，相当于把一台服务器需要承担的负载量交给多台服务器处理，进而提高系统的吞吐率；另外如果其中某一台服务器挂掉，其他服务器还可以正常提供服务，以此来提高系统的可伸缩性与可靠性。\n按照之前的流程再克隆一个虚拟机，ip设置为192.168.181.130并修改index.html\nXshell连接192.168.181.128，进行配置：\nupstream httpds&#123; #upstream:对应多组服务器，httpds：自定名称\tserver 192.168.181.129;\tserver 192.168.181.130;&#125;server &#123;    listen       80;    server_name  localhost;    location / &#123;    \tproxy_pass  http://httpds; #httpds:对应upstream的名称    &#125;    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   html;    &#125;&#125;\n\nupstream和server同级\n重新加载nginx：systemctl reload nginx\n浏览器多次访问192.168.181.128，轮流显示两个服务器中index.html的内容\n负载均衡策略\n权重 weight\nupstream httpds&#123;\tserver 192.168.181.129 weight=8; #添加weight：值越大，访问该服务器的概率越大\tserver 192.168.181.130 weight=2;&#125;\n\n下线 down\nupstream httpds&#123;\tserver 192.168.181.129 weight=8 down; #down：该服务器不会被访问（出现故障时下线该服务器）\tserver 192.168.181.130 weight=2;&#125;\n\n备用 backup\nupstream httpds&#123;\tserver 192.168.181.129 weight=8 down;\tserver 192.168.181.130 weight=2 backup; #backup：备用机，只有其他服务器都不可用时才会被使用&#125;\n\n都需要手动配置文件然后reload nginx\n动静分离将静态资源（比如图片、css、js）放在nginx上\n作用：将静态页面与动态页面或者静态内容接口和动态内容接口分开不同系统访问的架构设计方法，进而提升整个服务访问性能和可维护性。\n在nginx配置中的server下配置多个location即可（也可使用正则）：\nlocation / &#123;\tproxy_pass  192.168.181.129;&#125;# ~号表示开始正则匹配，*号表示不区分大小写location ~*/(img|css|js) &#123; #匹配根目录下的三种文件夹（img|css|js），优先级比location /高\troot html; #根目录：/usr/local/nginx/html/\tindex index.html index.htm;&#125;\n\nURLRewrite重写url，可以隐藏真实的url\nlocation / &#123;\trewrite  ^/([0-9]+).html$  /index.html?pageNum=$1  break;\tproxy_pass  192.168.181.129;&#125;\n\nrewrite  &lt;正则&gt;  &lt;真实uri&gt;  &lt;标识&gt;;\n^:正则开始，$:正则结束\n将匹配到的正则替换为真实uri（$1:表示正则表达式的第一个括号里匹配到的内容）\n四种标识:\n\nlast #本条规则匹配完成后，继续向下匹配新的location URI规则 \nbreak #本条规则匹配完成即终止，不再匹配后面的任何规则 \nredirect #返回302临时重定向，浏览器地址会显示跳转后的URL地址 \npermanent #返回301永久重定向，浏览器地址栏会显示跳转后的URL地址\n\ntry_files按顺序检查文件是否存在，返回第一个找到的文件或文件夹，如果所有的文件或文件夹都找不到，会进行一个内部重定向到最后一个参数。\nlocation / &#123;  root data;  index index.html index.htm;  try_files $uri $uri/ /index.html;&#125;\n\n查找逻辑：\n\n首先：检查 data 目录中是否存在 api 文件，如果存在，则返回文件；如果不存在，则进行下一步。\n其次：检查 data 目录中是否存在 api/ 目录，如果存在，则在检查 api/ 目录中是否存在 index.html 或者 index.htm 文件（由 index 指定）；如果存在，则返回该文件。如果不存在，则进行下一步。\n最后：检查 data 目录中是否存在 index.html 文件。如果存在，则返回文件；如果不存在，则返回 404。\n\n参考视频\n","categories":["部署"],"tags":["nginx","CentOS"]},{"title":"less预处理语言","url":"/2022/03/08/less%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%AD%E8%A8%80/","content":"变量声明和使用//定义变量@color: red;@var: a;@attr: color;@&#123;var&#125; &#123; //作为选择器或者属性名需要添加大括号    @&#123;attr&#125;: @color; //作为属性值直接使用&#125;@btn: &#123;    width: 100px;    height: 40px;    background-color: aqua;&#125;.btn &#123;    @btn(); //需要括号&#125;    @url: &#x27;https://cdn.jsdelivr.net/gh/cjhsyc/image-hosting@master/头像.677yiujw5980.webp&#x27;;.img&#123;    background-image: url(&quot;@&#123;url&#125;&quot;); //作为url使用    background-size: 100px;    width: 100px;    height: 100px;&#125;\n\n运算可以使用+、-、*、&#x2F;进行运算\n@a: 100px + 20px; //120px@b: @a*2; //240px@c: #666/2; //#333\n\n嵌套.parent&#123;    width: 100px;    height: 100px;    border: 1px solid gray;    .child&#123;        background-color: skyblue;        @media (min-width: 900px)&#123;            background-color: pink;        &#125;        @media (min-width: 500px) and (max-width: 900px)&#123;            background-color: greenyellow;        &#125;    &#125;&#125;\n\n相当于\n.parent &#123;  width: 100px;  height: 100px;  border: 1px solid gray;&#125;.parent .child &#123;  background-color: skyblue;&#125;@media (min-width: 900px) &#123;    .parent .child &#123;        background-color: pink;    &#125;&#125;@media (min-width: 500px) and (max-width: 900px) &#123;    .parent .child &#123;        background-color: greenyellow;    &#125;&#125;\n\n混合.mixins &#123;    border: 2px solid skyblue;    width: 300px;    height: 30px;&#125;.box &#123;    .mixins(); //括号可加可不加&#125;\n\n函数使用函数自定义一个绘制三角形的函数\n.triangle(top,@color:black,@height:50px) &#123;    border-color: transparent transparent @color transparent;&#125;.triangle(left,@color:black,@height:50px) &#123;    border-color: transparent @color transparent transparent;&#125;.triangle(bottom,@color:black,@height:50px) &#123;    border-color: @color transparent transparent transparent;&#125;.triangle(right,@color:black,@height:50px) &#123;    border-color: transparent transparent transparent @color;&#125;.triangle(@dir,@color:black,@height:50px) &#123;//@dir用来匹配第一个参数，后面的参数都要一致    width: 0;    height: 0;    border-width: @height;    border-style: solid;&#125;.triangleBox &#123;    .triangle(top,red);//绘制尖朝上的三角形,后两个参数不写则使用默认值&#125;\n\n命名空间和逻辑判断#card&#123;    //when:进行逻辑判断    //not:取反,and:且,或运算使用逗号    .border(@width,@color,@style) when not(@width &gt; 30px) , (@color &gt;= #666) and (@style = solid)&#123;        border: @width @style @color;    &#125;&#125;#main &#123;    //调用其他作用域的函数（ &#x27;&gt;&#x27; 可以省略 ）    #card &gt; .border(40px, #666, solid); //符合条件才生效    //#card.border(40px, #666, solid);//效果同上&#125;\n\n不定参数.boxShadow(@a,@b,...)&#123;//不定参数    box-shadow: @arguments;//@arguments:所有的参数,包括@a,@b    width: 200px;&#125;#box1&#123;    .boxShadow(0,0,10px,gray);&#125;#box2&#123;    .boxShadow(inset,0,0,5px,gray);&#125;\n\n循环//循环（递归调用函数）.columns(@n,@i:1) when (@i &lt;= @n) &#123;    .column-@&#123;i&#125; &#123;        width: @i*100% / @n;        height: 20px;        background-color: pink;    &#125;    .columns(@n, @i+1)&#125;.columns(4);\n\n属性合并.bg&#123;    width: 200px;    height: 200px;    //+ :属性用逗号隔开    //+_ :属性用空格隔开    background+: #666666;    background+_: url(&quot;@&#123;url&#125;&quot;);    background+_: no-repeat;    background+_: center;    box-shadow+: 0 0 5px greenyellow;    box-shadow+: 0 0 10px #000;    background-size: 100px;&#125;\n\n相当于\n.bg &#123;  width: 200px;  height: 200px;  background: #666666 url(&quot;@&#123;url&#125;&quot;) no-repeat center;  box-shadow: 0 0 5px greenyellow,0 0 10px #000;  background-size: 100px;&#125;\n\n继承.linkBtn &#123;    display: block;    width: 200px;    height: 80px;&#125;.linkBtn &#123;    color: white;    background-color: skyblue;&#125;.link:extend(.linkBtn) &#123;    text-decoration: none;    border: 4px solid orange;&#125;\n\n使用混合也可以实现相同的效果，但混合是相当于把代码再复制一份，而继承不是，上述代码转CSS如下：\n.linkBtn,.link &#123;  display: block;  width: 200px;  height: 80px;&#125;.linkBtn,.link &#123;  color: white;  background-color: skyblue;&#125;.link &#123;  text-decoration: none;  border: 4px solid orange;&#125;\n\n导入导入其他less文件\n@import &quot;./assets/style.less&quot;@import (reference) &quot;./assets/style.less&quot;//添加reference后，未被调用的代码不加载\n\n\n\n参考视频\n","categories":["样式","less"],"tags":["less"]},{"title":"nvm管理nodejs版本","url":"/2022/07/23/nvm%E7%AE%A1%E7%90%86nodejs%E7%89%88%E6%9C%AC/","content":"nvm安装地址：nvm-windows\n选择nvm-setup.exe下载安装，安装时设置nvm安装目录（D:\\nvm）和nodejs的链接目录（D:\\nodejs）。\n需要将D:\\nodejs添加到环境变量\nnvm镜像源配置淘宝镜像源（cmd运行）\nnvm node_mirror https://npmmirror.com/mirrors/node/nvm npm_mirror https://npmmirror.com/mirrors/npm/\n\nnvm管理nodejs需管理员身份运行cmd\n\n查看当前所有nodejs版本\nnvm ls\n\n安装指定版本nodejs（只指定大版本时默认安装该大版本的最新版）\nnvm install 16nvm install 16.16.0\n\n使用指定版本的nodejs（需指定完整的版本号）\nnvm use 16.16.0\n\n查看当前node和npm的版本\nnode -vnpm -v\n\n切换npm全局安装位置（需将D:/nodejs/npm_global添加至环境变量）\nnpm config set prefix &quot;D:/nodejs/npm_global&quot;npm config set cache &quot;D:/nodeks/npm_cache&quot;\n\nnrm\n全局安装nrm，管理npm镜像\nnpm i -g nrm\n\n使用淘宝镜像\nnrm lsnrm use taobao\n\n","categories":["nodejs"],"tags":["node","nodejs","nvm","npm","nrm"]},{"title":"vscode","url":"/2022/06/18/vscode/","content":"VS Code安装官网：Visual Studio Code\nvscode又两种版本（user版和system版），默认下载user版。（其他下载中可选择版本，具体区别不明）\n安装时勾选上两个通过Code打开（可以右键文件或文件夹在vscode中打开）\n推荐扩展\nChinese (Simplified)  &#x2F;&#x2F;适用于 VS Code 的中文（简体）语言包\nCode Spell Checker  &#x2F;&#x2F;拼写检查\nESLint  &#x2F;&#x2F;ESLint支持\ngit-commit-plugin  &#x2F;&#x2F;Git Commit模板\nGitLens — Git supercharged  &#x2F;&#x2F;Git历史记录\nGoogle Translate  &#x2F;&#x2F;划词翻译\nIntelliCode  &#x2F;&#x2F;代码提示\nLive Server  &#x2F;&#x2F;实时加载的本地服务器\nmarkdownlint  &#x2F;&#x2F;markdown格式化\nMaterial Icon Theme  &#x2F;&#x2F;图标主题\nopen in browser  &#x2F;&#x2F;右键在浏览器中打开\nPrettier - Code formatter  &#x2F;&#x2F;Prettier格式化\nTabnine AI Autocomplete  &#x2F;&#x2F;代码快速生成\nVue Language Features (Volar)  &#x2F;&#x2F;Vue支持\n\n修改扩展安装位置默认安装位置：C:\\Users\\&#123;用户名&#125;\\.vscode\\extensions\n将extensions文件夹剪切至其他盘（比如：D:\\Microsoft VS Code\\extensions）\n管理员身份运行cmd\nmklink /D &quot;C:\\Users\\&#123;用户名&#125;\\.vscode\\extensions&quot; &quot;D:\\Microsoft VS Code\\extensions&quot;\n\n","categories":["vscode"],"tags":["vscode","extension"]},{"title":"springboot","url":"/2022/05/03/springboot/","content":"创建项目idea创建Spring Initializr项目，自定项目名称，软件包名称改为com.example，java版本为8。\n连不上start.spring.io，可以使用start.aliyun.com。（使用阿里云的服务器创建的springboot版本较低，可自行在pom.xml中修改）\n依赖项选择Web下的Spring Web。\n基本使用src/main/java下新建com.example.controller包，新建java类：BookController：\npackage com.example.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(&quot;/books&quot;)public class BookController &#123;    @GetMapping(&quot;/&#123;id&#125;&quot;)    public String getById(@PathVariable Integer id)&#123;        return &quot;running...&quot;+id;    &#125;&#125;\n\n@RestController：@Controller + @ResponseBody\n@ResponseBody： 可以返回实体对象（返回json数据）\n@PathVariable：使用路径参数\n启动服务执行com.example下的Application即可，springboot内嵌服务器（默认tomcat），端口：8080\n基本配置springboot的配置写在resources下的application.properties：\n# 设置服务器端口server.port = 80\n\n除了properties格式还可以使用yml或yaml文件。\n新建application.yml：\nserver:  port: 80\n\n新建appalication.yaml：\nserver:  port: 80\n\n优先级：properties &gt; yml &gt; yaml\nyaml格式yml和yaml文件都是yaml格式，这是一种数据序列化格式，以数据为中心，重数据轻格式。\n读取yaml数据：\n@Value(&quot;$&#123;server.port&#125;&quot;)private Integer port;\n\n变量引用：\nlastname: wufullname: $&#123;lastname&#125;xian\n\n如果属性值中出现转译字符，需要用双引号包裹：\nlesson: &quot;spring\\nboot&quot;# \\n : 换行\n\n读取所有数据：\n//自动装配到Environment对象@Autowired private Environment env;//使用env.getProperty(&quot;server.port&quot;)\n\n读取数据到类中：\n定义类：（Server）\npackage com.example;import org.springframework.stereotype.Component;//定义为spring管控的类@Component//指定加载的数据@ConfigurationProperties(&quot;server&quot;)public class Server &#123;    //属性名与yml中对应    private Integer port;        // Alt+Ins 自动生成    public Integer getPort() &#123;        return port;    &#125;    public void setPort(Integer port) &#123;        this.port = port;    &#125;    @Override    public String toString() &#123;        return &quot;Server&#123;&quot; +                &quot;port=&quot; + port +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n使用：\n@Autowiredprivate Server server;\n\n整合Mybatis新建项目，依赖项选择sql下的MyBatis Framework 和 MySQL Driver\n使用：\napplication.yml:\nspring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/books    username: root    password: &quot;123456&quot;\n\ncom.example.doamin:Book类\npackage com.example.domain;public class Book &#123;    private Integer id;    private String name;    private String type;    @Override    public String toString() &#123;        return &quot;Book&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, type=&#x27;&quot; + type + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getType() &#123;        return type;    &#125;    public void setType(String type) &#123;        this.type = type;    &#125;&#125;\n\ncom.example.dao:BookDao接口\npackage com.example.dao;import com.example.domain.Book;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select;@Mapperpublic interface BookDao &#123;    @Select(&quot;select * from book where id = #&#123;id&#125;&quot;)    public Book getById(Integer id);&#125;\n\n进行测试：\ntest/java/com.example/Boot2MybatisApplicationTests:\npackage com.example;import com.example.dao.BookDao;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass Boot2MybatisApplicationTests &#123;    @Autowired    private BookDao bookDao;    @Test    void contextLoads() &#123;        System.out.println(bookDao.getById(1));    &#125;&#125;\n\n整合Mybatis-Plus使用start.spring.io创建项目，没有提供依赖项MyBatis Plus Framework。（start.aliyun.com有提供）\n可自行上网(https://mvnrepository.com/artifact/org.apache.maven)搜索MyBatis Plus的Maven配置写法。\n使用：（其他写法与Mybatis相同，修改BookDao即可）\ncom.example.dao:BookDao接口\npackage com.example.dao;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.example.domain.Book;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface BookDao extends BaseMapper&lt;Book&gt; &#123;     //通过泛型传入实体类，比如Book对应数据库中的表book（名称不对应运行报错）&#125;\n\n配置表名称前缀：\napplication.yml添加：\nmybatis-plus:  global-config:    db-config:      table-prefix: tb- # 此时对应表名称tb-book\n\n测试：\npackage com.example;import com.example.dao.BookDao;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass Boot3MybatisPlusApplicationTests &#123;    @Autowired    private BookDao bookDao;    @Test    void contextLoads() &#123;        System.out.println(bookDao.selectById(2));    &#125;&#125;\n\n整合Druid创建项目（使用mybatis和mysql）\nmvn网站搜索Druid（选择Druid Spring Boot Starter）\n自行选择一个版本，复制其maven配置（添加到dependencies下）\n在application.yml配置：\nspring:  datasource:    druid:      driver-class-name: com.mysql.cj.jdbc.Driver      url: jdbc:mysql://localhost:3306/books      username: root      password: &quot;123456&quot;\n\nidea快捷键Alt + 7 ：显示类结构\nCtrl + h ：显示类层次结构\nAlt + Ins ：快速生成方法\nAlt + Enter : 自动生成对象实例接收返回值\ndemo创建一个demo项目，使用用spring web、mybatis plus、mysql driver。\n使用druid数据源，pom.xml加入：\n&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;  &lt;version&gt;1.2.9&lt;/version&gt;&lt;/dependency&gt;\n\napplication.yml：\nspring:  datasource:    druid:      driver-class-name: com.mysql.cj.jdbc.Driver      url: jdbc:mysql://localhost:3306/books      username: root      password: &quot;123456&quot;server:  port: 80mybatis-plus:  global-config:    db-config:      id-type: auto # 向数据库添加数据时id自动递增  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 开启mybatis-plus运行日志\n\n创建表（book）结构如下：\n\n\n\nid\nname\ntype\ndescription\n\n\n\n1\nspringboot\n计算机\nSpring Boot 是 Pivotal 团队在 Spring 的基础上提供的一套全新的开源框架。\n\n\n使用Lombok简化实体类开发是一个java类库，提供了一组注解，简化POJO实体类开发\npom.xml加入：\n&lt;dependency&gt;  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;  &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;\n\n使用：\npackage com.example.domain;import lombok.Data;//自动生成getter、setter、toString、hashCode等方法@Datapublic class Book &#123;    private Integer id;    private String name;    private String type;    private String description;&#125;\n\n数据层开发com.example.Dao/BookDao：\npackage com.example.Dao;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.example.domain.Book;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface BookDao extends BaseMapper&lt;Book&gt; &#123;&#125;\n\n分页查询定义配置类：com.example.config/MPConfig:\npackage com.example.config;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;//定义为配置类@Configurationpublic class MPConfig &#123;    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor()&#123; //mybatisPlus的拦截器        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); //提供分页功能的拦截器        return interceptor;    &#125;&#125;\n\n测试：\n@Testvoid getPage() &#123;    IPage&lt;Book&gt; page = new Page&lt;&gt;(1, 5);    bookDao.selectPage(page, null);    System.out.println(page.getTotal()); //数据总数    System.out.println(page.getCurrent()); //当前页    System.out.println(page.getPages()); //总页数    System.out.println(page.getSize()); //每页条数    System.out.println(page.getRecords()); //查询结果&#125;\n\n条件查询//两种写法@Testvoid getBy() &#123;    QueryWrapper&lt;Book&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.like(&quot;name&quot;, &quot;安全&quot;); //查询name属性中含有“安全”的结果    bookDao.selectList(queryWrapper);&#125;@Testvoid getBy2() &#123;    LambdaQueryWrapper&lt;Book&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    queryWrapper.like(Book::getName, &quot;安全&quot;); //同上    bookDao.selectList(queryWrapper);&#125;@Testvoid getBy3() &#123;    String name = null;    LambdaQueryWrapper&lt;Book&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //在前面多传一个boolean参数（如果为false则不进行条件查询，而是输出表中所有结果）    queryWrapper.like(name != null,Book::getName, name);     bookDao.selectList(queryWrapper);&#125;\n\n业务层开发com.example.service/BookService：\npackage com.example.service;import com.example.domain.Book;import java.util.List;public interface BookService &#123;    Boolean save(Book book);    Boolean update(Book book);    Boolean delete(Book book);    Book getById(Integer id);    List&lt;Book&gt; getAll();&#125;\n\ncom.example.service.impl/BookServiceImpl:\npackage com.example.service.impl;import com.example.Dao.BookDao;import com.example.domain.Book;import com.example.service.BookService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class BookServiceImpl implements BookService &#123;    @Autowired    private BookDao bookDao;    @Override    public Boolean save(Book book) &#123;        return bookDao.insert(book) &gt; 0;    &#125;    @Override    public Boolean update(Book book) &#123;        return bookDao.updateById(book) &gt; 0;    &#125;    @Override    public Boolean delete(Book book) &#123;        return bookDao.deleteById(book) &gt; 0;    &#125;    @Override    public Book getById(Integer id) &#123;        return bookDao.selectById(id);    &#125;    @Override    public List&lt;Book&gt; getAll() &#123;        return bookDao.selectList(null);    &#125;&#125;\n\n测试：\n@Autowiredprivate BookService bookService;@Testvoid getById()&#123;    System.out.println(bookService.getById(1));&#125;\n\n快速开发（基于Mybatis-Plus）自动生成基本的业务代码（增删改查）\ncom.example.service/IBookService：\npackage com.example.service;import com.baomidou.mybatisplus.extension.service.IService;import com.example.domain.Book;public interface IBookService extends IService&lt;Book&gt; &#123;&#125;\n\ncom.example.service.impl/IBookServiceImpl:\npackage com.example.service.impl;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.example.Dao.BookDao;import com.example.domain.Book;import com.example.service.IBookService;import org.springframework.stereotype.Service;@Servicepublic class IBookServiceImpl extends ServiceImpl&lt;BookDao, Book&gt; implements IBookService &#123;&#125;\n\n测试：\n@Autowiredprivate IBookService iBookService;@Testvoid getAll() &#123;    System.out.println(iBookService.list());&#125;\n\n表现层开发com.example.controller/BookController:\npackage com.example.controller;import com.example.domain.Book;import com.example.service.IBookService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;@RestController@RequestMapping(&quot;books&quot;)public class BookController &#123;    @Autowired    private IBookService iBookService;    @GetMapping    public List&lt;Book&gt; getAll() &#123;        return iBookService.list();    &#125;    @GetMapping(&quot;&#123;id&#125;&quot;)    public Book getById(@PathVariable Integer id) &#123;        return niBookService.getById(id);    &#125;        @PostMapping    public Boolean save(@RequestBody Book book) &#123;        return iBookService.save(book);    &#125;    @PutMapping    public Boolean update(@RequestBody Book book) &#123;        return iBookService.updateById(book);    &#125;    @DeleteMapping(&quot;&#123;id&#125;&quot;)    public Boolean delete(@PathVariable Integer id) &#123;        Book book = new Book();        book.setId(id);        return iBookService.removeById(book);    &#125;&#125;\n\n使用接口测试工具进行测试\n消息一致性处理统一前后端交互的数据格式。\n返回结果封装成一个R对象\ncom.example.controller.utils/R:\npackage com.example.controller.utils;import lombok.Data;@Datapublic class R &#123;    private Boolean flag;    private Object data;    public R() &#123;    &#125;    public R(Boolean flag) &#123;        this.flag = flag;    &#125;    public R(Boolean flag, Object data) &#123;        this.flag = flag;        this.data = data;    &#125;&#125;\n\ncom.example.controller/BookController:\npackage com.example.controller;import com.example.controller.utils.R;import com.example.domain.Book;import com.example.service.IBookService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;@RestController@RequestMapping(&quot;books&quot;)public class BookController &#123;    @Autowired    private IBookService iBookService;    @GetMapping    public R getAll() &#123;        return new R(true, iBookService.list());    &#125;    @GetMapping(&quot;&#123;id&#125;&quot;)    public R getById(@PathVariable Integer id) &#123;        return new R(true, iBookService.getById(id));    &#125;    @PostMapping    public R save(@RequestBody Book book) &#123;        return new R(iBookService.save(book));    &#125;    @PutMapping    public R update(@RequestBody Book book) &#123;        return new R(iBookService.updateById(book));    &#125;    @DeleteMapping(&quot;&#123;id&#125;&quot;)    public R delete(@PathVariable Integer id) &#123;        return new R(iBookService.removeById(id));    &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n\n参考视频\n","categories":["springboot"],"tags":["springboot","java","mybatis","druid"]},{"title":"vue3使用tsx","url":"/2022/04/29/vue3%E4%BD%BF%E7%94%A8tsx/","content":"技术栈vue3+ts+vite\n安装@vitejs&#x2F;plugin-vue-jsxnpm i @vitejs/plugin-vue-jsx -D\n\n使用vite.config.ts中导入：\nimport &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import vueJsx from &#x27;@vitejs/plugin-vue-jsx&#x27;;export default defineConfig(&#123;  plugins: [vue(),vueJsx()]&#125;)\n\n修改tsconfig.json:（添加jsxFactory和jsxFragmentFactory）\n&#123;  &quot;compilerOptions&quot;: &#123;    &quot;jsx&quot;: &quot;preserve&quot;,    &quot;jsxFactory&quot;: &quot;h&quot;,    &quot;jsxFragmentFactory&quot;: &quot;Fragment&quot;,  &#125;,&#125;\n\ntsxsrc目录内新建tsx文件：（如：App.tsx）\nconst renderDom = () =&gt; &#123;  return (      &lt;div&gt;        hello,tsx!      &lt;/div&gt;  )&#125;export default renderDom\n\n在.vue文件中导入并使用：\n&lt;template&gt;  &lt;renderDom&gt;&lt;/renderDom&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import renderDom from &quot;./App.tsx&quot;; //导入后当成组件使用即可&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n\n展示数据变量写在单个花括号内，展示ref对象的值需要加上.value\nimport &#123;ref, Ref&#125; from &quot;vue&quot;;const text: Ref&lt;string&gt; = ref(&#x27;&#x27;)const renderDom = () =&gt; &#123;  return (      &lt;div&gt;        &lt;input type=&quot;text&quot; v-model=&#123;text.value&#125;/&gt;        &lt;span&gt;&#123;text.value&#125;&lt;/span&gt;      &lt;/div&gt;  )&#125;export default renderDom\n\nv-show和v-iftsx支持v-show，不支持v-if\n要想实现v-if的效果，需使用编程的方法\nlet flag = falseconst renderDom = () =&gt; &#123;  return (      &lt;div&gt;        &#123; flag ? &lt;div&gt;罗小黑&lt;/div&gt; : &lt;div&gt;罗小白&lt;/div&gt;&#125;      &lt;/div&gt;  )&#125;export default renderDom\n\nv-for使用Array.map()\nconst arr = [1,2,3,4]const renderDom = () =&gt; &#123;  return (      &lt;div&gt;        &#123; arr.map(item =&gt; &#123;          return &lt;div&gt;$&#123;item&#125;&lt;/div&gt;        &#125;) &#125;      &lt;/div&gt;  )&#125;export default renderDom\n\nv-bind和v-ontsx不支持v-bind和v-on\n绑定数据直接使用即可\n绑定事件使用onXXX（如onClick）即可，函数传参使用bind，不能使用事件修饰符（需自己使用js实现）\nconst arr = [1, 2, 3, 4]const clickEvent = (item: number) =&gt; &#123;  console.log(`点击了第$&#123;item&#125;个`)&#125;const renderDom = () =&gt; &#123;  return (      &lt;div&gt;        &#123;arr.map(item =&gt; &#123;          return &lt;div data-num=&#123;item&#125; onClick=&#123;clickEvent.bind(this, item)&#125;&gt;$&#123;item&#125;&lt;/div&gt;        &#125;)&#125;      &lt;/div&gt;  )&#125;export default renderDom\n\n接收props参数和emit&lt;template&gt;\t&lt;renderDom title=&quot;这是标题&quot; @getNum=&quot;getNum&quot;&gt;&lt;/renderDom&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import renderDom from &quot;./App.tsx&quot;; //导入后当成组件使用即可    const getNum = (num: number) =&gt; &#123;  console.log(num)&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n\ninterface Props &#123;  title: string&#125;const clickEvent = (ctx: any) =&gt; &#123;  ctx.emit(&#x27;getNum&#x27;, 20)&#125;const renderDom = (props: Props, ctx: any) =&gt; &#123;  return (      &lt;div&gt;        &lt;div&gt;&#123;props.title&#125;&lt;/div&gt;        &lt;button onClick=&#123;clickEvent.bind(this,ctx)&#125;&gt;按钮&lt;/button&gt;      &lt;/div&gt;  )&#125;export default renderDom\n\n\n\n参考视频\n","categories":["vue3"],"tags":["vue3","tsx","vite","jsx"]},{"title":"webpack配置","url":"/2022/03/07/webpack%E9%85%8D%E7%BD%AE/","content":"webpack.config.js入口和出口文件const path = require(&#x27;path&#x27;)//引入path模块module.exports = &#123;    entry: &#x27;./src/index.js&#x27;,//打包的入口文件    output: &#123;//出口        filename: &quot;bundle.js&quot;,//出口文件名        path: path.resolve(__dirname, &quot;./dist&quot;),//出口文件路径需要绝对路径        clean: true,//打包前清理dist文件夹    &#125;&#125;\n\n生成HTML文件安装html-webpack-plugin插件\nnpm i html-webpack-plugin -D\n\n该模块用于自动生成HTML文件。在webpack.config.js中引入：\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); //通过 npm 安装\n\n通过plugins配置插件：\nplugins: [    new HtmlWebpackPlugin(&#123;//可不传配置项（默认配置）        template: &quot;./index.html&quot;,//以index.html为模板生成html文件        filename: &quot;app.html&quot;,        inject: &#x27;body&#x27;,//指定script标签写在body标签中（默认为head）    &#125;)]\n\n代码有修改后自动打包：\nwebpack --watch\n\n开发环境安装webpack-dev-server插件\nnpm i webpack-dev-server -D\n\n//开发模式mode: &quot;development&quot;,devtool: &#x27;inline-source-map&#x27;,//精确显示代码位置（比如报错时）devServer: &#123;//开发服务器    static:&#x27;./dist&#x27;&#125;,\n\n命令行执行：\nwebpack-dev-server\n\n无需打包，通过浏览器访问8080端口实时查看页面效果\n资源模块Resource资源加载资源导出url\nmodule:&#123;    rules: [        &#123;            test:/\\.png$/,//匹配.png文件            type: &quot;asset/resource&quot;,//加载资源导出url            generator: &#123;//指定打包的路径（可省略）                filename: &#x27;images/[contenthash][ext]&#x27;//[contenthash]:哈希值作为文件名，[ext]:扩展名            &#125;        &#125;    ]&#125;\n\n示例：在index.js中导入png图片\nimport imgsrc from &#x27;../asset/微信.png&#x27;//图片url(http://localhost:8080/images/a2769eaec65049f8919b.png)const img = document.createElement(&#x27;img&#x27;)img.src = imgsrcdocument.body.appendChild(img)\n\n也可再output中使用assetModuleFilename指定打包路径，优先级低于rules中的配置\noutput: &#123;//出口    filename: &quot;bundle.js&quot;,//出口文件名    path: path.resolve(__dirname, &quot;./dist&quot;),//出口文件路径需要绝对路径    clean: true,//打包前清理dist文件夹    assetModuleFilename: &quot;images/[contenthash][ext]&quot;,//[contenthash]:哈希值作为文件名，[ext]:扩展名&#125;,\n\ninline资源导出为Data URL base64格式\n&#123;    test: /\\.svg$/,    type: &quot;asset/inline&quot;,//导出为Data URL base64格式&#125;,\n\n示例：导入svg图片\nimport logoSvg from &#x27;./asset/logo.svg&#x27;//(data:image/svg+xml;base64,PHN2ZyB4bWxucz......)const img2 = document.createElement(&#x27;img&#x27;)img2.src = logoSvgimg2.style.cssText=&#x27;width:400px;height:600px&#x27;document.body.appendChild(img2)\n\nsource资源导出文件源码\n&#123;    test: /\\.txt$/,    type: &quot;asset/source&quot;,//导出文件源码&#125;\n\n示例：导入源码\nimport helloTxt from &#x27;./asset/hello.txt&#x27;//txt的文本内容const block = document.createElement(&#x27;div&#x27;)block.style.cssText = &#x27;width:200px;height:200px;border:1px solid gray&#x27;block.textContent = helloTxtdocument.body.appendChild(block)\n\n通用资源类型自动选择资源类型，小于maxSize用inline类型，大于则用resource类型\n&#123;    test: /\\.jpg$/,    type: &quot;asset&quot;,//自动选择资源类型，小于maxSize用inline类型，大于则用resource类型    parser: &#123;//自定义条件（可省略）        dataUrlCondition:&#123;            maxSize: 4 * 1024//默认为4 * 1024        &#125;    &#125;&#125;\n\n示例：导入jpg图片\nimport jpgMap from &#x27;./asset/头像.jpg&#x27;//因为大于4k所以是url格式const block = document.createElement(&#x27;div&#x27;)block.style.cssText = &#x27;width:200px;height:200px;border:1px solid gray&#x27;block.textContent = helloTxtdocument.body.appendChild(block)\n\nloader加载CSS安装loader\nnpm i css-loader -Dnpm i style-loader -D\n\n在module &gt; rules中配置\n&#123;    test: /\\.css$/,    //css-loader写在style-loader后面，先加载    //如果需要CSS预处理语言，安装相应的loader，写在css-loader后面    use: [&#x27;style-loader&#x27;,&#x27;css-loader&#x27;],//css-loader允许打包css文件，style-loader将样式加到html页面上&#125;\n\n抽离和压缩CSS安装插件\nnpm i mini-css-extract-plugin -Dnpm i css-minimizer-webpack-plugin -D\n\n引入插件\nconst MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)const CssMinimizerPlugin = require(&#x27;css-minimizer-webpack-plugin&#x27;)\n\n在plugin中使用MiniCssExtractPlugin（用于以link标签的形式在html中导入css文件）\nnew MiniCssExtractPlugin(&#123;\tfilename:&#x27;styles/[contenthash].css&#x27;//自定义打包路径&#125;)\n\n&#123;    test: /\\.css$/,    //&#x27;style-loader&#x27;换为MiniCssExtractPlugin    use: [MiniCssExtractPlugin.loader,&#x27;css-loader&#x27;],//css-loader允许打包css文件，style-loader将样式加到html页面上&#125;\n\n新配置项optimization中使用CssMinimizerPlugin（用于压缩css文件）\noptimization: &#123;    minimizer: [        new CssMinimizerPlugin()    ]&#125;,mode:&#x27;production&#x27;//生产环境下才会压缩（会有其他报错）\n\nbabel-loader如果浏览器不支持ES6语法，使用babel-loader，将ES6转为ES5\n安装babel-loader，@babel&#x2F;core，@babel&#x2F;preset-env\nnpm i babel-loader @babel/core @babel/preset-env -Dnpm i @babel/runtime -Dnpm i @babel/plugin-transform-runtime -D\n\nmodule &gt; rules中配置\n&#123;    test:/\\.js$/,    exclude: /node_modules/,//排除node_modules中的js文件    use:&#123;        loader:&#x27;babel-loader&#x27;,        options: &#123;            presets:[&#x27;@babel/preset-env&#x27;],            plugins: [                [                    &#x27;@babel/plugin-transform-runtime&#x27;                ]            ]        &#125;    &#125;&#125;\n\n代码分离多入口entry中设置多入口文件，修改output中的filename\nentry: &#123;    //两个文件都引入了lodash模块    index: &#x27;./src/index.js&#x27;,    another: &#x27;./src/another.js&#x27;&#125;,//打包的入口文件output: &#123;//出口    filename: &quot;[name].bundle.js&quot;,//出口文件名（[name]:入口文件的键值）    path: path.resolve(__dirname, &quot;./dist&quot;),//出口文件路径需要绝对路径    clean: true,//打包前清理dist文件夹    assetModuleFilename: &quot;images/[contenthash][ext]&quot;,//[contenthash]:哈希值作为文件名，[ext]:扩展名&#125;,\n\n防止重复optimization: &#123;    splitChunks: &#123;        chunks: &quot;all&quot;//自动抽离公共代码模块    &#125;&#125;\n","categories":["工程化"],"tags":["webpack"]},{"title":"vue3使用router","url":"/2022/05/02/vue3%E4%BD%BF%E7%94%A8router/","content":"初始化vue3项目npm init vite@latest\n\n使用vue+ts\nvue-router基本使用安装vue-routernpm i vue-router\n\n基本使用新建src/index.ts:\nimport &#123;createRouter, createWebHashHistory, createWebHistory, RouteRecordRaw&#125; from &quot;vue-router&quot;;const routes: RouteRecordRaw[] = [  &#123;    path: &#x27;/&#x27;,    component: () =&gt; import(&#x27;../components/Login.vue&#x27;)  &#125;,  &#123;    path:&#x27;/reg&#x27;,    component: ()=&gt; import(&#x27;../components/Register.vue&#x27;)  &#125;]export default createRouter(&#123;  history: createWebHistory(), //路由模式  routes&#125;)\n\nmain.ts中导入：\nimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import Router from &#x27;./router/index&#x27;createApp(App).use(Router).mount(&#x27;#app&#x27;)\n\nrouter-view和router-linkApp.vue中：\n&lt;template&gt;  &lt;!--replace：不产生历史记录--&gt;  &lt;router-link to=&quot;/&quot; replace&gt;登录&lt;/router-link&gt;  &lt;router-link to=&quot;/reg&quot;&gt;注册&lt;/router-link&gt;  &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt;\n\n编程式导航&lt;template&gt;  &lt;router-link to=&quot;/&quot;&gt;登录&lt;/router-link&gt;  &lt;router-view&gt;&lt;/router-view&gt;  &lt;button @click=&quot;goto&quot;&gt;去注册&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;useRouter&#125; from &quot;vue-router&quot;;const router = useRouter()const goto = () =&gt; &#123;  router.push(&#x27;/reg&#x27;)  // router.replace(&#x27;/&#x27;) //不产生历史记录  // router.go(1) //前进  // router.go(-1) //后退  // router.back() //后退&#125;&lt;/script&gt;\n\n路由传参和vue2中一样（query、params、动态路由参数）\n传params参数必须使用命名路由，params参数刷新页面后丢失，动态路由参数和query不会\n路由模式vue2使用mode设置路由模式，vue3改为history\n对应关系：\n\n\n\nvue2\nvue3\n\n\n\nhistory\ncreateWebHistory\n\n\nhash\ncreateWebHashHistory\n\n\nabstact\ncreateMemoryHistory\n\n\nhash原理//获取当前hash值location.hash //输出：&#x27;#/&#x27;//设置hash值location.hash = &#x27;/reg&#x27; //或者&#x27;#/reg&#x27;\n\n通过onhashchange监听hash的变化:\nwindow.addEventListener(&#x27;hashchange&#x27;,(event)=&gt;&#123; //hash发生变化时触发\tconsole.log(event) //HashChangeEvent对象（包含很多属性，比如：newURL、oldURL等）&#125;)\n\nhistory原理通过onpopstate监听url的变化:\nwindow.addEventListener(&#x27;popstate&#x27;,(event)=&gt;&#123; //路径发生变化时触发\tconsole.log(event) //PopStateEvent对象（其中的state属性就包含路径信息）&#125;)\n\nhistory.state //&#123;back: &#x27;/reg&#x27;, current: &#x27;/&#x27;, forward: &#x27;/reg&#x27;, replaced: false, position: NaN, …&#125;history.pushState(&#123;&#125;,&#x27;&#x27;,&#x27;/reg&#x27;) //此方法只会改变当前地址栏的路径，并不会更新页面内容//需要在Javascript代码中调用history.back()或用户点击浏览器的回退按钮\n\n命名视图和重定向定义多个组件：\n&#123;  path: &#x27;/&#x27;,  //重定向（可使用字符串、对象、函数三种写法）  //redirect:&#x27;/user1&#x27;,  redirect: to =&gt; &#123;    return &#123;      path: &#x27;user1&#x27;    &#125;  &#125;，  //别名  //alias:[&#x27;user&#x27;,...],  children: [    &#123;      path: &#x27;user1&#x27;,      components:&#123;        default: () =&gt; import(&#x27;../components/A.vue&#x27;),      &#125;    &#125;,    &#123;      path: &#x27;user2&#x27;,      components:&#123;        bbb: () =&gt; import(&#x27;../components/B.vue&#x27;),        ccc: () =&gt; import(&#x27;../components/C.vue&#x27;)      &#125;    &#125;  ],&#125;\n\n&lt;template&gt;  &lt;!--加载default--&gt;  &lt;router-view&gt;&lt;/router-view&gt;  &lt;!--加载对应的name--&gt;  &lt;router-view name=&#x27;bbb&#x27;&gt;&lt;/router-view&gt;  &lt;router-view name=&#x27;ccc&#x27;&gt;&lt;/router-view&gt;&lt;/template&gt;\n\n路由过渡动画安装animate.css：npm install animate.css --save\n设置路由元信息（meta），准备好animate.css的类名\n&#123;  path: &#x27;/&#x27;,  component: () =&gt; import(&#x27;../components/Login.vue&#x27;)，  meta: &#123;    transition: &#x27;animate__bounceIn&#x27;  &#125;&#125;,&#123;  path:&#x27;/reg&#x27;,  component: ()=&gt; import(&#x27;../components/Register.vue&#x27;)，  meta: &#123;    transition: &#x27;animate__fadeIn&#x27;  &#125;&#125;\n\n使用：\n&lt;template&gt;  &lt;router-link to=&quot;/&quot;&gt;登录&lt;/router-link&gt;  &lt;router-link to=&quot;/reg&quot;&gt;注册&lt;/router-link&gt;  &lt;router-view #default=&quot;&#123;route,Component&#125;&quot;&gt;    &lt;transition :enter-active-class=&quot;`animate__animated $&#123;route.meta.transition&#125;`&quot;&gt;      &lt;component :is=&quot;Component&quot;&gt;&lt;/component&gt;    &lt;/transition&gt;  &lt;/router-view&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#x27;animate.css&#x27;&lt;/script&gt;\n\nrouter-view： 可以使用作用域插槽的写法\ntransition：定义过度动画\ncomponent（动态组件）：通过is属性指定组件\n滚动行为scrollBehavior：创建Router时可定义的方法（返回值为滚动条的位置）\nexport default createRouter(&#123;  history: createWebHistory(),  //保存滚动条的位置  scrollBehavior: (to,from,savedPosition)=&gt;&#123;    if(savedPosition)&#123;      return savedPosition    &#125;else &#123;      return &#123;        top:0      &#125;    &#125;  &#125;,  routes&#125;)\n","categories":["vue3"],"tags":["vue3","router","vue-router"]},{"title":"二叉树","url":"/2022/05/19/%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"搜索二叉树一种特殊有序的二叉树。如果一棵树不为空，并且如果它的根节点左子树不为空，那么它左子树上面的所有节点的值都小于它的根节点的值，如果它的右子树不为空，那么它右子树任意节点的值都大于他的根节点的值，它的左右子树也是二叉搜索树。\n验证是否是搜索二叉树leetcode上的题目：验证二叉搜索树\n通过二叉树的中序遍历判断\nvar isValidBST = function (root) &#123;  let pre = -Infinity  return valid(root)  function valid(root) &#123;    if (!root) return true    if (!valid(root.left)) return false    if (root.val &lt;= pre) return false    pre = root.val    return valid(root.right)  &#125;&#125;;\n\n完全二叉树叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。\n宽度优先遍历使用队列实现\nfunction TreeNode(val, left, right) &#123;  this.val = (val === undefined ? 0 : val)  this.left = (left === undefined ? null : left)  this.right = (right === undefined ? null : right)&#125;let root = new TreeNode(5)root.left = new TreeNode(1)root.right = new TreeNode(4)root.right.left = new TreeNode(3)root.right.right = new TreeNode(6)function traverse(root) &#123;  const queue = []  queue.push(root)  while (queue.length) &#123;    root = queue.shift()    console.log(root.val)    if (root.left) queue.push(root.left)    if (root.right) queue.push(root.right)  &#125;&#125;traverse(root) //5 1 4 3 6\n\n验证完全二叉树使用宽度优先遍历。如果遇到有右节点无左节点的返回false；语遇到叶子节点之后的所有节点都必须是叶子节点，否则返回false。\n二叉树最大深度leetcode上的题目：二叉树的最大深度\n递归解决：（树的最大深度等于左右子树的最大深度加一）\nvar maxDepth = function (root) &#123;  if (!root) return 0  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1&#125;;\n\n满二叉树除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。\n递归解决：（所有节点的左右子树是满二叉树且深度相等）\nfunction TreeNode(val, left, right) &#123;  this.val = (val === undefined ? 0 : val)  this.left = (left === undefined ? null : left)  this.right = (right === undefined ? null : right)&#125;let root = new TreeNode(5)root.left = new TreeNode(1)root.right = new TreeNode(4)root.right.left = new TreeNode(3)root.right.right = new TreeNode(6)root.left.left = new TreeNode(6)root.left.right = new TreeNode(6)function isFull(root) &#123;  return depth(root) &gt;= 0  function depth(root) &#123;    if (!root) return 0    let leftDepth = depth(root.left)    let rightDepth = depth(root.right)    if (leftDepth !== -1 &amp;&amp; leftDepth === rightDepth)      return leftDepth + 1    else       return -1  &#125;&#125;console.log(isFull(root)) //true\n\n平衡二叉树任意节点的子树的高度差都小于等于 1\nleetcode上的题目：平衡二叉树\n递归解决：\nvar isBalanced = function (root) &#123;  return depth(root) &gt;= 0  function depth(root) &#123;    if (!root) return 0    let leftDepth = depth(root.left)    let rightDepth = depth(root.right)    if (leftDepth !== -1 &amp;&amp; rightDepth !== -1 &amp;&amp; Math.abs(leftDepth - rightDepth) &lt;= 1) &#123;      return Math.max(leftDepth, rightDepth) + 1    &#125; else &#123;      return -1    &#125;  &#125;&#125;;\n\n二叉树共同祖先leetcode上的题目：二叉树的最近公共祖先\n递归解决：\nvar lowestCommonAncestor = function (root, p, q) &#123;  if (!root || root === p || root === q) &#123;    return root  &#125;  let left = lowestCommonAncestor(root.left, p, q)  let right = lowestCommonAncestor(root.right, p, q)  //if (!left &amp;&amp; !right) return null  if (left &amp;&amp; right) return root  return left ? left : right&#125;;\n\n前驱节点、后继节点二叉树的前驱节点：就是中序遍历中该节点的前一个节点\n二叉树的后继节点：就是中序遍历中该节点的后一个节点\n序列化和反序列化leetcode上的题目：二叉树的序列化与反序列化\n//序列化var serialize = function (root) &#123;  if (!root) return &#x27;#_&#x27;  let result = root.val + &#x27;_&#x27;  result += serialize(root.left)  result += serialize(root.right)  return result&#125;;//反序列化var deserialize = function (data) &#123;  const arr = data.split(&#x27;_&#x27;)  function createTree(arr) &#123;    const val = arr.shift()    if (val === &#x27;#&#x27;) &#123;      return null    &#125;    const head = new TreeNode(val)    head.left = createTree(arr)    head.right = createTree(arr)    return head  &#125;  return createTree(arr)&#125;;\n","categories":["数据结构"],"tags":["二叉树"]},{"title":"实用网站","url":"/2022/03/22/%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99/","content":"前端面试web前端面试 - 面试官系列\n大厂面试题每日一题\n木易杨前端进阶\nJavaScriptECMAScript 6 入门-阮一峰\nTypeScriptTypeScript入门教程\nGit廖雪峰的官方网站-Git教程\n博客山月行\n冴羽的博客：TypeScript、JavaScript、ES6、VuePress\n站点MDN\n","categories":["网站"],"tags":["ES6","git","JavaScript","面试题"]},{"title":"古典密码Vigenere算法","url":"/2022/04/08/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81Vigenere%E7%AE%97%E6%B3%95/","content":"代码如下（html文件）：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Title&lt;/title&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;style&gt;    #root &#123;      width: 60%;      margin: auto;    &#125;    .header &#123;      width: 360px;      margin: auto;    &#125;    .main &#123;      display: flex;      justify-content: left;      padding-top: 20px;    &#125;    .area &#123;      width: 40%;      padding-right: 80px;    &#125;    .area textarea &#123;      width: 100%;      height: 120px;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;root&quot;&gt;  &lt;div class=&quot;header&quot;&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;请输入密钥&quot; v-model.lazy.trim=&quot;key&quot; @blur=&quot;setKey&quot;&gt;    &lt;button @click=&quot;encryption&quot;&gt;加密&lt;/button&gt;    &lt;button @click=&quot;decrypt&quot;&gt;解密&lt;/button&gt;  &lt;/div&gt;  &lt;div class=&quot;main&quot;&gt;    &lt;div class=&quot;area&quot;&gt;      &lt;textarea placeholder=&quot;请输入明文/密文&quot; v-model.lazy.trim=&quot;put&quot;&gt;&lt;/textarea&gt;    &lt;/div&gt;    &lt;div class=&quot;area&quot;&gt;      &lt;textarea placeholder=&quot;加密/解密的结果&quot; v-model.lazy.trim=&quot;out&quot;&gt;&lt;/textarea&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;&lt;script&gt;  Vue.config.productionTip = false;   //阻止 vue 在启动时生成生产提示  new Vue(&#123;    el: &quot;#root&quot;,    data: &#123;      key: &#x27;&#x27;,      put: &#x27;&#x27;,//输入      out: &#x27;&#x27;,//输出    &#125;,    computed: &#123;      table() &#123;        const obj = &#123;&#125;        let c1 = &#x27;&#x27;, c2 = &#x27;&#x27;, r = &#x27;&#x27;        for (let i = 97; i &lt; 123; i++) &#123;          c1 = String.fromCharCode(i)          obj[c1] = &#123;&#125;          for (let n = 97; n &lt; 123; n++) &#123;            let res = n + i - 97            c2 = String.fromCharCode(n)            r = String.fromCharCode(res &gt; 122 ? res - 26 : res)            obj[c1][c2] = r          &#125;        &#125;        return obj      &#125;    &#125;,    methods: &#123;      setKey() &#123;        if (!/^[a-z|A-Z]+$/.test(this.key)) &#123;          this.key = &#x27;&#x27;        &#125;      &#125;,      //加密按钮回调      encryption() &#123;        let &#123;put, key&#125; = this        key = key.toLowerCase()        let out = []        let n = 0        const l = key.length - 1        if (put &amp;&amp; key) &#123;          for (let i = 0; i &lt; put.length; i++) &#123;            if (/[a-z]/.test(put[i])) &#123;              out.push(this.table[key[n]][put[i]])            &#125; else if (/[A-Z]/.test(put[i])) &#123;              let char = this.table[key[n]][put[i].toLowerCase()]              out.push(char.toUpperCase())            &#125; else &#123;              out.push(put[i])            &#125;            n === l ? n = 0 : n++          &#125;          this.out = out.join(&#x27;&#x27;)        &#125;      &#125;,      //解密按钮回调      decrypt() &#123;        let &#123;put, key&#125; = this        key = key.toLowerCase()        let out = []        let n = 0        const l = key.length - 1        if (put &amp;&amp; key) &#123;          for (let i = 0; i &lt; put.length; i++) &#123;            if (/[a-z]/.test(put[i])) &#123;              out.push(this.decryptUtil(key[n], put[i]))            &#125; else if (/[A-Z]/.test(put[i])) &#123;              let char = this.decryptUtil(key[n], put[i].toLowerCase())              out.push(char.toUpperCase())            &#125; else &#123;              out.push(put[i])            &#125;            n === l ? n = 0 : n++          &#125;          this.out = out.join(&#x27;&#x27;)        &#125;      &#125;,      //解密      decryptUtil(key, value) &#123;        for (let i = 97; i &lt; 123; i++) &#123;          if (this.table[key][String.fromCharCode(i)] === value) &#123;            return String.fromCharCode(i)          &#125;        &#125;      &#125;    &#125;  &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n","categories":["信息安全","古典密码"],"tags":["Vue","JavaScript","Vigenere"]},{"title":"手写vue-lazyload","url":"/2022/04/03/%E6%89%8B%E5%86%99vue-lazyload/","content":"vue-lazyloadmain.js中引入vue-lazyload：\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import VueLazyload from &quot;vue-lazyload&quot;;Vue.use(VueLazyload,&#123;  loading:&#x27;http://localhost:3000/img/loading.gif&#x27;, //图片加载中显示的图片  error:&#x27;http://localhost:3000/img/error-img.png&#x27;, //图片加载错误显示的图片  preLoad:1 //超出1倍屏幕高度的图片先不加载&#125;)\n\n.vue文件中使用：\n使用指令v-lazy代替img标签的src属性，表示该图片使用懒加载\n&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;div v-for=&quot;(item,index) in imgData&quot; :key=&quot;index&quot;&gt;      &lt;div class=&quot;img&quot;&gt;        &lt;img v-lazy=&quot;item.img&quot; alt=&quot;img&quot;&gt;      &lt;/div&gt;      &lt;div class=&quot;content&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &#x27;axios&#x27;export default &#123;  name: &#x27;App&#x27;,  data() &#123;    return &#123;      imgData: []    &#125;  &#125;,  mounted() &#123;    this.getImgs()  &#125;,  methods: &#123;    async getImgs() &#123;      const res = await axios.get(&#x27;http://localhost:3000/imgs&#x27;)      this.imgData = res.data    &#125;  &#125;&#125;&lt;/script&gt;\n\n自定义指令实现v-lazy手写插件vue-lazyload新建文件modules/vue-lazyload/index.js:\nexport default &#123; //默认暴露一个带有install方法的对象  install(Vue,options)&#123; //Vue：Vue构造器，options：使用插件时传入的配置对象      &#125;&#125;\n\nmain.js中引入自己的插件：\nimport VueLazyload from &quot;./modules/vue-lazyload&quot;;\n\n自定义指令export default &#123;  install(Vue, options) &#123;    //自定义指令,参数一：自定义指令名，参数二：定义该指令功能的对象    Vue.directive(&#x27;lazy&#x27;, &#123;      //指令定义对象可以调用一些钩子函数：比如bind、inserted      //钩子函数的参数，el：指令所绑定的元素，binding：一个对象，vnode：虚拟节点      //bind：只调用一次，指令第一次绑定到元素时调用      bind(el,binding,vnode)&#123;      &#125;    &#125;)  &#125;&#125;\n\n功能实现的类接下来就需要在bind钩子函数中实现功能逻辑，为了更好的扩展性，将功能封装成一个类：\n创建modules/vue-lazyload/lazy.js：\nexport default function (Vue) &#123; //暴露一个函数，接收Vue构造器  return class Lazy &#123; //返回一个类，接收options    constructor(options) &#123;      this.options = options    &#125;      //实现功能的函数    bindLazy(el, binding) &#123;    &#125;  &#125;&#125;\n\nmodules/vue-lazyload/index.js:\nimport lazy from &#x27;./lazy&#x27; //导入lazy.jsexport default &#123;  install(Vue, options) &#123;    const LazyClass = lazy(Vue)    const lazyload = new LazyClass(options)    Vue.directive(&#x27;lazy&#x27;, &#123;      bind: lazyload.bindLazy.bind(lazyload) //绑定函数，注意修改this指向    &#125;)  &#125;&#125;\n\n准备一个函数，用于获取dom的最近的滚动父节点（overflow：scroll）\n创建modules/vue-lazyload/util.js:\nexport function getScrollParent(el) &#123;  let _parent = el.parentNode  while (_parent) &#123;      //getComputedStyle：获取目标的所有css属性    const overflow = getComputedStyle(_parent)[&#x27;overflow&#x27;] //获取overflow属性值    if (/(scroll)|(auto)/.test(overflow)) &#123;      return _parent    &#125;    _parent = _parent.parentNode  &#125;&#125;\n\nlazy.js中使用Vue.nextTick:\nimport &#123;getScrollParent&#125; from &#x27;./util&#x27;export default function (Vue) &#123;  return class Lazy &#123;    constructor(options) &#123;      this.options = options      this.isAddScrollListener = false     &#125;    bindLazy(el, binding) &#123;      Vue.nextTick(() =&gt; &#123;        const scrollParent = getScrollParent(el)        if (scrollParent &amp;&amp; !this.isAddScrollListener) &#123; //如果还没有绑定事件          scrollParent.addEventListener(&#x27;scroll&#x27;,this.handleScroll.bind(this))        &#125;      &#125;)    &#125;    //滚动事件    handleScroll()&#123;    &#125;  &#125;&#125;\n\n图片实例的类创建modules/vue-lazyload/lazyimg.js:\nexport default class Lazyimg &#123;  constructor(&#123;el, src, options, imgRender&#125;) &#123;    this.el = el    this.src = src    this.options = options    this.imgRender = imgRender    this.loaded = false //已经加载过    this.state = &#123;      loading: false, //加载成功      error: false //加载失败    &#125;  &#125;i  //图片是否在指定范围内  checkIsVisible() &#123;    const &#123;top&#125; = this.el.getBoundingClientRect() //获取元素距顶部的距离    return top &lt; window.innerHeight * (this.options.preLoad || 1.3) //判断是否在范围内，preLoad默认1.3  &#125;  //加载图片（未完成，第二个参数先写死成loading，参数一为该图片实例）  loadImg() &#123;    this.imgRender(this,&#x27;loading&#x27;) //加载图片，图片加载中时显示的图片  &#125;&#125;\n\nlazy.js:每次触发bind时创建一个图片实例，保存到数组\nimport &#123;getScrollParent&#125; from &#x27;./util&#x27;import &#123;throttle&#125; from &#x27;lodash&#x27; //节流import Lazyimg from &quot;./lazyimg&quot;;export default function (Vue) &#123;  return class Lazy &#123;    constructor(options) &#123;      this.options = options      this.isAddScrollListener = false      this.lazyimgPool = [] //图片实例数组    &#125;    bindLazy(el, binding) &#123;      Vue.nextTick(() =&gt; &#123;        const scrollParent = getScrollParent(el)        if (scrollParent &amp;&amp; !this.isAddScrollListener) &#123;          scrollParent.addEventListener(&#x27;scroll&#x27;, throttle(this.handleScroll.bind(this), 200))          this.isAddScrollListener = true        &#125;          //创建一个新的图片实例        const lazyimg = new Lazyimg(&#123;           el,          src: binding.value, //v-lazy指令绑定的值          options: this.options,          imgRender: this.imgRender.bind(this)        &#125;)        this.lazyimgPool.push(lazyimg)        this.handleScroll() //滚动事件在一开始就执行一次      &#125;)    &#125;    //滚动事件    handleScroll() &#123;    &#125;    //图片渲染函数    imgRender() &#123;    &#125;  &#125;&#125;\n\n滚动事件handleScroll() &#123;  let isVisible = false  this.lazyimgPool.forEach(lazyimg =&gt; &#123;    if (!lazyimg.loaded) &#123; //图片还没有加载      isVisible = lazyimg.checkIsVisible() //图片是否出现在指定的范围内（perLoad指定的）      isVisible &amp;&amp; lazyimg.loadImg() //如果出现在范围内，则加载图片    &#125;  &#125;)&#125;\n\n渲染图片imgRender(lazyimg, state) &#123;  const &#123;el, options&#125; = lazyimg  const &#123;loading, error&#125; = options  let src = &#x27;&#x27;  switch (state) &#123;    case &#x27;loading&#x27;: //加载中      src = loading || &#x27;&#x27;      break    case &#x27;error&#x27;: //加载错误      src = error || &#x27;&#x27;      break    default: //加载完成，显示真正的目标图片      src = lazyimg.src  &#125;  el.setAttribute(&#x27;src&#x27;,src) //设置或改变图片的src&#125;\n\n渲染完成util.js中添加：\nexport function imgLoad(src) &#123;  return new Promise(((resolve, reject) =&gt; &#123;    const oImg = new Image()    oImg.src = src    oImg.onload = resolve //加载成功    oImg.onerror = reject //加载失败  &#125;))&#125;\n\nlazy.js:\nloadImg() &#123;  this.imgRender(this, &#x27;loading&#x27;)  imgLoad(this.src).then(() =&gt; &#123;//成功    this.state.loading = true    this.imgRender(this, &#x27;ok&#x27;)     this.loaded = true  &#125;).catch(() =&gt; &#123;//失败    this.state.error = true    this.imgRender(this, &#x27;error&#x27;)    this.loaded = true  &#125;)&#125;\n\n通过IntersectionObserver实现export default &#123;  install(Vue, options) &#123;    Vue.directive(&#x27;lazy&#x27;, &#123;      bind(el, binding) &#123;        init(el, binding.value, options.loading)      &#125;,      inserted(el) &#123;        observer(el)      &#125;    &#125;)  &#125;&#125;// 初始化function init(el, src, loading) &#123;  el.setAttribute(&#x27;data-src&#x27;, src)  el.setAttribute(&#x27;src&#x27;, loading)&#125;// 利用IntersectionObserver监听elfunction observer(el) &#123;  let observer = new IntersectionObserver(entries =&gt; &#123;    if (entries[0].isIntersecting)&#123; //进入视口      let realSrc=el.dataset.src      if (realSrc)&#123;        el.setAttribute(&#x27;src&#x27;,realSrc)        el.removeAttribute(&#x27;data-src&#x27;)      &#125;    &#125;  &#125;)  observer.observe(el)&#125;\n\n生成观察器实例：let observer = new IntersectionObserver(callback,option)\n接收两个参数，callback：可见性变化时的回调函数，option：可选的配置项\ncallback：\n一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。\nlet io = new IntersectionObserver(  entries =&gt; &#123;    console.log(entries);  &#125;)\n\nenteries：是一个数组，每个成员是IntersectionObserverEntry对象，如果同时有多个被观察的对象的可见性发生变化，enteries数组就有多个成员。\nIntersectionObserverEntry对象的部分属性：\n\nisIntersecting：是否可见\ntime：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒\nboundingClientRect：目标元素的矩形区域信息\nintersectionRatio：目标元素的可见比例，完全可见时为1，完全不可见时小于等于0\nintersectionRect：目标元素与视口（或根元素）的交叉区域的信息\ntarget：目标元素\nrootBounds：根元素的矩形区域的信息\n\noption对象属性：\n\nthreshold：数组，决定何时触发回调函数，比如，[0, 0.25, 0.5, 0.75, 1]就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。\nroot、rootMargin：root属性指定目标元素所在的容器节点（即根元素）。注意，容器元素必须是目标元素的祖先节点。rootMargin属性。后者定义根元素的margin，用来扩展或缩小rootBounds这个矩形的大小，从而影响intersectionRect交叉区域的大小。它使用CSS的定义方法，比如10px 20px 30px 40px，表示 top、right、bottom 和 left 四个方向的值。\n\n参考文档\n参考视频\n","categories":["手写","vue"],"tags":["vue","vue-lazyload","图片懒加载","插件","自定义指令","IntersectionObserver"]},{"title":"手写flat","url":"/2022/04/18/%E6%89%8B%E5%86%99flat/","content":"手写flat（数组扁平化）Array.prototype._flat=function (depth=1)&#123;  function flatten(arr,depth)&#123;    if(depth&lt;=0) return [...arr]    return arr.reduce((pre,cur)=&gt;&#123;      if (Array.isArray(cur)) pre.push(...flatten(cur,depth-1)) //是数组，递归      else pre.push(cur) //不是数组，直接加入pre      return pre    &#125;,[])  &#125;  return flatten(this,depth)&#125;\n\nconst arr=[1,[2,3],[4,[5,6]],7]console.log(arr._flat()) //[1, 2, 3, 4, [5, 6], 7]console.log(arr._flat(1)) //[1, 2, 3, 4, [5, 6], 7]console.log(arr._flat(2)) //[1, 2, 3, 4, 5, 6, 7]console.log(arr._flat(Infinity)) //[1, 2, 3, 4, 5, 6, 7]\n\n代码简化：\nArray.prototype._flat = function (depth = 1) &#123;  function flatten(arr, depth) &#123;    return depth &lt;= 0 ?        [...arr] : arr.reduce((pre, cur) =&gt; Array.isArray(cur) ?            [...pre, ...flatten(cur, depth - 1)] : [...pre, cur], [])  &#125;  return flatten(this, depth)&#125;\n\n\n\n参考视频\n","categories":["JavaScript","手写"],"tags":["flat"]},{"title":"排序","url":"/2022/05/13/%E6%8E%92%E5%BA%8F/","content":"选择排序第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。\n以此类推，直到全部待排序的数据元素的个数为零。\n算法的时间复杂度为O(n^2)、额外空间复杂度为O(1)。\nfunction swap(arr, i, j) &#123;  let num = arr[i]  arr[i] = arr[j]  arr[j] = num&#125;const arr = [3, 44, 635, 7, 45, 34, 65, 2, 34, 6262, 432, 4]function selectSort(arr) &#123;  if (!Array.isArray(arr) || arr.length &lt; 2) return  let len = arr.length  for (let i = 0; i &lt; len; i++) &#123;    let index = i    for (let j = i + 1; j &lt; len; j++) &#123;      index = arr[index] &gt; arr[j] ? j : index    &#125;    swap(arr, i, index)  &#125;&#125;console.log(arr) //[3, 44, 635, 7, 45, 34, 65, 2, 34, 6262, 432, 4]selectSort(arr)console.log(arr) //[2, 3, 4, 7, 34, 34, 44, 45, 65, 432, 635, 6262]\n\n冒泡排序首先从数组的第一个元素开始到数组最后一个元素为止，对数组中相邻的两个元素进行比较，如果位于数组左端的元素大于数组右端的元素，则交换这两个元素在数组中的位置。这样操作后数组最右端的元素即为该数组中所有元素的最大值。\n接着对该数组除最右端的n-1个元素进行同样的操作，再接着对剩下的n-2个元素做同样的操作，直到整个数组有序排列。\n算法的时间复杂度为O(n^2)、额外空间复杂度为O(1)。\nfunction bubbleSort(arr) &#123;  if (!Array.isArray(arr) || arr.length &lt; 2) return  const len = arr.length  for (let i = len - 1; i &gt; 0; i--) &#123;    for (let j = 0; j &lt; i; j++) &#123;      arr[j] &gt; arr[j + 1] ? swap(arr, j, j + 1) : null    &#125;  &#125;&#125;console.log(arr) //[3, 44, 635, 7, 45, 34, 65, 2, 34, 6262, 432, 4]bubbleSort(arr)console.log(arr) //[2, 3, 4, 7, 34, 34, 44, 45, 65, 432, 635, 6262]\n\n插入排序将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增 1 的有序表。\n算法的时间复杂度为O(n^2)、额外空间复杂度为O(1)。\nfunction insertSort(arr) &#123;  if (!Array.isArray(arr) || arr.length &lt; 2) return  const len = arr.length  for (let i = 1; i &lt; len; i++) &#123;    let j = i    while (j &gt;= 0 &amp;&amp; arr[j - 1] &gt; arr[j]) &#123;      swap(arr, j - 1, j)      j--    &#125;  &#125;&#125;console.log(arr) //[3, 44, 635, 7, 45, 34, 65, 2, 34, 6262, 432, 4]insertSort(arr)console.log(arr) //[2, 3, 4, 7, 34, 34, 44, 45, 65, 432, 635, 6262]\n\n简化写法\nfunction insertSort2(arr) &#123;  if (!Array.isArray(arr) || arr.length &lt; 2) return  const len = arr.length  for (let i = 1; i &lt; len; i++) &#123;    for (let j = i - 1; j &gt; -1 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123;      swap(arr, j, j + 1)    &#125;  &#125;&#125;console.log(arr) //[3, 44, 635, 7, 45, 34, 65, 2, 34, 6262, 432, 4]insertSort2(arr)console.log(arr) //[2, 3, 4, 7, 34, 34, 44, 45, 65, 432, 635, 6262]\n\n适用于数据量不大，算法稳定性要求高，且数据局部或整体有序的数列排序。\n对数器生成随机长度和随机值的数组，用于测试排序算法是否正确\nfunction randomArray(maxLen, maxVal) &#123;  const arr = []  const len = Math.floor(Math.random() * maxLen) + 1  for (let i = 0; i &lt; len; i++) &#123;    arr.push(Math.floor(Math.random() * maxVal))  &#125;  return arr&#125;function copy(arr) &#123;  const newArr = []  for (let i = 0; i &lt; arr.length; i++) &#123;    newArr.push(arr[i])  &#125;  return newArr&#125;//是否升序function isSorted(arr) &#123;  if (arr.length &lt; 2) return true  for (let i = 1; i &lt; arr.length; i++) &#123;    if (arr[i - 1] &gt; arr[i]) return false  &#125;  return true&#125;function testSort(sortFun) &#123;  for (let i = 0; i &lt; 1000; i++) &#123;    const arr = randomArray(10, 1000)    const backup = copy(arr)    sortFun(arr)    if (!isSorted(arr)) &#123;      console.log(&#x27;排序出错&#x27;)      console.log(&#x27;排序前:&#x27; + backup)      console.log(&#x27;排序后:&#x27; + arr)      return    &#125;  &#125;  console.log(&#x27;排序成功&#x27;)&#125;testSort(selectSort) //排序成功testSort(bubbleSort) //排序成功testSort(insertSort) //排序成功testSort(insertSort2) //排序成功\n\n归并排序归并排序（Merge Sort）是建立归并操作上的一种有效，稳定的排序算法，该算法是采用分治法的一个非常典型的应用。\n将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。\n算法的时间复杂度为O(n*log n)、额外空间复杂度为O(n)。\nfunction merge(arr, l, m, r) &#123;  const help = []  let p1 = l  let p2 = m + 1  while (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;    arr[p1] &lt;= arr[p2] ? help.push(arr[p1++]) : help.push(arr[p2++])  &#125;  while (p1 &lt;= m) &#123;    help.push(arr[p1++])  &#125;  while (p2 &lt;= r) &#123;    help.push(arr[p2++])  &#125;  for (let i = 0; i &lt; help.length; i++) &#123;    arr[l + i] = help[i]  &#125;&#125;function mergeSortProcess(arr, l, r) &#123;  if (l === r) return  let mid = l + Math.floor((r - l) / 2)  mergeSortProcess(arr, l, mid)  mergeSortProcess(arr, mid + 1, r)  merge(arr, l, mid, r)&#125;function mergeSort(arr) &#123;  if (!Array.isArray(arr) || arr.length &lt; 2) return  let l = 0  let r = arr.length + 1  mergeSortProcess(arr, l, r)&#125;testSort(mergeSort) //排序成功\n\n快速排序快速排序（Quick Sort）算法是在冒泡排序的基础上进行改进的一种算法，从名字上看就知道该排序算法的特点是快、效率高，是处理大数据最快的排序算法之一。\n实现的基本思想是：通过一次排序将整个无序表分成相互独立的两部分，其中一部分中的数据都比另一部分中包含的数据的值小。\n然后继续沿用此方法分别对两部分进行同样的操作，直到每一个小部分不可再分，所得到的整个序列就变成有序序列。\n荷兰国旗问题给定一个数组arr，数组的最后一个数为num，将arr划分为三个区域，左边的数都小于num，中间等于num，右边都大于num。\n要求额外空间复杂度O(1)，时间复杂度O(n)。\nfunction partition(arr, l, r) &#123;  let num = arr[r]  let i = l  while (i &lt;= r) &#123;    if (arr[i] &lt; num) &#123;      swap(arr, l++, i++)    &#125; else if (arr[i] === num) &#123;      i++    &#125; else &#123;      swap(arr, i, r--)    &#125;  &#125;  return [l, r]&#125;let arr = [1, 8, 7, 4, 5, 6, 1, 8, 4, 9, 5]//返回一个长度为二的数组，表示中间区域的左右边界console.log(partition(arr, 0, 10)) //[4, 5]console.log(arr) //[1, 4, 4, 1, 5, 5, 8, 6, 9, 7, 8]\n\n实现快速排序递归调用上面（荷兰国旗问题中）的方法，随机选择一个数作为num，划分为小于、等于、大于三个部分后，对左右两个区域执行相同的操作。\n算法的时间复杂度为O(n*log n)、额外空间复杂度为O(log n)。\n最坏情况下每一次基准元素都是数组中最小或者最大的元素，则快速排序就是冒泡排序，这种情况时间复杂度就是冒泡排序的时间复杂度：O(n^2)。\nfunction quickSortProcess(arr, l, r) &#123;  if (l &gt;= r) return  //在l~r范围中随机取一个数和r位置的数交换  swap(arr, r, l + Math.floor(Math.random() * (r - l + 1)))  const part = partition(arr, l, r)  quickSortProcess(arr, l, part[0] - 1)  quickSortProcess(arr, part[1] + 1, r)&#125;function quickSort(arr) &#123;  if (!Array.isArray(arr) || arr.length &lt; 2) return  let l = 0  let r = arr.length - 1  quickSortProcess(arr, l, r)&#125;testSort(quickSort) //排序成功\n\n是目前基于比较的内部排序中被认为最好的方法，当数据过大且数据杂乱无章时，则适合采用快速排序。\n堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。（小顶堆或大顶堆，下面代码中使用的是大顶堆）\n算法的时间复杂度为O(n*log n)、额外空间复杂度为O(1)。\nfunction parentIndex(index) &#123;  if (!index) return index  return Math.floor((index - 1) / 2)&#125;//比父节点大则与父节点交换function heapInsert(arr, index) &#123;  while (arr[index] &gt; arr[parentIndex(index)]) &#123;    swap(arr, index, parentIndex(index))    index = parentIndex(index)  &#125;&#125;//比两个子节点中最大的一个小，则与其交换function heapify(arr, index, heapSize) &#123;  let left = index * 2 + 1  while (left &lt; heapSize) &#123;    let max = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left    max = arr[index] &lt; arr[max] ? max : index    if (max === index) break    swap(arr, index, max)    index = max    left = index * 2 + 1  &#125;&#125;function heapSort(arr) &#123;  let heapSize = arr.length  //生成大根堆（父节点大于子节点）,该循环时间复杂度为O(n*log n)  for (let i = 0; i &lt; heapSize; i++) &#123;    heapInsert(arr, i)  &#125;  //该循环时间复杂度为O(n*log n)  while (heapSize) &#123;    swap(arr, 0, --heapSize)    heapify(arr, 0, heapSize)  &#125;&#125;testSort(heapSort) //排序成功\n\n优化写法：（优化前一个循环：只需要使用heapify方法即可将一个数组转化为堆结构，且时间复杂度为O(n)）\nfunction heapSort(arr) &#123;  let heapSize = arr.length  //该循环时间复杂度为O(n)  for (let i = heapSize - 1; i &gt;= 0; i--) &#123;    heapify(arr, i, heapSize)  &#125;  while (heapSize) &#123;    swap(arr, 0, --heapSize)    heapify(arr, 0, heapSize)  &#125;&#125;testSort(heapSort) //排序成功\n\n稳定性假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]&#x3D;r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。\n\n不稳定的排序算法：选择排序、快速排序、堆排序等\n稳定的排序算法：冒泡排序、插入排序、归并排序等\n\n目前没有发现时间复杂度为O(n*log n)、额外空间复杂度低于O(n)且具有稳定性的排序算法。\n一般情况下，快速排序更常用，因为其常数项时间更低。额外空间要求很少时使用堆排序；要求稳定性时使用归并排序。\n还可以使用综合排序的方法提高效率。（比如在快排过程中的一些样本量比较少的步骤中使用插入排序）\n","categories":["算法"],"tags":["选择排序","冒泡排序","插入排序","归并排序","快速排序","堆排序"]},{"title":"数据可视化","url":"/2022/03/20/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/","content":"canvascanvas基本使用canvas标签\n &lt;!--canvas：画布，html5新增--&gt;&lt;!--有默认宽高：300 * 150--&gt;&lt;!--浏览器默认canvas标签是一张图片--&gt;&lt;!--给canvas添加文本和子节点无效--&gt;&lt;!--需要通过js操作画布显示内容--&gt;&lt;!--不要通过样式设置canvas的宽高，而通过标签的属性来设置--&gt;&lt;canvas width=&quot;500px&quot; height=&quot;300px&quot;&gt;&lt;/canvas&gt;\n\n通过js操作canvas\nlet canvas = document.querySelector(&#x27;canvas&#x27;)// 获取画布上下文let ctx = canvas.getContext(&#x27;2d&#x27;)// 绘制线段(起点)ctx.moveTo(100, 200)ctx.lineTo(200, 250)//终点（第二个点）ctx.lineTo(150, 300)//第三点ctx.closePath()//连接起点和第三个点ctx.fillStyle = &#x27;red&#x27;//设置填充的颜色ctx.fill()//填充ctx.strokeStyle = &#x27;blue&#x27;//设置线段颜色ctx.lineWidth = &#x27;5&#x27;//设置线段宽度ctx.stroke()//画出线/三角形边框\n\n绘制矩形const canvas = document.querySelector(&#x27;canvas&#x27;)const ctx = canvas.getContext(&#x27;2d&#x27;)//绘制矩形：参数为 左上点坐标和宽高ctx.strokeRect(100,200,300,100)//填充矩形：默认黑色ctx.fillRect(100,400,300,100)\n\n绘制圆形const canvas = document.querySelector(&#x27;canvas&#x27;)const ctx = canvas.getContext(&#x27;2d&#x27;)//开始绘制圆形ctx.beginPath()//画圆:arc(x,y,r,sAngle,eAngle,counterclockwise);//x,y:圆心，r：半径，sAngle：起始弧度，eAngle：结束弧度，(0到2PI绘制一个完整的圆)//counterclockwise：可选。规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针。ctx.arc(300, 200, 100, 0, 2 * Math.PI)//设置填充颜色ctx.fillStyle = &#x27;red&#x27;ctx.fill()//完成绘制ctx.stroke()\n\n清除画布与绘制文字const canvas = document.querySelector(&#x27;canvas&#x27;)const ctx = canvas.getContext(&#x27;2d&#x27;)ctx.fillRect(200,100,300,200)//清除画布(一个矩形范围内)ctx.clearRect(0,0,700,500)//设置字体ctx.font=&#x27;20px 微软雅黑&#x27;ctx.fillStyle=&#x27;red&#x27;//文字颜色//绘制文字(参数：文本内容和起始位置)ctx.fillText(&#x27;数据可视化&#x27;,50,20)\n\nsvg基本使用&lt;!--默认宽高：300*150,可通过样式设置宽高--&gt;&lt;!--在svg内部使用相应的标签绘图--&gt;&lt;svg class=&quot;box&quot;&gt;  &lt;!--画线:属性包括两点的坐标，stroke：线的颜色（必选），stroke-width：线的宽度--&gt;  &lt;line x1=&quot;100&quot; y1=&quot;100&quot; x2=&quot;200&quot; y2=&quot;300&quot; stroke=&quot;red&quot; stroke-width=&quot;5&quot;&gt;&lt;/line&gt;  &lt;!--折线：points：各个点的坐标--&gt;  &lt;!--会自动填充颜色（黑色），fill-opacity：填充颜色透明度--&gt;  &lt;polyline points=&quot;300 300,50 100,120 400&quot; stroke=&quot;green&quot; fill-opacity=&quot;0&quot;&gt;&lt;/polyline&gt;  &lt;!--矩形：默认填充黑色,fill:设置填充颜色--&gt;  &lt;rect x=&quot;400&quot; y=&quot;200&quot; width=&quot;150&quot; height=&quot;50&quot; fill=&quot;pink&quot;&gt;&lt;/rect&gt;  &lt;!--圆形：自动填充黑色，style：设置样式，r：半径，cx、cy：圆心坐标--&gt;  &lt;circle r=&quot;50&quot; cx=&quot;100&quot; cy=&quot;100&quot; style=&quot;stroke: skyblue;fill: none&quot;&gt;&lt;/circle&gt;  &lt;!--椭圆：rx：水平半径，ry：垂直半径--&gt;  &lt;ellipse rx=&quot;100&quot; ry=&quot;50&quot; cx=&quot;400&quot; cy=&quot;400&quot; style=&quot;stroke: skyblue;fill: none&quot;&gt;&lt;/ellipse&gt;  &lt;!--多边形--&gt;  &lt;polygon points=&quot;300 100,400 200,350 300&quot; stroke=&quot;blue&quot; fill=&quot;none&quot;&gt;&lt;/polygon&gt;  &lt;!--任意图形--&gt;  &lt;!--d:M:起点，L：线终点，Z：连接起点--&gt;  &lt;path d=&quot;M 10 10 L 120 70 L 30 140 L 60 340 L 432 110 Z&quot; fill=&quot;none&quot; stroke=&quot;red&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n\nEChartsECharts官网\n引入ECharts&lt;!--引入ECharts--&gt;&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/echarts/5.3.1/echarts.min.js&quot;&gt;&lt;/script&gt;\n\nimport引入：\nimport * as echarts from &#x27;echarts&#x27;\n\n基本使用&lt;!--准备一个容器--&gt;&lt;div style=&quot;width: 800px;height: 500px&quot; id=&quot;main&quot;&gt;&lt;/div&gt;\n\n初始化echarts实例：\nconst myCharts = echarts.init(document.getElementById(&#x27;main&#x27;));\n\n绘制柱状图\nmyCharts.setOption(&#123;  //标题  title:&#123;    text:&#x27;数据可视化&#x27;,//主标题    subtext:&#x27;echarts基本使用&#x27;,//副标题    textAlign:&#x27;center&#x27;,//居中对齐    left:&#x27;center&#x27;,//title 组件离容器左侧的距离。  &#125;,  //x轴配置  xAxis:&#123;    //数据    data:[&#x27;衣服&#x27;,&#x27;食品&#x27;,&#x27;游戏&#x27;,&#x27;电影&#x27;],  &#125;,  //y轴配置  yAxis: &#123;    axisLine:&#123;//线      show:true    &#125;,    axisTick:&#123;//刻度      show:true    &#125;  &#125;,  //系列的设置：图表的类型和数据  series:[    &#123;      //图标类型      type:&#x27;bar&#x27;,//bar：柱状图，line：折线图      data:[10,30,40,20],//数据      color:&#x27;pink&#x27;,//颜色    &#125;  ]&#125;)\n\n一个容器显示多个图表在series中配置多个图表\nseries: [      &#123;        //图标类型        type: &#x27;bar&#x27;,//bar：柱状图，line：折线图        data: [10, 30, 40, 20],//数据        color: &#x27;pink&#x27;,//颜色      &#125;,      &#123;        type: &#x27;line&#x27;,        data: [10, 30, 40, 20],//数据        color: &#x27;gray&#x27;      &#125;,      &#123;        type: &#x27;pie&#x27;,//pie:饼图        data: [&#123;name: &#x27;衣服&#x27;, value: 10&#125;, &#123;name: &#x27;食品&#x27;, value: 30&#125;, &#123;name: &#x27;游戏&#x27;, value: 40&#125;, &#123;name: &#x27;电影&#x27;, value: 20&#125;],        width: 300,//包括文字内容的大小范围        height: 150,        left: 500,//距离左侧的距离        radius: 50,//半径      &#125;    ]\n\ndataset数据集准备数据集（二维数组）\n//数据集const data = [  [&#x27;衣服&#x27;, 10, 20, &#x27;饮料&#x27;, 22],  [&#x27;食品&#x27;, 30, 10, &#x27;电器&#x27;, 44],  [&#x27;游戏&#x27;, 40, 40, &#x27;小说&#x27;, 11],  [&#x27;电影&#x27;, 20, 30, &#x27;音乐&#x27;, 33],]\n\n在echarts的配置对象中设置字符集\n//设置字符集dataset:&#123;  //数据源  source:data,&#125;,\n\nxxxxxxxxxx26 1&#x2F;&#x2F;序列化2var serialize &#x3D; function (root) {3  if (!root) return ‘#‘4  let result &#x3D; root.val + ‘‘5  result +&#x3D; serialize(root.left)6  result +&#x3D; serialize(root.right)7  return result8};9​10&#x2F;&#x2F;反序列化11var deserialize &#x3D; function (data) {12  const arr &#x3D; data.split(‘_’)13​14  function createTree(arr) {15    const val &#x3D; arr.shift()16    if (val &#x3D;&#x3D;&#x3D; ‘#’) {17      return null18    }19    const head &#x3D; new TreeNode(val)20    head.left &#x3D; createTree(arr)21    head.right &#x3D; createTree(arr)22    return head23  }24​25  return createTree(arr)26};js\nseries: [  &#123;    //图标类型    type: &#x27;bar&#x27;,//bar：柱状图，line：折线图    // data: [10, 30, 40, 20],//数据    color: &#x27;pink&#x27;,//颜色    encode: &#123;      x: 0,      y: 1,    &#125;  &#125;,  &#123;    type: &#x27;line&#x27;,    // data: [10, 30, 40, 20],//数据    color: &#x27;gray&#x27;,    encode: &#123;      x: 0,      y: 2,    &#125;  &#125;,  &#123;    type: &#x27;pie&#x27;,//pie:饼图    // data: [&#123;name: &#x27;衣服&#x27;, value: 10&#125;, &#123;name: &#x27;食品&#x27;, value: 30&#125;, &#123;name: &#x27;游戏&#x27;, value: 40&#125;, &#123;name: &#x27;电影&#x27;, value: 20&#125;],    width: 300,//包括文字内容的大小范围    height: 150,    left: 500,//距离左侧的距离    radius: 50,//半径    encode: &#123;      //饼图旁边的文字      itemName: 3,      value: 4,    &#125;  &#125;]\n\n组件提示组件//提示组件(鼠标悬浮时显示)tooltip:&#123;  textStyle:&#123;    //文字颜色    color:&#x27;red&#x27;  &#125;&#125;\n\n系列切换组件给图表添加name属性\nseries: [  &#123;    name:&#x27;柱状图&#x27;,    type: &#x27;bar&#x27;,    encode: &#123;      x: 0,      y: 1,    &#125;  &#125;,  &#123;    name:&#x27;折线图&#x27;,    type: &#x27;line&#x27;,    encode: &#123;      x: 0,      y: 2,    &#125;  &#125;,],//系列切换组件legend:&#123;  data:[&#x27;柱状图&#x27;,&#x27;折线图&#x27;],  right: &#x27;20%&#x27;&#125;\n\n工具栏组件// 工具栏组件toolbox: &#123;  show: true,  feature: &#123;    dataZoom: &#123;      yAxisIndex: &quot;none&quot;    &#125;,    dataView: &#123;      readOnly: false    &#125;,    magicType: &#123;      type: [&quot;line&quot;, &quot;bar&quot;]    &#125;,    restore: &#123;&#125;,    saveAsImage: &#123;&#125;  &#125;&#125;,\n\n双坐标两个x轴\nmyCharts.setOption(&#123;  title: &#123;    text: &#x27;echarts坐标系&#x27;,    left: &#x27;center&#x27;,    textAlign: &#x27;center&#x27;,  &#125;,  //多个坐标系，使用数组  xAxis: [    &#123;      data: [&#x27;衣服&#x27;, &#x27;食品&#x27;, &#x27;游戏&#x27;, &#x27;电影&#x27;],    &#125;,    &#123;&#125;,  ],  yAxis: &#123;&#125;,  series: [    &#123;      type: &#x27;scatter&#x27;,//散点图      data: [        [11, 87],        [34, 45],        [64, 23],        [43, 54],        [12, 40],      ],      xAxisIndex: 1,//使用第二个x轴    &#125;,    &#123;      type: &#x27;bar&#x27;,      data: [10, 30, 40, 20],      xAxisIndex: 0,//使用第一个x轴    &#125;  ]&#125;)\n","categories":["数据可视化"],"tags":["Echarts","canvas","svg"]},{"title":"链表","url":"/2022/05/16/%E9%93%BE%E8%A1%A8/","content":"单链表反转function Node(value, next) &#123;  this.value = value  this.next = next&#125;const n1 = new Node(1)n1.next = new Node(2)n1.next.next = new Node(3)function reverse(head) &#123;  let pre = null  let next = null  while (head) &#123;    next = head.next    head.next = pre    pre = head    head = next  &#125;  return pre&#125;let n2 = reverse(n1)while (n2) &#123;  console.log(n2.value) //3 2 1  n2 = n2.next&#125;\n\n双向链表反转function DoubleNode(value,last,next)&#123;  this.value = value  this.last = last  this.next = next&#125;let n1 = new DoubleNode(1,null)n1.next = new DoubleNode(2,n1)n1.next.next = new DoubleNode(3,n1.next)function reverseDouble(head)&#123;  let pre = null  let next = null  while (head)&#123;    next = head.next    head.next = pre    head.last = next    pre = head    head = next  &#125;  return pre&#125;\n\nK 个一组翻转链表leetcode上的题目： K 个一组翻转链表\nvar reverseKGroup = function(head, k) &#123;  let start = head  let end = getGroupEnd(start,k)  if(!end)&#123;    return start  &#125;  head = end  reverse(start,end)  let lastEnd = start  while(start.next)&#123;    start = start.next    end = getGroupEnd(start,k)    if(!end)&#123;      return head    &#125;    reverse(start,end)    lastEnd.next = end    lastEnd = start  &#125;  return head&#125;;function getGroupEnd(start,k)&#123;  while(--k &gt; 0 &amp;&amp; start)&#123;    start = start.next  &#125;  return start&#125;function reverse(start,end)&#123;  let cur = start  let pre = null  let next = null  while(start !== end)&#123;    next = start.next    start.next = pre    pre = start    start = next  &#125;  next = start.next  start.next = pre  cur.next = next&#125;\n\n有序链表合并leetcode上的题目：合并两个有序链表\nvar mergeTwoLists = function (list1, list2) &#123;  if (!list1 || !list2) &#123;    return list1 ? list1 : list2  &#125;  let head = list1.val &lt; list2.val ? list1 : list2  let cur1 = head.next  let cur2 = head === list1 ? list2 : list1  let pre = head  while (cur1 &amp;&amp; cur2) &#123;    if (cur1.val &lt; cur2.val) &#123;      pre.next = cur1      cur1 = cur1.next    &#125; else &#123;      pre.next = cur2      cur2 = cur2.next    &#125;    pre = pre.next  &#125;  pre.next = cur1 ? cur1 : cur2  return head&#125;;\n\n快慢指针快慢指针：快指针每次沿链表向前移动2，慢指针每次向前移动1次。\n应用：判断单链表是否为回文链表：（leetcode上的题目：回文链表）\n思路：遍历链表，将值拷贝到一个栈中；再次遍历链表，对比每次出栈的值是否相同即可。\n优化：使用快慢指针，在遍历到一半时开始进行比较即可，节省一半的额外空间。\nvar isPalindrome = function(head) &#123;  if(!head || !head.next) return true  let fast = head  let slow = head  const stack = []  while(fast &amp;&amp; fast.next)&#123;    stack.push(slow.val)    fast = fast.next.next    slow = slow.next  &#125;  if(fast) slow = slow.next  while(slow)&#123;    if(stack.pop() !== slow.val) return false    slow = slow.next  &#125;  return true&#125;;\n\n继续优化：只使用O(1)的额外空间复杂度，慢指针在走的过程中将前半部分的链表反转\nvar isPalindrome = function(head) &#123;  if(!head || !head.next) return true  let fast = head,slow = head,cur = head  let pre = null  while(fast &amp;&amp; fast.next)&#123;    fast = fast.next.next    slow = slow.next    cur.next = pre    pre = cur    cur = slow  &#125;  if(fast) slow = slow.next  while(slow)&#123;    if(slow.val !== pre.val) return false    slow = slow.next    pre = pre.next  &#125;  return true&#125;;\n\n注：上面未将链表的反转部分还原\n环形链表leetcode上的题目：环形链表 II\n返回链表开始入环的第一个节点，如果链表无环，则返回 null。\nvar detectCycle = function(head) &#123;  if(!head || !head.next || !head.next.next) return null  let fast = head.next.next, slow = head.next  while(fast !== slow)&#123;    fast = fast.next?.next    slow = slow.next    if(!fast) return null  &#125;  fast = head  while(fast !== slow)&#123;    fast = fast.next    slow = slow.next  &#125;  return slow&#125;;\n\n假设环外有a个节点，环内有b个节点，则第a+nb个节点一定是入口节点。使用快慢指针判断有环无环，快慢指针相遇时在第nb个节点，再走a步即可。\n","categories":["数据结构"],"tags":["链表"]},{"title":"防抖节流","url":"/2022/03/09/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/","content":"防抖function debounce(fn, duration = 500) &#123;//自定义防抖函数,默认0.5秒内没有再次触发该函数时执行    let timer    return function (...args) &#123;        timer &amp;&amp; clearTimeout(timer)        timer = setTimeout(() =&gt; &#123;            typeof fn === &#x27;function&#x27; &amp;&amp; fn.apply(this, args)        &#125;, duration)    &#125;&#125;const input = document.getElementById(&#x27;input&#x27;)input.addEventListener(&#x27;input&#x27;, debounce(event =&gt; &#123;    console.log(event.target.value)&#125;));\n\n节流function throttle(fn, duration = 1000) &#123; //自定义节流函数，1秒内只触发一次    let time = 0    return function (...args) &#123;        if (new Date() - time &gt; duration) &#123;            typeof fn === &#x27;function&#x27; &amp;&amp; fn.apply(this, args)            time = new Date()        &#125;    &#125;&#125;const btn = document.getElementById(&#x27;btn&#x27;)btn.addEventListener(&#x27;click&#x27;, throttle(event =&gt; &#123;    console.log(event.target.innerText)&#125;));\n\n","categories":["JavaScript","手写"],"tags":["JavaScript"]},{"title":"css高级","url":"/2022/07/27/css%E9%AB%98%E7%BA%A7/","content":"样式初始化/* 样式初始化 */* &#123;  /* 清除默认的外边框和内边框 */  margin: 0;  padding: 0;  /* 统一盒子模型 */  box-sizing: border-box;&#125;/* 和字体相关的样式写在body中,因为默认会被继承 */body &#123;  font-family: &#x27;Lato&#x27;, sans-serif;  font-weight: 400;  font-size: 16px;  /* 当前字体尺寸的1.7倍 */  line-height: 1.7;  color: #777;    padding: 30px;&#125;\n\n背景图&#x2F;裁剪区域html文件中导入样式文件，并准备一个容器。\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;!-- Lato字体 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;http://fonts.googleapis.com/css?family=Lato:100,300,400,700,900&quot; /&gt;    &lt;!-- 基础样式 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;style/style.css&quot; /&gt;    &lt;!-- 页面图标 --&gt;    &lt;link rel=&quot;shortcut icon&quot; href=&quot;img/favicon.ico&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;header class=&quot;header&quot;&gt;header content...&lt;/header&gt;  &lt;/body&gt;&lt;/html&gt;\n\n.header &#123;  height: 95vh;  /* 可指定多个背景图 */  /* linear-gradient函数用于创建一个颜色线性渐变的图片*/  /* url指定图片路径 */  background-image: linear-gradient(      to right bottom,      rgba(126, 213, 111, 0.8),      rgba(40, 180, 131, 0.8)    ),    url(../img/background.png);  /* 保持图像的纵横比并完全覆盖背景区域 */  background-size: cover;  /* 窗口缩放时图片顶部保持不动 */  background-position: top;  /* clip-path:指定元素的可视区域 */  /* polygon函数用于创建一个多边形,从右上角开始顺时针指定顶点 */  clip-path: polygon(0 0, 100% 0, 100% 80%, 0 100%);&#125;\n\n","categories":["css"],"tags":["css","style"]},{"title":"发布npm包","url":"/2022/08/06/%E5%8F%91%E5%B8%83npm%E5%8C%85/","content":"注册账号\n在npm官网注册\n\n登录账号（需要npm镜像源为npm官方源）\nnpm config get registry //查看当前镜像源nrm use npm //使用npm官方镜像源（如果安装了nrm）npm config set registry https://registry.npmjs.org/ //使用npm官方镜像npm login //登录（输入账号密码、邮箱和验证码）npm adduser //效果同上\n\n查看当前账号\nnpm whoami\n\npackage.jsonname和version是必须的\n&#123;  &quot;name&quot;: &quot;xxx&quot;,  //包名（要避免与npm上已有的包重名）  &quot;version&quot;: &quot;0.0.1&quot;, //版本号  //&quot;private&quot;: true, //为true时，npm将拒绝发布该程序包  &quot;type&quot;: &quot;module&quot;, //使用es模块加载（默认值为commonjs）  &quot;keywords&quot;: [], //关键词  &quot;repository&quot;: &#123; //关联的远程仓库    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;https://github.com/xxx/xxx.git&quot; //远程仓库url  &#125;,  &quot;files&quot;: [ //指定要发布的文件夹或文件（默认发布所有文件，package.json始终会被发布）    &quot;dist&quot;  ],  &quot;main&quot;: &quot;./dist/xxx.umd.js&quot;, //指定通过name被导入时的入口文件  &quot;module&quot;: &quot;./dist/xxx.es.js&quot;, //指定通过name被es模块导入时的入口文件  &quot;types&quot;: &quot;./dist/types/index.d.ts&quot;, //类型声明文件  &quot;exports&quot;: &#123; //定义导出的内容（main和module的替代品）    &quot;.&quot;: &#123;      &quot;types&quot;: &quot;./dist/types/index.d.ts&quot;,      &quot;import&quot;: &quot;./dist/icons.es.js&quot;,      &quot;require&quot;: &quot;./dist/icons.umd.js&quot;    &#125;  &#125;,  &quot;license&quot;: &quot;MIT&quot; //开源协议&#125;\n\n发布\n发布前需切换至官方镜像源\nnpm publish// 再次发布前需要将version版本号加一\n\n当发布name以@开头的包时，npm默认发布私有包（私有包需要收费），使用如下命令发布为公开包\nnpm publish --access public\n\n发布beta版本（修改version，如0.0.1-beta.1）\nnpm publish --tag=beta\n\n发布成功后登录npm官网即可看到自己发布的包\n\n\n作废和撤销\n作废npm包，表示不在维护更新\nnpm deprecate &lt;package-name&gt; &quot;&lt;message&gt;&quot;\n\n撤销发布包（只能删除24小时内发布的最后一个版本）\nnpm unpublish &lt;package-name&gt; --force\n\n","categories":["前端工程化"],"tags":["npm","package.json"]},{"title":"js继承","url":"/2022/10/17/js%E7%BB%A7%E6%89%BF/","content":"原型链继承function Parent () &#123;  this.name = &#x27;kevin&#x27;;&#125;Parent.prototype.getName = function () &#123;  console.log(this.name);&#125;function Child () &#123;&#125;// 子类的原型指向父类的实例Child.prototype = new Parent();var child1 = new Child();console.log(child1.getName()) // kevin\n\n缺点：\n\n引用（对象）类型的属性被所有实例共享\nfunction Parent () &#123;  this.names = [&#x27;kevin&#x27;, &#x27;daisy&#x27;];&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();child1.names.push(&#x27;yayu&#x27;);console.log(child1.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]var child2 = new Child();console.log(child2.names); // [&quot;kevin&quot;, &quot;daisy&quot;, &quot;yayu&quot;]\n\n在创建 Child 的实例时，不能向Parent传参\n\n\n构造函数继承function Parent (name) &#123;  this.names = [name, &#x27;daisy&#x27;];&#125;function Child (name) &#123;  // 调用父类构造函数  Parent.call(this, name);&#125;var child1 = new Child(&#x27;kevin1&#x27;);child1.names.push(&#x27;yayu&#x27;);console.log(child1.names); // [&quot;kevin1&quot;, &quot;daisy&quot;, &quot;yayu&quot;]var child2 = new Child(&#x27;kevin2&#x27;);console.log(child2.names); // [&quot;kevin2&quot;, &quot;daisy&quot;]\n\n优点：\n\n避免了引用（对象）类型的属性被所有实例共享\n\n可以在 Child 中向 Parent 传参\n\n\n缺点：只能继承父类的实例属性和方法，不能继承原型属性或者方法。\n组合继承融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。\nfunction Parent (name) &#123;  this.name = name;  this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];&#125;Parent.prototype.getName = function () &#123;  console.log(this.name)&#125;function Child (name, age) &#123;  Parent.call(this, name); // 第二次调用父构造函数  this.age = age;&#125;Child.prototype = new Parent(); // 第一次调用父构造函数Child.prototype.constructor = Child; // 修改为正确的constructor指向var child1 = new Child(&#x27;kevin&#x27;, &#x27;18&#x27;);child1.colors.push(&#x27;black&#x27;);console.log(child1.name); // kevinconsole.log(child1.age); // 18console.log(child1.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]var child2 = new Child(&#x27;daisy&#x27;, &#x27;20&#x27;);console.log(child2.name); // daisyconsole.log(child2.age); // 20console.log(child2.colors); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]\n\n缺点：会调用两次父构造函数。所以，在上述例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为colors，属性值为[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]。\n原型式继承就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。\nfunction createObj(o) &#123;  function F()&#123;&#125;  F.prototype = o;  return new F();&#125;\n\n缺点：因为Object.create方法实现的是浅拷贝，多个实例的引用类型属性指向相同的内存，存在篡改的可能。\nvar person = &#123;  name: &#x27;kevin&#x27;,  friends: [&#x27;daisy&#x27;, &#x27;kelly&#x27;]&#125;var person1 = createObj(person);var person2 = createObj(person);person1.name = &#x27;person1&#x27;;console.log(person2.name); // kevinperson1.friends.push(&#x27;taylor&#x27;);console.log(person2.friends); // [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]\n\n注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = &#39;person1&#39;，给person1添加了 name 值，并非修改了原型上的 name 值。\n寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。\nfunction createObj (o) &#123;  var clone = Object.create(o);  clone.sayName = function () &#123;    console.log(&#x27;hi&#x27;);  &#125;  return clone;&#125;\n\n缺点：跟上面讲的原型式继承一样。\n寄生组合式继承function Parent (name) &#123;  this.name = name;  this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];&#125;Parent.prototype.getName = function () &#123;  console.log(this.name)&#125;function Child (name, age) &#123;  Parent.call(this, name);  this.age = age;&#125;// 关键的三步var F = function () &#123;&#125;;F.prototype = Parent.prototype;Child.prototype = new F();// 上面三步相当于// Child.prototype = Object.create(Parent.prototype)Child.prototype.constructor = Childvar child1 = new Child(&#x27;kevin&#x27;, &#x27;18&#x27;);console.log(child1);\n\n优点：只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。\nclass继承利用babel工具进行转换，我们会发现extends实际采用的也是寄生组合继承方式。\nclass Animal &#123;  constructor(name) &#123;    this.name = name;  &#125;  hello() &#123;    console.log(&quot;hello&quot;);  &#125;&#125;class Dog extends Animal &#123;  constructor(name, say) &#123;    super(name); // 通过super调用父构造函数    this.say = say;  &#125;&#125;\n\n\n\n参考\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"层叠上下文","url":"/2022/10/17/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/","content":"层叠上下文我们假定用户正面向（浏览器）视窗或网页，而 HTML 元素沿着其相对于用户的一条虚构的 z 轴排开，层叠上下文就是对这些 HTML 元素的一个三维构想。众 HTML 元素基于其元素属性按照优先级顺序占据这个空间。\n层叠水平\n层叠水平决定了同一个层叠上下文中元素在z轴上的显示顺序。\n\n普通元素的层叠水平优先由层叠上下文决定，因此，层叠水平的比较只有在当前层叠上下文元素中才有意义。\n\n\n注意：千万不要把层叠水平和CSS的z-index属性混为一谈。某些情况下z-index确实可以影响层叠水平，但是，只限于定位元素以及flex盒子的孩子元素；而层叠水平所有的元素都存在。\n层叠顺序元素发生层叠时候有着特定的垂直显示顺序，层叠顺序从小到大如下：\n\nbackground &#x2F; border\n负z-index\nblock块级水平盒子\nfloat浮动盒子\ninline &#x2F; inline-block水平盒子\nz-index: auto &#x2F; z-index: 0 &#x2F; 不依赖z-index的层叠上下文\n正z-index\n\n生成层叠上下文\nHTML中的根元素&lt;html&gt;&lt;/html&gt;本身就具有层叠上下文，称为“根层叠上下文”；\n普通元素设置position属性为非static值并设置z-index属性为具体数值，产生层叠上下文；\n父元素的display属性值为flex|inline-flex|grid，子元素z-index属性值不为auto的时候，子元素为层叠上下文元素；\n元素的opacity属性值不是1；\n以下任意属性值不为none的元素：\ntransform\nfilter\nbackdrop-filter\nperspective\nclip-path\nmask &#x2F; mask-image &#x2F; mask-border\n\n\n元素mix-blend-mode属性值不是normal；\n元素的isolation属性值是isolate；\nwill-change指定的属性值为上面任意一个；\n元素的-webkit-overflow-scrolling属性值设置为touch。\n\n层叠上下文的特点\n谁大谁上：当具有明显的层叠水平标示的时候，如识别的z-indx值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。通俗讲就是官大的压死官小的。\n后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。\n在层叠上下文中，子元素同样也按照上面解释的规则进行层叠。重要的是，其子级层叠上下文的 z-index 值只在父级中才有意义。子级层叠上下文被自动视为父级层叠上下文的一个独立单元。\n层叠上下文可以包含在其他层叠上下文中，并且一起创建一个层叠上下文的层级。\n每个层叠上下文都完全独立于它的兄弟元素：当处理层叠时只考虑子元素。\n每个层叠上下文都是自包含的：当一个元素的内容发生层叠后，该元素将被作为整体在父级层叠上下文中按顺序进行层叠。\n\n总结\n先看要比较的两个元素是否处于同一个层叠上下文中。如果是，谁的层叠水平大，谁在上面。 \n如果两个元素不在同一层叠上下文中，请先比较他们所处的层叠上下文的层叠水平。 当两个元素层叠水平相同、层叠顺序相同时，在DOM结构中后面的元素层叠等级在前面元素之上。\n\n参考\n","categories":["css"],"tags":["css","z-index"]},{"title":"块级格式化上下文","url":"/2022/10/18/%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/","content":"BFC的概念块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。\n通俗理解\nBFC 是一个独立的布局环境,可以理解为一个容器,在这个容器中按照一定规则进行物品摆放,并且不会影响其它环境中的物品。\n如果一个元素符合触发 BFC 的条件，则 BFC 中的元素布局不受外部影响。\n浮动元素会创建 BFC，则浮动元素内部子元素主要受该浮动元素影响，所以两个浮动元素之间是互不影响的。\n\n生成BFC\n根元素或包含根元素的元素\n浮动元素 float ＝ left | right | inherit（≠ none）\n绝对定位元素 position ＝ absolute 或 fixed\ndisplay ＝ inline-block | flex | inline-flex | table-cell | table-caption\noverflow ＝ hidden | auto | scroll (≠ visible)\n\nBFC的特性\nBFC 是一个独立的容器，容器内子元素不会影响容器外的元素。反之亦如此。\n盒子从顶端开始垂直地一个接一个地排列，盒子之间垂直的间距是由 margin 决定的。\n在同一个 BFC 中，两个相邻的块级盒子的垂直外边距会发生重叠。\nBFC 区域不会和 float box 发生重叠。\nBFC 能够识别并包含浮动元素，当计算其区域的高度时，浮动元素也可以参与计算了。\n\nBFC的作用清除浮动\n浮动元素会脱离文档流(绝对定位元素也会脱离文档流)，导致无法计算准确的高度，这种问题称为高度塌陷。\n解决高度塌陷问题的前提是能够识别并包含浮动元素，也就是清除浮动。\n\n清除方法：创建BFC\n&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;Sibling&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;Sibling&quot;&gt;&lt;/div&gt;&lt;/div&gt;\n\n.container &#123;   overflow: hidden; /* 生成BFC */  background-color: green; &#125; .container .Sibling &#123;   float: left;   margin: 10px;  background-color: lightgreen;  &#125;\n\n注意：通过 overflow: hidden 创建 BFC，固然可以解决高度塌陷的问题，但是大范围应用在布局上肯定不是最合适的，毕竟 overflow: hidden 会造成溢出隐藏的问题，尤其是与 JS 的交互效果会有影响。\n改进：使用clear: both\n&lt;div class=&quot;container clearfix&quot;&gt;  &lt;div class=&quot;Sibling&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;Sibling&quot;&gt;&lt;/div&gt;&lt;/div&gt;\n\n.container &#123;   background-color: green; &#125; .container .Sibling &#123;   float: left;   margin: 10px;  background-color: lightgreen;  &#125;.clearfix::after &#123;  content: &quot;&quot;;  display: block;  clear: both; // 清除浮动&#125;\n\n避免外边距折叠外边距折叠（Margin collapsing）只会发生在属于同一BFC的块级元素之间。如果它们属于不同的 BFC，它们之间的外边距则不会折叠。所以通过创建一个不同的 BFC ，就可以避免外边距折叠。\n参考\n","categories":["css"],"tags":["css","BFC"]},{"title":"闭包与作用域","url":"/2022/10/20/%E9%97%AD%E5%8C%85%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/","content":"闭包一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。\n也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。\nfunction init() &#123;    var name = &quot;Mozilla&quot;; // name 是一个被 init 创建的局部变量    function displayName() &#123; // displayName() 是内部函数，一个闭包        alert(name); // 使用了父函数中声明的变量    &#125;    displayName();&#125;init();\n\ndisplayName() 没有自己的局部变量。然而，由于闭包的特性，它可以访问到外部函数的变量\n作用\n创建私有变量\n延长变量的生命周期\n\n\n一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的。\n\n柯里化函数柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用。\n// 使用闭包柯里化一个计算矩形面积的函数function getArea(width) &#123;  return height =&gt; &#123;    return width * height  &#125;&#125;getArea(10)(20) // 200\n\n模拟私有方法在JavaScript中，没有支持声明私有变量，但我们可以使用闭包来模拟私有方法\nvar Counter = (function() &#123;  var privateCounter = 0;  function changeBy(val) &#123;    privateCounter += val;  &#125;  return &#123;    increment: function() &#123;      changeBy(1);    &#125;,    decrement: function() &#123;      changeBy(-1);    &#125;,    value: function() &#123;      return privateCounter;    &#125;  &#125;&#125;)();var Counter1 = makeCounter();var Counter2 = makeCounter();console.log(Counter1.value()); /* logs 0 */Counter1.increment();Counter1.increment();console.log(Counter1.value()); /* logs 2 */Counter1.decrement();console.log(Counter1.value()); /* logs 1 */console.log(Counter2.value()); /* logs 0 */\n\n上述通过使用闭包来定义公共函数，并令其可以访问私有函数和变量，这种方式也叫模块方式。\n两个计数器 Counter1 和 Counter2 是维护它们各自的独立性的，每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境，不会影响另一个闭包中的变量。\n注意如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。\n作用域作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合。\n换句话说，作用域决定了代码区块中变量和其他资源的可见性。\n我们在全局是无法获取到（闭包除外）函数内部的变量。\n我们一般将作用域分成：\n\n全局作用域\n函数作用域\n块级作用域\n\n全局作用域任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问\n// 全局变量var greeting = &#x27;Hello World!&#x27;;function greet() &#123;  console.log(greeting);&#125;// 打印 &#x27;Hello World!&#x27;greet();\n\n函数作用域函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问。\nfunction greet() &#123;  var greeting = &#x27;Hello World!&#x27;;  console.log(greeting);&#125;// 打印 &#x27;Hello World!&#x27;greet();// 报错： Uncaught ReferenceError: greeting is not definedconsole.log(greeting);\n\n可见上述代码中在函数内部声明的变量或函数，在函数外部是无法访问的，这说明在函数内部定义的变量或者方法只是函数作用域。\n块级作用域ES6引入了let和const关键字,和var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量。\n&#123;  // 块级作用域中的变量  let greeting = &#x27;Hello World!&#x27;;  var lang = &#x27;English&#x27;;  console.log(greeting); // Prints &#x27;Hello World!&#x27;&#125;// 变量 &#x27;English&#x27;console.log(lang);// 报错：Uncaught ReferenceError: greeting is not definedconsole.log(greeting);\n\n词法作用域词法作用域，又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，JavaScript 遵循的就是词法作用域。\nvar a = 2;function foo()&#123;    console.log(a)&#125;function bar()&#123;    var a = 3;    foo();&#125;bar()\n\n由于JavaScript遵循词法作用域，相同层级的 foo 和 bar 就没有办法访问到彼此块作用域中的变量，所以输出2。\n作用域链当在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。\n如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错。\n","categories":["JavaScript"],"tags":["JavaScript","闭包","作用域链"]},{"title":"vue3性能提升","url":"/2022/10/20/vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/","content":"响应式vue2中采用 defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式；\nvue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历\n\n可以监听动态属性的添加\n可以监听到数组的索引和数组length属性\n可以监听删除属性\n\ndefineProperty\n检测不到对象属性的添加和删除\n数组API方法无法监听到\n需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题\n\n源码体积相比Vue2，Vue3整体体积变小了，除了移出一些不常用的API，最重要的是Tree shanking\n任何一个函数，如ref、reavtived、computed等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小\nTree shakingTree shaking是基于ES6模板语法（import与exports），主要是借助ES6模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量\nTree shaking无非就是做了两件事：\n\n编译阶段利用ES6 Module判断哪些模块已经加载\n判断那些模块和变量未被使用或者引用，进而删除对应代码\n\n通过Tree shaking，Vue3给我们带来的好处是：\n\n减少程序体积（更小）\n减少程序执行时间（更快）\n便于将来对程序架构进行优化（更友好）\n\n编译阶段回顾Vue2，我们知道每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把用到的数据property记录为依赖，当依赖发生改变，触发setter，则会通知watcher，从而使关联的组件重新渲染。\nVue3在编译阶段，做了进一步优化。主要有如下：\n\ndiff算法优化\n静态提升\n事件监听缓存\nSSR优化\n\ndiff算法优化一个组件结构如下：\n&lt;template&gt;\t&lt;div id=&quot;content&quot;&gt;    &lt;p class=&quot;text&quot;&gt;静态文本&lt;/p&gt;    &lt;p class=&quot;text&quot;&gt;静态文本&lt;/p&gt;    &lt;p class=&quot;text&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;    &lt;p class=&quot;text&quot;&gt;静态文本&lt;/p&gt;    ...    &lt;p class=&quot;text&quot;&gt;静态文本&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;\n\n可以看到，组件内部只有一个动态节点，剩余一堆都是静态节点，所以这里很多 diff 和遍历其实都是不需要的，造成性能浪费。\nvue3在diff算法中相比vue2增加了静态标记。\n关于这个静态标记，其作用是为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较。\n静态类型枚举如下\nexport const enum PatchFlags &#123;  TEXT = 1,  // 动态的文本节点  CLASS = 1 &lt;&lt; 1,  // 2 动态的 class  STYLE = 1 &lt;&lt; 2,  // 4 动态的 style  PROPS = 1 &lt;&lt; 3,  // 8 动态属性，不包括类名和样式  FULL_PROPS = 1 &lt;&lt; 4,  // 16 动态 key，当 key 变化时需要完整的 diff 算法做比较  HYDRATE_EVENTS = 1 &lt;&lt; 5,  // 32 表示带有事件监听器的节点  STABLE_FRAGMENT = 1 &lt;&lt; 6,   // 64 一个不会改变子节点顺序的 Fragment  KEYED_FRAGMENT = 1 &lt;&lt; 7, // 128 带有 key 属性的 Fragment  UNKEYED_FRAGMENT = 1 &lt;&lt; 8, // 256 子节点没有 key 的 Fragment  NEED_PATCH = 1 &lt;&lt; 9,   // 512  DYNAMIC_SLOTS = 1 &lt;&lt; 10,  // 动态 solt  HOISTED = -1,  // 特殊标志是负整数表示永远不会用作 diff  BAIL = -2 // 一个特殊的标志，指代差异算法&#125;\n\n静态提升Vue3中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用。\n这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用。\n事件监听缓存默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化。\n开启事件侦听器缓存后没有了静态标记，也就是说下次diff算法的时候直接使用。\nSSR优化当静态内容大到一定量级时候，会用createStaticVNode方法在客户端去生成一个static node，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染。\n","categories":["vue3"],"tags":["vue3","proxy"]},{"title":"OSI七层模型和TCP/IP协议","url":"/2022/10/20/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8CTCPIP%E5%8D%8F%E8%AE%AE/","content":"OSIOSI （Open System Interconnect）模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。\nOSI将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰。\nOSI主要划分了七层，如下\n应用层应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用\n该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP协议等\n在应用层交互的数据单元我们称之为报文\n表示层表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 OSI参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务\n该层提供的服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异\n会话层会话层就是负责建立、管理和终止表示层实体之间的通信会话\n该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法\n传输层传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题\n传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层\n其中，主要的传输层协议是TCP和UDP\n网络层两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网\n网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送\n在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层\n在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层\n数据链路层数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议\n在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP数据报组装成帧，在两个相邻节点间的链路上传送帧\n每一帧的数据可以分成：报头head和数据data两部分:\n\nhead 标明数据发送者、接受者、数据类型，如 MAC地址\ndata 存储了计算机之间交互的数据\n\n通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源\n物理层作为OSI 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送\n该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）\n该层主要是和硬件有关，与软件关系不大\n传输过程\n应用层报文被传送到运输层\n在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用\n应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变\n运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报\n网络层数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧\n在物理层数据帧被封装成比特流，之后通过传输介质传送到对端\n对端再一步步解开封装，获取到传送的数据\n\nTCP&#x2F;IP协议TCP&#x2F;IP，传输控制协议&#x2F;网际协议，是指能够在多个不同网络间实现信息传输的协议簇。\n\nTCP（传输控制协议）\n一种面向连接的、可靠的、基于字节流的传输层通信协议\n\nIP（网际协议）\n用于封包交换数据网络的协议\n\n\nTCP&#x2F;IP协议不仅仅指的是TCP和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇，只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以通称为TCP&#x2F;IP协议族（英语：TCP&#x2F;IP Protocol Suite，或TCP&#x2F;IP Protocols）\n划分TCP&#x2F;IP协议族按层次分别了五层体系或者四层体系：\n五层体系的协议结构是综合了 OSI 和 TCP&#x2F;IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。\n五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构，包括应用层、传输层、网络层（网际互联层）、网络接口层。\n五层体系应用层TCP/IP 模型将 OSI参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务\n如：FTP、Telnet、DNS、SMTP 等\n传输层该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能\n传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）\n其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输\n网络层负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机\n在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组或包进行传送\n数据链路层数据链路层在两个相邻节点传输数据时，将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧\n物理层保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境\n四层体系TCP&#x2F;IP 的四层结构则如下表所示：\n\n\n\n层次名称\n单位\n功 能\n协 议\n\n\n\n网络接口层\n帧\n负责实际数据的传输，对应OSI参考模型的下两层\nHDLC（高级链路控制协议）PPP（点对点协议） SLIP（串行线路接口协议）\n\n\n网络层\n数据报\n负责网络间的寻址数据传输，对应OSI参考模型的第三层\nIP（网际协议） ICMP（网际控制消息协议）ARP（地址解析协议） RARP（反向地址解析协议）\n\n\n传输层\n报文段\n负责提供可靠的传输服务，对应OSI参考模型的第四层\nTCP（控制传输协议） UDP（用户数据报协议）\n\n\n应用层\n\n负责实现一切与应用程序相关的功能，对应OSI参考模型的上三层\nFTP（文件传输协议） HTTP（超文本传输协议） DNS（域名服务器协议）SMTP（简单邮件传输协议）NFS（网络文件系统协议）\n\n\n","categories":["计算机网络"],"tags":["HTTP","OSI","TCP","IP"]},{"title":"TCP三次握手和四次挥手","url":"/2022/10/20/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","content":"三次握手三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。\n主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。\n过程如下：\n\n第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态\n第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1作为ACK的值，此时服务器处于 SYN_RCVD 的状态\n第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接\n\n每一次握手的作用如下：\n\n第一次握手：客户端发送网络包，服务端收到了 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。\n第二次握手：服务端发包，客户端收到了 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常\n第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常\n\n通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了\n为什么不是两次握手?如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到\n并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源\n四次挥手tcp终止一个连接，需要经过四次挥手\n过程如下：\n\n第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认\n第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态\n第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态\n第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态\n\n四次挥手原因服务端在收到客户端断开连接Fin报文后，并不会立即关闭连接，而是先发送一个ACK包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送FIN报文断开连接，因此需要四次挥手\n","categories":["计算机网络"],"tags":["TCP"]},{"title":"http请求和状态码","url":"/2022/10/20/http%E8%AF%B7%E6%B1%82%E5%92%8C%E7%8A%B6%E6%80%81%E7%A0%81/","content":"HTTP 请求方法根据 HTTP 标准，HTTP 请求可以使用多种请求方法。\nHTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。\nHTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。\n\n\n\n序号\n方法\n描述\n\n\n\n1\nGET\n请求指定的页面信息，并返回实体主体。\n\n\n2\nHEAD\n类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。\n\n\n3\nPOST\n向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。\n\n\n4\nPUT\n从客户端向服务器传送的数据取代指定的文档的内容。\n\n\n5\nDELETE\n请求服务器删除指定的页面。\n\n\n6\nCONNECT\nHTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。\n\n\n7\nOPTIONS\n允许客户端查看服务器的性能。（预检请求）\n\n\n8\nTRACE\n回显服务器收到的请求，主要用于测试或诊断。\n\n\n9\nPATCH\n是对 PUT 方法的补充，用来对已知资源进行局部更新 。\n\n\n跨域资源共享 CORS同源策略同源策略(Same Origin Policy)是一种约定，它是浏览器最核心也是最基本的安全功能。同源策略会阻止一个域的javascrip脚本和另一个域的内容进行交互，是用于隔离潜在恶意文件的关键安全机制。\n当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域。\n如果不是浏览器发起请求，就不会受到同源策略的影响。\n同源策略目的就是为了保证用户信息的安全，防止恶意的网站窃取用户数据。如果网页之间不满足“同源”的要求，那么它们之间：\n\n不能共享Cookie、LocalStorage、SessionStorage、IndexedDB\n不能获取DOM\nAJAX请求不能发送\n\n同源策略并不是浏览器不让请求发出去、或者后端拒绝返回数据。实际情况是请求正常发出去了，后端也正常相应了，只不过数据到了浏览器后浏览器不去作用加载而是丢弃了。\n不受同源策略影响的标签：\n\nimg\nscript\nstyle\nlink\niframe 引入资源可以允许不同域引入，但操作对应源里的dom是有跨域问题的\n\n跨域解决方法\n前端nginx反向代理\n后端设置CORS允许跨域（Access-Control-Allow-Origin）\njsonp：只适用于get请求\n\nCORS步骤一：客户端（浏览器）请求\n当浏览器发出跨域请求时，浏览器会添加一个带有当前源（方案、主机和端口）的 Origin 标头。\n步骤二：服务器响应\n在服务器端，当服务器看到此标头并希望允许访问时，它需要在响应中添加一个 Access-Control-Allow-Origin 标头，指定请求来源（或 * 以允许任何来源。）\n步骤三：浏览器收到响应\n当浏览器看到带有适当 Access-Control-Allow-Origin 标头的响应时，浏览器允许与客户端站点共享响应数据。\nCORS解决带cookie跨域问题出于隐私原因，CORS 通常用于“匿名请求”——请求未识别请求者的请求。如果您想在使用 CORS（可以识别发送者）时发送 cookie，您需要向请求和响应添加额外的标头。\n\n请求\n添加credentials: &#39;include&#39;到请求参数中即可实现带cookie进行跨域请求\nfetch(&#x27;https://example.com&#x27;, &#123;  mode: &#x27;cors&#x27;,  credentials: &#x27;include&#x27;&#125;)\n\n响应\nAccess-Control-Allow-Origin必须设置特定的值 (不能使用通配符*) 并且必须设置Access-Control-Allow-Credentials 为 true.\nHTTP/1.1 200 OKAccess-Control-Allow-Origin: https://example.comAccess-Control-Allow-Credentials: true\n\nCORS相关字段（1）Access-Control-Allow-Origin\n该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。\n（2）Access-Control-Allow-Credentials\n该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。\n（3）Access-Control-Expose-Headers\n该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。\n简单请求和非简单请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。\n只要同时满足以下两大条件，就属于简单请求。\n\n请求方法是以下三种方法之一：\nHEADGETPOST\n\nHTTP的头信息不超出以下几种字段：AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n\n\n预检请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。\n非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。\n浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。\n预检请求实际上是对服务端的一种权限请求\nOPTIONS /cors HTTP/1.1Origin: http://api.aaa.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.ccc.comConnection: keep-aliveUser-Agent: Mozilla/5.0...\n\n预检请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。\n除了Origin字段，”预检”请求的头信息包括两个特殊字段。\n（1）Access-Control-Request-Method\n该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。\n（2）Access-Control-Request-Headers\n该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。\n预检请求的回应服务器收到预检请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。\n\nHTTP&#x2F;1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache&#x2F;2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text&#x2F;html; charset&#x3D;utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout&#x3D;2, max&#x3D;100Connection: Keep-AliveContent-Type: text&#x2F;plain \n\n上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。\n如果浏览器否定了预检请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息：\nXMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.\n\n一旦服务器通过了预检请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。\n服务器回应的其他CORS相关字段如下：\n（1）Access-Control-Allow-Methods\n该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。\n（2）Access-Control-Allow-Headers\n如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。\n（3）Access-Control-Allow-Credentials\n该字段与简单请求时的含义相同。\n（4）Access-Control-Max-Age\n该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求\nHTTP状态码TTP状态码（英语：HTTP Status Code），用以表示网页服务器超文本传输协议响应状态的3位数字代码。\n它由 RFC 2616规范定义的，并得到 RFC 2518、RFC 2817、RFC 2295、RFC 2774与 RFC 4918等规范扩展。\n简单来讲，http状态码的作用是服务器告诉客户端当前请求响应的状态，通过状态码就能判断和分析服务器的运行状态。\n1xx代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。\n\n100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应\n101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级\n\n2xx代表请求已成功被服务器接收、理解、并接受。\n\n200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回\n201（已创建）：请求成功并且服务器创建了新的资源\n202（已创建）：服务器已经接收请求，但尚未处理\n203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源\n204（无内容）：服务器成功处理请求，但没有返回任何内容\n205（重置内容）：服务器成功处理请求，但没有返回任何内容\n206（部分内容）：服务器成功处理了部分请求\n\n3xx表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。\n\n300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择\n301（永久重定向）：永久重定向会缓存。请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置\n302（临时重定向）： 临时重定向不会缓存。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求\n303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码\n304（使用缓存）：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，没有内容部分\n305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理\n307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求\n\n4xx代表了客户端看起来可能发生了错误，妨碍了服务器的处理。\n\n400（错误请求）： 参数有误，请求无法被服务器识别\n401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。\n403（禁止）： 服务器拒绝请求\n404（未找到）： 服务器找不到请求的网页\n405（方法禁用）： 禁用请求中指定的方法\n406（不接受）： 无法使用请求的内容特性响应请求的网页\n407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理\n408（请求超时）： 服务器等候请求时发生超时\n\n5xx表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生。\n\n500（服务器内部错误）：服务器遇到错误，无法完成请求\n501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码\n502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应\n503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）\n504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求\n505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本\n\n","categories":["计算机网络"],"tags":["http","CORS"]},{"title":"HTTP和HTTPS","url":"/2022/10/20/HTTP%E5%92%8CHTTPS/","content":"HTTPHTTP (HyperText Transfer Protocol)，即超文本运输协议，是实现网络通信的一种规范。\nHTTP是一个传输协议，即将数据由A传到B或将B传输到A，并且 A 与 B 之间能够存放很多第三方，如： A&lt;&#x3D;&gt;X&lt;&#x3D;&gt;Y&lt;&#x3D;&gt;Z&lt;&#x3D;&gt;B。\n传输的数据并不是计算机底层中的二进制包，而是完整的、有意义的数据，如HTML 文件, 图片文件, 查询结果等超文本，能够被上层应用识别。\n在实际应用中，HTTP常被用于在Web浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密。\n特点如下：\n\n支持客户&#x2F;服务器模式\n简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快\n灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记\n无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间\n无状态：HTTP协议无法根据之前的状态进行本次的请求处理\n\nHTTP1.0中如果需要建立长连接，需要设置一个非标准的Connection字段 Connection: keep-alive；\n在HTTP1.1中，默认支持长连接（Connection: keep-alive），即在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，建立一次连接，多次请求均由这个连接完成。\n不同版本对比HTTP1.0\n浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接\n\nHTTP1.1\n引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用\n在同一个TCP连接里面，客户端可以同时发送多个请求\n虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着\n新增了一些请求方法\n新增了一些请求头和响应头\n\nHTTP2.0\n二进制分帧：采用二进制格式而非文本格式，解析起来更高效\n完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行（复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应）\n首部压缩：使用报头压缩，降低开销\n服务器推送，允许服务端推送资源给客户端\n\nHTTPSHTTP在通信过程中，存在以下问题：\n\n通信使用明文（不加密），内容可能被窃听\n不验证通信方的身份，因此有可能遭遇伪装\n\n而HTTPS的出现正是解决这些问题，HTTPS是建立在SSL之上，其安全性由SSL来保证\n在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能\n区别\nHTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL&#x2F;TLS协议进行了加密处理，相对更安全\nHTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443\nHTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP\nHTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高\n\nSSLSSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议\nHTTPS &#x3D; HTTP + TLS/SSL\nSSL的功能主要依赖于四种手段：\n\n对称加密：采用协商的密钥对数据加密\n非对称加密：实现身份认证和密钥协商\n摘要算法：验证信息的完整性\n数字签名：身份验证\n\n对称加密对称加密指的是加密和解密使用的秘钥都是同一个，是对称的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。\n非对称加密非对称加密，存在两个秘钥，一个叫公钥，一个叫私钥。两个秘钥是不同的，公钥可以公开给任何人使用，私钥则需要保密。\n公钥和私钥都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。\n混合加密在HTTPS通信过程中，采用的是对称加密+非对称加密，也就是混合加密。\n在对称加密中讲到，如果能够保证了密钥的安全，那整个通信过程就可以说具有了机密性。\n而HTTPS采用非对称加密解决秘钥交换的问题。\n具体做法是发送密文的一方使用对方的公钥进行加密处理“对称密钥”，然后对方用自己的私钥解密拿到“对称密钥”。\n这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。\n为什么使用混合加密融合了对称加密和非对称加密两者的优点：\n\n对称加密只使用一个密钥，运算速度快，但密钥必须保密，无法做到安全的密钥交换。\n非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，但速度慢，不适合直接加密信息。所以用来解决对称密钥的交换问题。\n\n但在网络传输过程中，数据有可能被篡改，并且黑客可以伪造身份发布公钥，如果你获取到假的公钥，那么混合加密也并无多大用处，你的数据扔被黑客解决。\n因此，在上述加密的基础上仍需加上完整性、身份验证的特性，来实现真正的安全，实现这一功能则是摘要算法和数字签名。\n摘要算法实现完整性的手段主要是摘要算法，也就是常说的散列函数、哈希函数。\n可以理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。\n摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性。\n比如，你发了条消息：“转账 1000 元”，然后再加上一个 SHA-2 的摘要。网站收到后也计算一下消息的摘要，把这两份“指纹”做个对比，如果一致，就说明消息是完整可信的，没有被修改。\n数字签名数字签名能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。\n原理其实很简单，就是用私钥加密，公钥解密。\n签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的。\n和消息本身一样，因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么判断这个公钥就是你的公钥。\n这时候就需要一个第三方，就是证书验证机构。\nCA验证机构数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场。\nCA 对公钥的签名认证要求包括序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”。\n流程如下：\n\n服务器的运营人员向数字证书认证机构提出公开密钥的申请\n数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名\n然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起\n服务器会将这份由数字证书认证机构颁发的数字证书发送给客户端，以进行非对称加密方式通信\n\n接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，则证明：\n\n认证服务器的公开密钥的是真实有效的数字证书认证机构\n服务器的公开密钥是值得信赖的\n\n总结可以看到，HTTPS与HTTP虽然只差一个SSL，但是通信安全得到了大大的保障，通信的四大特性都以解决，解决方式如下：\n\n机密性：混合算法\n完整性：摘要算法\n身份认证：数字签名\n不可否定：数字签名\n\n同时引入第三方证书机构，确保公开秘钥的安全性\n","categories":["计算机网络"],"tags":["http","SSL","https"]},{"title":"DNS域名解析","url":"/2022/10/21/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/","content":"DNSDNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器。\n简单来讲，DNS相当于一个翻译官，负责将域名翻译成ip地址。\n\nIP 地址：一长串能够唯一地标记网络上的计算机的数字\n域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识\n\n域名域名是一个具有层次的结构，从上到下一次为根域名、顶级域名、二级域名、三级域名…\n例如www.xxx.com，www为三级域名、xxx为二级域名、com为顶级域名，系统为用户做了兼容，域名末尾的根域名.一般不需要输入。\n在域名的每一层都会有一个域名服务器：\n\n根域名服务器\n顶级域名服务器：com域名服务器、cn域名服务器、edu域名服务器…\n权限域名服务器：abc.com域名服务器、y.abc.com域名服务器…\n本地域名服务器：任何一台主机在网络地址配置时，都会配置一个域名服务器作为默认域名服务器\n\n查询方式递归查询\n本地域名服务器向根域名服务器发起请求\n根域名服务器向顶级域名服务器发起请求\n顶级域名服务器向权限域名服务器发起请求\n权限域名服务器将 IP 地址逐级返回给本地域名服务器\n\n迭代查询\n首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器\n本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址\n本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址\n\n域名缓存在域名服务器解析的时候，使用缓存保存域名和IP地址的映射。\n计算机中DNS的记录也分成了两种缓存方式：\n\n浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗\n操作系统缓存：操作系统的缓存其实是用户自己配置的 hosts 文件\n\n查询过程解析域名的过程如下：\n\n首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表\n若没有命中，则继续搜索操作系统的 DNS 缓存\n若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果\n若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询\n本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来\n操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起\n至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起\n\n","categories":["计算机网络"],"tags":["DNS"]},{"title":"UDP和TCP","url":"/2022/10/21/UDP%E5%92%8CTCP/","content":"UDPUDP（User Datagram Protocol），用户数据包协议，是一个简单的面向数据报的通信协议，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层\n也就是说无论应用层交给UDP多长的报文，它统统发送，一次发送一个报文\n而对接收方，接到后直接去除首部，交给上面的应用层就完成任务\nUDP报头包括4个字段，每个字段占用2个字节（即16个二进制位），标题短，开销小\n特点如下：\n\nUDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务\n传输途中出现丢包，UDP 也不负责重发\n当包的到达顺序出现乱序时，UDP没有纠正的功能。\n并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为\n\nTCPTCP（Transmission Control Protocol），传输控制协议，是一种可靠、面向字节流的通信协议，把上面应用层交下来的数据看成无结构的字节流来发送\n可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着，TCP会根据当前网络的拥塞状态来确定每个报文段的大小\nTCP报文首部有20个字节，额外开销大\n特点如下：\n\nTCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。\n此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。\n根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）\n\n区别UDP与TCP两者的都位于传输层。\n两者区别如下表所示：\n\n\n\n\nTCP\nUDP\n\n\n\n可靠性\n可靠\n不可靠\n\n\n连接性\n面向连接\n无连接\n\n\n报文\n面向字节流\n面向报文\n\n\n效率\n传输效率低\n传输效率高\n\n\n双共性\n全双工\n一对一、一对多、多对一、多对多\n\n\n流量控制\n滑动窗口\n无\n\n\n拥塞控制\n慢开始、拥塞避免、快重传、快恢复\n无\n\n\n\nTCP 是面向连接的协议，建立连接3次握手、断开连接四次挥手，UDP是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取\nTCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方\nTCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用\nTCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信\n\n\n全双工通信：又称为双向同时通信，即通信的双方可以同时发送和接收信息的信息交互方式\n\n两者应用场景如下：\n\n\n\n应用层协议\n应用\n传输层协议\n\n\n\nSMTP\n电子邮件\nTCP\n\n\nLELNET\n远程终端接入\nTCP\n\n\nHTTP\n万维网\nTCP\n\n\nFTP\n文件传输\nTCP\n\n\nDNS\n域名转换\nUDP\n\n\nTFTP\n文件传输\nUDP\n\n\nSNMP\n网络管理\nUDP\n\n\nNFS\n远程文件服务器\nUDP\n\n\nTCP 应用场景适用于对效率要求低，对准确性要求高或者要求有链接的场景，而UDP 适用场景为对效率要求高，对准确性要求低的场景。\n","categories":["计算机网络"],"tags":["TCP","UDP"]},{"title":"js模块化","url":"/2022/10/21/js%E6%A8%A1%E5%9D%97%E5%8C%96/","content":"cjs (commonjs)commonjs 是 Node 中的模块规范，通过 require 及 exports 进行导入导出 (进一步延伸的话，module.exports 属于 commonjs2)\n同时，webpack 也对 cjs 模块进行解析，因此 cjs 模块可以运行在 node 环境及 webpack 环境下的，但不能在浏览器中直接使用。但如果你写前端项目在 webpack 中，也可以理解为它在浏览器和 Node 都支持。\n// sum.jsexports.sum = (x, y) =&gt; x + y;// index.jsconst &#123; sum &#125; = require(&quot;./sum.js&quot;);\n\n由于 cjs 为动态加载，可直接 require 一个变量\nrequire(`./$&#123;a&#125;`);\n\nesm (es module)esm 是 tc39 对于 ESMAScript 的模块话规范，正因是语言层规范，因此在 Node 及 浏览器中均会支持。\n它使用 import/export 进行模块导入导出.\n// sum.jsexport const sum = (x, y) =&gt; x + y;// index.jsimport &#123; sum &#125; from &quot;./sum&quot;;\n\nesm 为静态导入，正因如此，可在编译期进行 Tree Shaking，减少 js 体积。\n如果需要动态导入，tc39 为动态加载模块定义了 API: import(module) 。\nconst ms = await import(&quot;https://cdn.skypack.dev/ms@latest&quot;);ms.default(1000);\n\n目前，在浏览器与 node.js 中均原生支持 esm。\n动态 import标准用法的 import 导入的模块是静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。下面的是你可能会需要动态导入的场景：\n\n当静态导入的模块很明显的降低了代码的加载速度且被使用的可能性很低，或者并不需要马上使用它。\n当静态导入的模块很明显的占用了大量系统内存且被使用的可能性很低。\n当被导入的模块，在加载时并不存在，需要异步获取。\n当导入模块的说明符，需要动态构建。（静态导入只能使用静态说明符）\n当被导入的模块有副作用（这里说的副作用，可以理解为模块中会直接运行的代码），这些副作用只有在触发了某些条件才被需要时。（原则上来说，模块不能有副作用，但是很多时候，你无法控制你所依赖的模块的内容）\n\n请不要滥用动态导入（只有在必要情况下采用）。静态框架能更好的初始化依赖，而且更有利于静态分析工具和 Tree Shaking 发挥作用。\n与cjs比较\ncjs 模块输出的是一个值的拷贝，esm 输出的是值的引用\ncjs 模块是运行时加载，esm 是编译时加载\n\numd一种兼容 cjs 与 amd 的模块，既可以在 node&#x2F;webpack 环境中被 require 引用，也可以在浏览器中直接用 CDN 被 script.src 引入。\n(function (root, factory) &#123;  if (typeof define === &quot;function&quot; &amp;&amp; define.amd) &#123;    // AMD    define([&quot;jquery&quot;], factory);  &#125; else if (typeof exports === &quot;object&quot;) &#123;    // CommonJS    module.exports = factory(require(&quot;jquery&quot;));  &#125; else &#123;    // 全局变量    root.returnExports = factory(root.jQuery);  &#125;&#125;)(this, function ($) &#123;  // ...&#125;);\n","categories":["JavaScript"],"tags":["cjs","esm","umd"]},{"title":"vite特点","url":"/2022/10/21/vite%E7%89%B9%E7%82%B9/","content":"ViteVite是一种新型前端构建工具，能够显著提升前端开发体验。它主要由两部分组成：\n\n一个开发服务器，它基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的 模块热更新（HMR）。\n一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。\n\nVite 意在提供开箱即用的配置，同时它的 插件 API 和 JavaScript API带来了高度的可扩展性，并有完整的类型支持。\n冷启动Vite 通过在一开始将应用中的模块区分为 依赖 和 源码 两类，改进了开发服务器启动时间。\n\n依赖 大多为在开发时不会变动的纯 JavaScript。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会存在多种模块化格式（例如 ESM 或者 CommonJS）。\nVite 将会使用 esbuild 预构建依赖。esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。\n\n源码 通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue/Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）。\nVite 以 原生 ESM 方式提供源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理。\n\n\n生产环境仍需打包尽管原生 ESM 现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP&#x2F;2）。为了在生产环境中获得最佳的加载性能，最好还是将代码进行 tree-shaking、懒加载和 chunk 分割（以获得更好的缓存）。\nVite使用Rollup进行生产打包，因此，Vite的主要优势在开发阶段。\nNPM 依赖解析原生 ES 导入不支持下面这样的裸模块导入：\nimport &#123; someMethod &#125; from &#x27;my-dep&#x27;\n\n上面的代码会在浏览器中抛出一个错误。Vite 将会检测到所有被加载的源文件中的此类裸模块导入，并执行以下操作:\n\n预构建 它们可以提高页面加载速度，并将 CommonJS / UMD 转换为 ESM 格式。预构建这一步由 esbuild 执行，这使得 Vite 的冷启动时间比任何基于 JavaScript 的打包器都要快得多。\n重写导入为合法的 URL，例如 /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd 以便浏览器能够正确导入它们。\n\n依赖是强缓存的，Vite 通过 HTTP 头来缓存请求得到的依赖。\n预构建\nCommonJS 和 UMD 兼容性: 开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。\n当转换 CommonJS 依赖时，Vite 会执行智能导入分析，这样即使导出是动态分配的（如 React），按名导入也会符合预期效果：\n// 符合预期import React, &#123; useState &#125; from &#x27;react&#x27;\n\n性能： Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。\n一些包将它们的 ES 模块构建作为许多单独的文件相互导入。例如，lodash-es 有超过 600 个内置模块！当我们执行 import &#123; debounce &#125; from &#39;lodash-es&#39; 时，浏览器同时发出 600 多个 HTTP 请求！尽管服务器在处理这些请求时没有问题，但大量的请求会在浏览器端造成网络拥塞，导致页面的加载速度相当慢。\n通过预构建 lodash-es 成为一个模块，就只需要一个 HTTP 请求了。\n\n\n在服务器已经启动之后，如果遇到一个新的依赖关系导入，而这个依赖关系还没有在缓存中，Vite 将重新运行依赖构建进程并重新加载页面。如果没有找到相应的缓存，Vite 将抓取你的源码，并自动寻找引入的依赖项（即 “bare import”，表示期望从 node_modules 解析），并将这些依赖项作为预构建包的入口点。预构建通过 esbuild 执行，所以它通常非常快。\n缓存文件系统缓存Vite 会将预构建的依赖缓存到 node_modules/.vite。它根据几个源来决定是否需要重新运行预构建步骤:\n\npackage.json 中的 dependencies 列表\n包管理器的 lockfile，例如 package-lock.json, yarn.lock，或者 pnpm-lock.yaml\n可能在 vite.config.js 相关字段中配置过的\n\n只有在上述其中一项发生更改时，才需要重新运行预构建。\n如果出于某些原因，你想要强制 Vite 重新构建依赖，你可以用 --force 命令行选项启动开发服务器，或者手动删除 node_modules/.vite 目录。\n浏览器缓存解析后的依赖请求会以 HTTP 头 max-age=31536000,immutable 强缓存，以提高在开发时的页面重载性能。一旦被缓存，这些请求将永远不会再到达开发服务器。如果安装了不同的版本（这反映在包管理器的 lockfile 中），则附加的版本 query 会自动使它们失效。如果你想通过本地编辑来调试依赖项，你可以:\n\n通过浏览器调试工具的 Network 选项卡暂时禁用缓存；\n重启 Vite dev server，并添加 --force 命令以重新构建依赖；\n重新载入页面。\n\n热更新\nvite server：指 vite 在开发时启动的 server\nvite client：vite dev server 会在 index.html 中，注入路径为 @vite/client 的脚本，这个脚本是运行在浏览器的\n\n热更新的核心流程：\n\n修改代码，vite server 监听到代码被修改\nvite 计算出热更新的边界（即受到影响，需要进行更新的模块）\nvite server 通过 websocket 告诉 vite client 需要进行热更新\n浏览器拉取修改后的模块\n执行热更新的代码\n\nVite 提供了一套原生 ESM 的 HMR API。 具有 HMR 功能的框架可以利用该 API 提供即时、准确的更新，而无需重新加载页面或清除应用程序状态。\nTypeScriptVite 天然支持引入 .ts 文件。\nVite 仅执行 .ts 文件的转译工作，并 不 执行任何类型检查。并假设类型检查已经被你的 IDE 或构建过程接管了（你可以在构建脚本中运行 tsc --noEmit 或者安装 vue-tsc 然后运行 vue-tsc --noEmit 来对你的 *.vue 文件做类型检查）。\nVite 使用 esbuild 将 TypeScript 转译到 JavaScript，约是 tsc 速度的 20~30 倍，同时 HMR 更新反映到浏览器的时间小于 50ms。\n使用 仅含类型的导入和导出 形式的语法可以避免潜在的 “仅含类型的导入被不正确打包” 的问题，写法示例如下：\nimport type &#123; T &#125; from &#x27;only/types&#x27;export type &#123; T &#125;\n\n与Webpack区别vite和webpack的主要区别在开发阶段：\n\nWebpack基于commonjs，先打包合并然后请求服务器，更改一个模块，其他有依赖关系的模块都会重新打包； \n\nVite基于es module，自动向依赖的module发请求，服务端按需编译返回，改动一个模块仅仅会重新请求该模块；\n\n\n","categories":["前端工程化"],"tags":["vite","ESM","Webpack"]},{"title":"正则","url":"/2022/10/21/%E6%AD%A3%E5%88%99/","content":"正则表达式正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法，以及 String 的 match、matchAll、replace、search 和 split 方法。\n创建正则表达式\n使用一个正则表达式字面量，其由包含在斜杠之间的模式组成\nvar re = /ab+c/;\n\n脚本加载后，正则表达式字面量就会被编译。当正则表达式保持不变时，使用此方法可获得更好的性能。\n\n或者调用RegExp对象的构造函数\nvar re = new RegExp(&quot;ab+c&quot;);\n\n在脚本运行过程中，用构造函数创建的正则表达式会被编译。如果正则表达式将会改变，或者它将会从用户输入等来源中动态地产生，就需要使用构造函数来创建正则表达式。\n\n\n特殊字符正则表达式中的特殊字符：\n\n\n\n字符\n含义\n\n\n\n\\\n依照下列规则匹配：在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。\n\n\n^\n匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。\n\n\n$\n匹配输入的结束。如果多行标志被设置为 true，那么也匹配换行符前的位置。\n\n\n*\n匹配前一个表达式 0 次或多次。等价于 &#123;0,&#125;。\n\n\n+\n匹配前面一个表达式 1 次或者多次。等价于 &#123;1,&#125;。\n\n\n?\n匹配前面一个表达式 0 次或者 1 次。等价于 &#123;0,1&#125;。\n\n\n.（小数点）\n默认匹配除换行符之外的任何单个字符。\n\n\n(x)\n它会匹配 ‘x’ 并且记住匹配项。其中括号被称为捕获括号。\n\n\n(?:x)\n匹配 ‘x’ 但是不记住匹配项。这种括号叫作非捕获括号。\n\n\n\n\n\n\nx(?=y)\n匹配’x’仅仅当’x’后面跟着’y’.这种叫做先行断言。\n\n\n(?&lt;=y)x\n匹配’x’仅当’x’前面是’y’.这种叫做后行断言。\n\n\nx(?!y)\n仅仅当’x’后面不跟着’y’时匹配’x’，这被称为正向否定查找。\n\n\nx|y\n匹配‘x’或者‘y’。\n\n\n&#123;n&#125;\nn 是一个正整数，匹配了前面一个字符刚好出现了 n 次。\n\n\n&#123;n,&#125;\nn 是一个正整数，匹配前一个字符至少出现了 n 次。\n\n\n&#123;n,m&#125;\nn 和 m 都是整数。匹配前面的字符至少 n 次，最多 m 次。如果 n 或者 m 的值是 0，这个值被忽略。\n\n\n[xyz]\n一个字符集合。匹配方括号中的任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。\n\n\n[^xyz]\n一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。\n\n\n[\\b]\n匹配一个退格 (U+0008)。（不要和\\b混淆了。）\n\n\n\\b\n匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。\n\n\n\\B\n匹配一个非单词的边界。\n\n\n\\cX\n当 X 是处于 A 到 Z 之间的字符的时候，匹配字符串中的一个控制符。\n\n\n\\d\n匹配一个数字。等价于 [0-9]。\n\n\n\\D\n匹配一个非数字字符。等价于 [^0-9]。\n\n\n\\f\n匹配一个换页符 (U+000C)。\n\n\n\\n\n匹配一个换行符 (U+000A)。\n\n\n\\r\n匹配一个回车符 (U+000D)。\n\n\n\\s\n匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于 [ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。\n\n\n\\S\n匹配一个非空白字符。\n\n\n\\t\n匹配一个水平制表符 (U+0009)。\n\n\n\\v\n匹配一个垂直制表符 (U+000B)。\n\n\n\\w\n匹配一个单字字符（字母、数字或者下划线）。等价于 [A-Za-z0-9_]。\n\n\n\\W\n匹配一个非单字字符。等价于 [^A-Za-z0-9_]。\n\n\n\\n\n在正则表达式中，它返回最后的第 n 个子捕获匹配的子字符串 (捕获的数目以左括号计数)。\n\n\n\\0\n匹配 NULL（U+0000）字符，不要在这后面跟其它小数，因为 \\0&lt;digits&gt; 是一个八进制转义序列。\n\n\n\\xhh\n匹配一个两位十六进制数（\\x00-\\xFF）表示的字符。\n\n\n\\uhhhh\n匹配一个四位十六进制数表示的 UTF-16 代码单元。\n\n\n\\u&#123;hhhh&#125;或\\u&#123;hhhhh&#125;\n（仅当设置了 u 标志时）匹配一个十六进制数表示的 Unicode 字符。\n\n\n标志正则表达式有六个可选参数 (flags) 允许全局和不分大小写搜索等。这些参数既可以单独使用也能以任意顺序一起使用，并且被包含在正则表达式实例中。\n\n\n\n标志\n描述\n\n\n\ng\n全局搜索。\n\n\ni\n不区分大小写搜索。\n\n\nm\n多行搜索。\n\n\ns\n允许 . 匹配换行符。\n\n\nu\n使用 unicode 码的模式进行匹配。\n\n\ny\n执行“粘性 (sticky)”搜索，匹配从目标字符串的当前位置开始。\n\n\n用法：\nvar re = /\\w+\\s/gvar re = new RegExp(&quot;\\\\w+\\\\s&quot;, &quot;g&quot;)\n\n如果使用 m 标志，^和$匹配的开始或结束输入字符串中的每一行，而不是整个字符串的开始或结束。\n使用正则表达式正则表达式可以被用于 RegExp 的 exec 和 test 方法，以及 String 的 match、matchAll、replace、search 和 split 方法。\n\n\n\n方法\n描述\n\n\n\nexec\n一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组（未匹配到则返回 null）。\n\n\ntest\n一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或 false。\n\n\nmatch\n一个在字符串中执行查找匹配的 String 方法，它返回一个数组，在未匹配到时会返回 null。\n\n\nmatchAll\n一个在字符串中执行查找所有匹配的 String 方法，它返回一个迭代器（iterator）。\n\n\nsearch\n一个在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回-1。\n\n\nreplace\n一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉匹配到的子字符串。\n\n\nsplit\n一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。\n\n\nexec如果匹配失败，exec() 方法返回 null，并将正则表达式的 lastIndex 重置为 0。\n如果匹配成功，exec() 方法返回一个数组，并更新正则表达式对象的 lastIndex 属性。\nvar myRe = new RegExp(&quot;d(b+)d&quot;, &quot;g&quot;)var myArray = myRe.exec(&quot;cdbbdbsbz&quot;)console.log(myArray) // [&#x27;dbbd&#x27;, &#x27;bb&#x27;, index: 1, input: &#x27;cdbbdbsbz&#x27;, groups: undefined]console.dir(myRe) // 其中 lastIndex: 5\n\n上述代码中，匹配成功后将返回一个数组并且更新正则表达式的属性。\nmyArray\n\n索引 0：表示最近一个匹配到的字符串。\n大于0的索引：对应所有被记住的子字符串。\nindex：匹配到的字符位于原始字符串的索引值。\ninput：初始字符串。\ngroups：一个命名捕获组对象，其键是名称，值是捕获组。若没有定义命名捕获组，则 groups 的值为 undefined。\n\nmyRe\n\nlastIndex：开始下一个匹配的起始索引值。（这个属性只有在使用 g 参数时可用）\n\n命名捕获组const date = &#x27;10-23-2022&#x27;const newDate = date.replace(/(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)-(?&lt;year&gt;\\d&#123;4&#125;)/, &quot;$&lt;day&gt;-$&lt;month&gt;-$&lt;year&gt;&quot;)\n\n命名捕获分组很大的一个作用就是它能起到注释的作用。\n名捕获分组自身的语法是 (?&lt;name&gt;...)，比普通的分组多了一个 ?&lt;name&gt; 字样，其中 name 的起法就和你平时起变量名一样即可（不过在这里关键字也可用）。\n反向引用一个命名分组的语法是 \\k&lt;name&gt;，注意命名分组同样可以通过数字索引来反向引用，比如：\n/(?&lt;foo&gt;a)\\k&lt;foo&gt;\\1/.test(&quot;aaa&quot;) // true\n\n在 replace() 方法的替换字符串中反向引用是用 $&lt;name&gt;：\n&quot;abc&quot;.replace(/(?&lt;foo&gt;a)/, &quot;$&lt;foo&gt;-&quot;) // &quot;a-bc&quot;，同样 $1 仍然可用\n\n总结一下就是，和命名分组相关的有三种语法，分别是 ?&lt;name&gt;、\\k&lt;name&gt;、$&lt;name&gt;，相同点是都用尖括号包裹着分组名。\nmatch\n如果使用 g 标志，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组。\n如果未使用 g 标志，则仅返回第一个完整匹配及其相关的捕获组（Array）。在这种情况下，返回的项目将具有如下所述的其他属性。\n\n如上所述，匹配的结果包含如下所述的附加特性。\n\ngroups: 一个命名捕获组对象，其键是捕获组名称，值是捕获组，如果未定义命名捕获组，则为 undefined。\nindex: 匹配的结果的开始位置\ninput: 搜索的字符串。\n\n一个Array，其内容取决于 global（g）标志的存在与否，如果未找到匹配则为null。\n如果正则表达式不包含 g 标志，str.match() 将返回与 RegExp.exec()相同的结果。\n如果你想要获得捕获组，并且设置了全局标志，你需要用 RegExp.exec() 或者 String.prototype.matchAll()\nmatchAllstr.matchAll(regexp)\n\nRegExp必须是设置了全局模式g的形式，否则会抛出异常TypeError。\n返回值：\n一个迭代器（不可重用，结果耗尽需要再次调用方法，获取一个新的迭代器）。\nconst regexp = RegExp(&#x27;foo[a-z]*&#x27;,&#x27;g&#x27;);const str = &#x27;table football, foosball&#x27;;let matches = str.matchAll(regexp);// 使用for...of遍历for (const match of matches) &#123;  console.log(match);&#125;matches = str.matchAll(regexp);// 使用Array.from()Array.from(matches, m =&gt; m[0])matches = str.matchAll(regexp);// 使用扩展运算符const array = [...matches]array[0] // [&#x27;football&#x27;, index: 6, input: &#x27;table football, foosball&#x27;, groups: undefined]array[1] // [&#x27;foosball&#x27;, index: 16, input: &#x27;table football, foosball&#x27;, groups: undefined]\n\n使用括号的子字符串匹配一个正则表达式模式使用括号，将导致相应的子匹配被记住。\n下面的脚本使用 replace() 方法来转换字符串中的单词。在匹配到的替换文本中，脚本使用替代的$1 ,$2 表示第一个和第二个括号的子字符串匹配。\nvar re = /(\\w+)\\s(\\w+)/;var str = &quot;John Smith&quot;;var newstr = str.replace(re, &quot;$2, $1&quot;);console.log(newstr); // &quot;Smith, John&quot;\n","categories":["JavaScript"],"tags":["RegExp"]},{"title":"打字动画","url":"/2022/10/22/%E6%89%93%E5%AD%97%E5%8A%A8%E7%94%BB/","content":"打字动画&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;style&gt;      html,      body &#123;        margin: 0;      &#125;      .color1 &#123;        color: #e60012;      &#125;      .color2 &#123;        color: #eb6100;      &#125;      .color3 &#123;        color: #fcc800;      &#125;      .color4 &#123;        color: #22ac38;      &#125;      .color5 &#123;        color: #0086d1;      &#125;      .color6 &#123;        color: #1d2088;      &#125;      .color7 &#123;        color: #920783;      &#125;      .word &#123;        font-size: 20px;      &#125;      .content &#123;        text-align: center;        font-size: 0;      &#125;      .blink &#123;        font-size: 20px;        animation: fade 500ms infinite;        -webkit-animation: fade 500ms infinite;      &#125;      @keyframes fade &#123;        from &#123;          opacity: 1;        &#125;        50% &#123;          opacity: 0;        &#125;        to &#123;          opacity: 1;        &#125;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;content&quot;&gt;      &lt;span class=&quot;blink&quot; id=&quot;jsBlink&quot;&gt;|&lt;/span&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      function output(str) &#123;        const contentDom = document.querySelector(&#x27;.content&#x27;)        contentDom.innerHTML = &#x27;&lt;span class=&quot;blink&quot; id=&quot;jsBlink&quot;&gt;|&lt;/span&gt;&#x27;        const blinkDom = document.querySelector(&#x27;.blink&#x27;)        const enterIndexs = []        while (str.indexOf(&#x27;\\n&#x27;) &gt; -1) &#123;          enterIndexs.push(str.indexOf(&#x27;\\n&#x27;) + enterIndexs.length)          str = str.replace(&#x27;\\n&#x27;, &#x27;&#x27;)        &#125;        const arr = str.split(&#x27;&#x27;)        const doms = arr.map((item) =&gt; &#123;          if (item === &#x27; &#x27;) item = &#x27;&amp;nbsp;&#x27;          else if (item === &#x27;&gt;&#x27;) item = &#x27;\\&gt;&#x27;          else if (item === &#x27;&lt;&#x27;) item = &#x27;\\&lt;&#x27;          const dom = document.createElement(&#x27;span&#x27;)          dom.innerHTML = item          dom.className = `word color$&#123;Math.ceil(Math.random() * 7)&#125;`          return dom        &#125;)        enterIndexs.forEach((item) =&gt; &#123;          const brDom = document.createElement(&#x27;br&#x27;)          doms.splice(item, 0, brDom)        &#125;)        console.log(contentDom)        console.log(blinkDom)        for (let i = 0; i &lt; doms.length; i++) &#123;          setTimeout(() =&gt; &#123;            console.log(doms[i])            contentDom.insertBefore(doms[i], blinkDom)          &#125;, 200 * (i + 1))        &#125;      &#125;      output(&#x27;Hello world\\n你好，世界！&#x27;)    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n","categories":["面试题"],"tags":["JavaScript"]},{"title":"Web攻击方式","url":"/2022/10/22/Web%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/","content":"CSRFCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目\n一个典型的CSRF攻击有着如下的流程：\n\n受害者登录a.com，并保留了登录凭证（Cookie）\n攻击者引诱受害者访问了b.com\nb.com 向 a.com 发送了一个请求：a.com&#x2F;act&#x3D;xx。浏览器会默认携带a.com的Cookie\na.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求\na.com以受害者的名义执行了act&#x3D;xx\n攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作\n\ncsrf可以通过get请求，即通过访问img的页面后，浏览器自动访问目标地址，发送请求\n&lt;img src=&quot;http://bank.com/transfer?account=lisi&amp;amount=100&quot;&gt;\n\n同样，也可以设置一个自动提交的表单发送post请求，如下：\n&lt;form action=&quot;http://bank.example/withdraw&quot; method=POST&gt;    &lt;input type=&quot;hidden&quot; name=&quot;account&quot; value=&quot;xiaoming&quot; /&gt;    &lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;10000&quot; /&gt;    &lt;input type=&quot;hidden&quot; name=&quot;for&quot; value=&quot;hacker&quot; /&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; \n\n访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作\n还有一种为使用a标签的，需要用户点击链接才会触发\n访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作\n&lt;a href=&quot;http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker&quot; taget=&quot;_blank&quot;&gt;    重磅消息！！&lt;a/&gt;\n\nCSRF的特点\n攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生\n攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据\n整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”\n跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪\n\nCSRF的预防CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性\n防止csrf常用方案如下：\n\n阻止不明外域的访问\n同源检测：服务器端通过请求的Origin Header和Referer Header，判断请求的来源。\nSameSite cookies\n\n\n提交时要求附加本域才能获取的信息\nCSRF Token\n双重Cookie验证\n\n\n\n四种防范方法中，CSRF Token是最成熟、使用最广泛的方法。\nSameSite cookiesSameSite 是 HTTP 响应头 Set-Cookie 的属性之一。它允许您声明该 Cookie 是否仅限于第一方或者同一站点上下文。\nSameSite 接受下面三个值：\nLax\n对于从第三方站点以link标签，a标签，GET形式的Form提交这三种方式访问目标系统时，会带上目标系统的Cookie，对于其他方式，如 POST形式的Form提交、AJAX形式的GET、img的src访问目标系统时，不带Cookie。这是浏览器中的默认值。\nStrict\n最严格模式，完全禁止第三方Cookie，跨站点访问时，任何情况下都不会发送Cookie。换言之，只有当前网页的 URL与请求目标一致，才会带上Cookie。\nNone\nCookie 将在所有上下文中发送，即允许跨站发送。\n以前 None 是默认值，但最近的浏览器版本将 Lax 作为默认值，以便对某些类型的跨站请求伪造（CSRF）攻击具有相当强的防御能力。\nCSRF Token\n用户打开页面的时候，服务器需要给这个用户生成一个Token\n对于GET请求，Token将附在请求地址之后。对于 POST 请求来说，要在 form 的最后加上\n\n&lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt;\n\n\n当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性\n\n双重Cookie验证上述CSRF Token方式，需要在服务器上保存Token值，并对请求参数进行校验，增加了服务器端的复杂度。双重Cookie验证的原理是在Cookie中保存Token值，同时在Form表单中也提供该值，请求提交时，Cookie和Form表单中的Token同时提交，服务器端只需要对请求中的两个参数进行校验即可，省去了在服务器端维护Token的步骤。\nXSSXSS，跨站脚本攻击，允许攻击者将恶意代码植入到提供给其它用户使用的页面中。\nXSS涉及到三方，即攻击者、客户端与Web应用。\nXSS的攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互。\n根据攻击的来源，XSS攻击可以分成：\n\n存储型\n反射型\nDOM 型\n\n存储型存储型 XSS 的攻击步骤：\n\n攻击者将恶意代码提交到目标网站的数据库中\n用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器\n用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行\n恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作\n\n这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。\n反射型反射型 XSS 的攻击步骤：\n\n攻击者构造出特殊的 URL，其中包含恶意代码\n用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器\n用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行\n恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作\n\n反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。\n反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。\n由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。\nPOST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。\nDOM 型DOM 型 XSS 的攻击步骤：\n\n攻击者构造出特殊的 URL，其中包含恶意代码\n用户打开带有恶意代码的 URL\n用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行\n恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作\n\nDOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞.\nXSS的预防通过前面介绍，看到XSS攻击的两大要素：\n\n攻击者提交恶意代码\n浏览器执行恶意代码\n\n针对第一个要素，我们在用户输入的过程中，过滤掉用户输入的恶劣代码，然后提交给后端，但是如果攻击者绕开前端请求，直接构造请求就不能预防了。\n而如果在后端写入数据库前，对输入进行过滤，然后把内容给前端，但是这个内容在不同地方就会有不同显示。\n在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等；\n如果用 Vue/React 技术栈，并且不使用 v-html&#x2F;dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患；\nDOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，&lt;a&gt; 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。\nSQL注入Sql 注入攻击，是通过将恶意的 Sql查询或添加语句插入到应用的输入参数中，再在后台 Sql服务器上解析执行进行的攻击\n流程如下所示：\n\n找出SQL漏洞的注入点\n判断数据库的类型以及版本\n猜解用户名和密码\n利用工具查找Web后台管理入口\n入侵和破坏\n\n预防方式如下：\n\n严格检查输入变量的类型和格式\n过滤和转义特殊字符\n对访问数据库的Web应用程序采用Web应用防火墙\n\n","categories":["JavaScript"],"tags":["CSRF","XSS"]},{"title":"cookie、session和本地存储","url":"/2022/10/23/cookie%E3%80%81session%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/","content":"CookieCookie，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据。是为了解决 HTTP无状态导致的问题。\n作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 cookie有效期、安全性、使用范围的可选属性组成。\n但是cookie在每次请求中都会被发送，如果不使用 HTTPS并对其加密，其保存的信息很容易被窃取，导致安全风险。举个例子，在一些使用 cookie保持登录态的网站上，如果 cookie被窃取，他人很容易利用你的 cookie来假扮成你登录网站。\ncookie的使用通过 Document.cookie 属性可创建新的 Cookie，也可通过该属性访问非HttpOnly标记的 Cookie。\ndocument.cookie = &#x27;名字=值&#x27;// 通过 JavaScript 创建的 `Cookie` 不能包含 `HttpOnly` 标志。\n\ncookie的修改，首先要确定domain和path属性都是相同的才可以，其中有一个不同得时候都会创建出一个新的cookie\nSet-Cookie:name=aa; domain=aa.net; path=/  # 服务端设置document.cookie =name=bb; domain=aa.net; path=/  # 客户端设置\n\ncookie的删除，最常用的方法就是给cookie设置一个过期的时间，这样cookie过期后会被浏览器删除\nSet-Cookie响应标头 Set-Cookie 被用来由服务器端向用户代理（一般是浏览器）发送 cookie，所以用户代理可再后续的请求中将其发送回服务器。服务器要发送多个 cookie，则应该在同一响应中发送多个 Set-Cookie 标头。\n一个简单的 Cookie 可能像这样：\nSet-Cookie: &lt;cookie 名&gt;=&lt;cookie 值&gt;\n\n服务器通过该头部告知客户端保存 Cookie 信息。\nHTTP/1.0 200 OKContent-type: text/htmlSet-Cookie: yummy_cookie=chocoSet-Cookie: tasty_cookie=strawberry[页面内容]\n\n现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的 Cookie 信息通过 Cookie 请求头部再发送给服务器。\nGET /sample_page.html HTTP/1.1Host: www.example.orgCookie: yummy_cookie=choco; tasty_cookie=strawberry\n\n生命周期Cookie 的生命周期可以通过两种方式定义：\n\n会话期 Cookie 是最简单的 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期 Cookie 不需要指定过期时间（Expires）或者有效期（Max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样，这会导致 Cookie 的生命周期无限期延长。\n持久性 Cookie 的生命周期取决于过期时间（Expires）或有效期（Max-Age）指定的一段时间。\n\n例如：\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;\n\n属性\nExpires=&lt;date&gt; \ncookie 的最长有效时间，形式为符合 HTTP-date 规范的时间戳。\n如果没有设置这个属性，那么表示这是一个会话期 cookie。一个会话结束于客户端被关闭时，这意味着会话期 cookie 在彼时会被移除。其截止时间与客户端相关，而非服务器的时间。\n\nMax-Age=&lt;number&gt;\n在 cookie 失效之前需要经过的秒数。秒数为 0 或 -1 将会使 cookie 直接过期。假如 Expires 和 Max-Age 属性均存在，那么 Max-Age 的优先级更高。\n\nDomain=&lt;domain-value&gt;\n指定 cookie 可以送达的主机名。\n假如没有指定，那么默认值为当前文档访问地址中的主机部分（但是不包含子域名）。 与之前的规范不同的是，域名（.example.com）之前的点号会被忽略。 多个主机&#x2F;域名的值是不被允许的，但如果指定了一个域，则其子域也会被包含。\n\nPath=&lt;path-value&gt;\n指定一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 标头。\n字符 / 可以解释为文件目录分隔符，此目录的下级目录也满足匹配的条件（例如，如果 path=/docs，那么/docs、/docs/、/docs/Web/ 和 /docs/Web/HTTP 都满足匹配条件。\n/、/docsets 或者 /fr/docs 则不满足匹配条件。\n\nSecure\n一个带有安全（Secure）属性的 cookie 只有在请求使用 https: 协议（localhost 不受此限制）的时候才会被发送到服务器。\n\nHttpOnly\n用于阻止 JavaScript 通过 Document.cookie 属性访问 cookie。注意，设置了 HttpOnly 的 cookie 在 JavaScript 初始化的请求中仍然会被发送。例如，调用 XMLHttpRequest.send() 或 fetch()。其用于防范跨站脚本攻击（XSS）。\n\nSameSite=&lt;samesite-value&gt;\n允许服务器设定一则 cookie 不随着跨站请求一起发送，这样可以在一定程度上防范跨站请求伪造攻击（CSRF）。\n可选的属性值有：\n\nStrict\n这意味浏览器仅对同一站点的请求发送 cookie，即请求来自设置 cookie 的站点。如果请求来自不同的域或协议（即使是相同域），则携带有 SameSite=Strict 属性的 cookie 将不会被发送。\n\nLax\n这意味着 cookie 不会在跨站请求中被发送，如：加载图像或 frame 的请求。但 cookie 在用户从外部站点导航到源站时，cookie 也将被发送（例如，跟随一个链接）。这是 SameSite 属性未被设置时的默认行为。\n对于从第三方站点以link标签，a标签，GET形式的Form提交这三种方式访问目标系统时，会带上目标系统的Cookie，对于其他方式，如 POST形式的Form提交、AJAX形式的GET、img的src访问目标系统时，不带Cookie。\n\nNone\n这意味着浏览器会在跨站和同站请求中均发送 cookie。在设置这一属性值时，必须同时设置 Secure 属性，就像这样：SameSite=None; Secure。\n\n\n\n\nCookie 前缀名称中包含 __Secure- 或 __Host- 前缀的 cookie，只可以应用在使用了安全连接（HTTPS）的域中，需要同时设置 secure 属性。\n另外，假如 cookie 以 __Host- 为前缀，那么 path 属性的值必须为 /（表示整个站点），且不能含有 Domain 属性。\n// 当响应来自于一个安全域（HTTPS）的时候，二者都可以被客户端接受Set-Cookie: __Secure-ID=123; Secure; Domain=example.comSet-Cookie: __Host-ID=123; Secure; Path=/// 缺少 Secure 指令，会被拒绝Set-Cookie: __Secure-id=1// 缺少 Path=/ 指令，会被拒绝Set-Cookie: __Host-id=1; Secure// 由于设置了 domain 属性，会被拒绝Set-Cookie: __Host-id=1; Secure; Path=/; domain=example.com\n\nSessionSession是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。\n虽然Session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为Session需要使用Cookie作为识别标志。HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值为该Session的id（也就是HttpSession.getId()的返回值）。Session依据该Cookie来识别是否为同一用户。\n该Cookie为服务器自动生成的，它的maxAge属性一般为–1，表示仅当前浏览器内有效，并且各浏览器窗口间不共享，关闭浏览器就会失效。\n生命周期Session保存在服务器端。为了获得更高的存取速度，服务器一般把Session放在内存里。每个用户都会有一个独立的Session。如果Session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，Session里的信息应该尽量精简。\nSession在用户第一次访问服务器的时候自动创建。需要注意只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session。如果尚未生成Session，也可以使用request.getSession(true)强制生成Session。\nSession生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session“活跃”了一次。\n有效期由于会有越来越多的用户访问服务器，因此Session也会越来越多。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。\nSession的超时时间为maxInactiveInterval属性，可以通过对应的getMaxInactiveInterval()获取，通过setMaxInactiveInterval(longinterval)修改。\nSession的超时时间也可以在web.xml中修改。另外，通过调用Session的invalidate()方法可以使Session失效。\n和Cookie区别\ncookie数据存放在客户的浏览器上，session数据放在服务器上\ncookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗考虑到安全应当使用session。\n设置cookie时间可以使cookie过期。但是使用session-destory()，我们将会销毁会话。\nsession会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。\n单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型)\n\nlocalStorage\n生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的\n存储的信息在同一域中是共享的\n当本页操作（新增、修改、删除）了localStorage的时候，本页面不会触发storage事件,但是别的页面会触发storage事件。\n大小：5M（跟浏览器厂商有关系）\nlocalStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡\n受同源策略的限制\n\n使用// 设置localStorage.setItem(&#x27;username&#x27;,&#x27;cfangxu&#x27;)// 获取localStorage.getItem(&#x27;username&#x27;)// 获取键名localStorage.key(0) //获取第一个键名// 删除localStorage.removeItem(&#x27;username&#x27;)// 一次性清除所有存储localStorage.clear()\n\nlocalStorage 也不是完美的，它有两个缺点：\n\n无法像Cookie一样设置过期时间\n只能存入字符串，无法直接存对象\n\nlocalStorage.setItem(&#x27;key&#x27;, &#123;name: &#x27;value&#x27;&#125;);console.log(localStorage.getItem(&#x27;key&#x27;)); // &#x27;[object, Object]&#x27;\n\nsessionStoragesessionStorage和 localStorage使用方法基本一致，唯一不同的是生命周期，一旦页面（会话）关闭，sessionStorage 将会删除数据\n区别关于cookie、sessionStorage、localStorage三者的区别主要如下：\n\n存储大小：cookie数据大小不能超过4k，sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大\n有效时间：localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage数据在当前浏览器窗口关闭后自动删除；cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n数据与服务器之间的交互方式，cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端； sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存\n\nindexedDBindexedDB是一种低级API，用于客户端存储大量结构化数据(包括, 文件&#x2F; blobs)。该API使用索引来实现对该数据的高性能搜索。\n虽然 Web Storage对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案。\n优点：\n\n储存量理论上没有上限\n所有操作都是异步的，相比 LocalStorage 同步操作性能更高，尤其是数据量较大时\n原生支持储存JS的对象\n是个正经的数据库，意味着数据库能干的事它都能干\n\n缺点：\n\n操作非常繁琐\n本身有一定门槛\n\n关于indexedDB的使用基本使用步骤如下：\n\n打开数据库并且开始一个事务\n创建一个 object store\n构建一个请求来执行一些数据库操作，像增加或提取数据等。\n通过监听正确类型的 DOM 事件以等待操作完成。\n在操作结果上进行一些操作（可以在 request对象中找到）\n\n关于使用indexdb的使用会比较繁琐，大家可以通过使用Godb.js库进行缓存，最大化的降低操作难度。\n应用场景在了解了上述的前端的缓存方式后，我们可以看看针对不对场景的使用选择：\n\n标记用户与跟踪用户行为的情况，推荐使用cookie\n适合长期保存在本地的数据（令牌），推荐使用localStorage\n敏感账号一次性登录，推荐使用sessionStorage\n存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用indexedDB\n\n","categories":["JavaScript"],"tags":["cookie","session","localStorage","sessionStorage","indexedDB"]},{"title":"常见算法","url":"/2022/10/23/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/","content":"什么是算法算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。\n可以这样理解，算法是用来解决特定问题的一系列步骤；算法必须具备如下3个重要特性：\n\n有穷性。执行有限步骤后，算法必须中止。\n\n确切性。算法的每个步骤都必须确切定义。\n\n可行性。特定算法须可以在特定的时间内解决特定问题。\n\n\n分治法分而治之是算法设计中的一种方法，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并\n关于分而治之的实现，都会经历三个步骤：\n\n分解：将原问题分解为若干个规模较小，相对独立，与原问题形式相同的子问题\n解决：若子问题规模较小且易于解决时，则直接解。否则，递归地解决各子问题\n合并：将各子问题的解合并为原问题的解\n\n实际上，关于分而治之的思想，归并排序同样经历了实现分而治之的三个步骤：\n\n分解：把数组从中间一分为二\n解决：递归地对两个子数组进行归并排序\n合并：将两个字数组合并称有序数组\n\n同样关于快速排序的实现，亦如此：\n\n分：选基准，按基准把数组分成两个字数组\n解：递归地对两个字数组进行快速排序\n合：对两个字数组进行合并\n\n同样二分搜索也能使用分而治之的思想去实现，代码如下：\nfunction binarySearch(arr,l,r,target)&#123;  if(l&gt; r)&#123;    return -1;  &#125;  let mid = l + Math.floor((r-l)/2)  if(arr[mid] === target)&#123;    return mid;  &#125;else if(arr[mid] &lt; target )&#123;    return binarySearch(arr,mid + 1,r,target)  &#125;else&#123;    return binarySearch(arr,l,mid - 1,target)  &#125;&#125;\n\n动态规划动态规划，同样是算法设计中的一种方法，是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。\n常常适用于有重叠子问题和最优子结构性质的问题。\n简单来说，动态规划其实就是，给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决；然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。\n一般这些子问题很相似，可以通过函数关系式递推出来，例如斐波那契数列，我们可以得到公式：当 n 大于 2的时候，F(n) &#x3D; F(n-1) + F(n-2) ，f(10)&#x3D; f(9)+f(8),f(9) &#x3D; f(8) + f(7)…是重叠子问题，当n &#x3D; 1、2的时候，对应的值为2，这时候就通过可以使用一个数组记录每一步计算的结果，以此类推，减少不必要的重复计算。\n适用场景如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划。\n比如一些求最值的场景，如最长递增子序列、最小编辑距离、背包问题、凑零钱问题等等，都是动态规划的经典应用场景。\n关于动态规划题目解决的步骤，一般如下：\n\n描述最优解的结构\n递归定义最优解的值\n按自底向上的方式计算最优解的值\n由计算出的结果构造一个最优解\n\n与分治法区别动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的，而分而治之的子问题是相互独立的；若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。\n如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。\n综上，可得：\n\n动态规划：有最优子结构和重叠子问题\n分而治之：各子问题独立\n\n贪心算法贪心算法，又称贪婪算法，是算法设计中的一种思想。\n其期待每一个阶段都是局部最优的选择，从而达到全局最优，但是结果并不一定是最优的。\n举个零钱兑换的例子，如果你有1元、2元、5元的钱币数张，用于兑换一定的金额，但是要求兑换的钱币张数最少；如果现在你要兑换11元，按照贪心算法的思想，先选择面额最大的5元钱币进行兑换，那么就得到11 &#x3D; 5 + 5 + 1 的选择，这种情况是最优的；但是如果你手上钱币的面额为1、3、4，想要兑换6元，按照贪心算法的思路，我们会 6 &#x3D; 4 + 1 + 1这样选择，这种情况结果就不是最优的选择。\n从上面例子可以看到，贪心算法存在一些弊端，使用到贪心算法的场景，都会存在一个特性：\n一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。\n至于是否选择贪心算法，主要看是否有如下两大特性：\n\n贪心选择：当某一个问题的整体最优解可通过一系列局部的最优解的选择达到，并且每次做出的选择可以依赖以前做出的选择，但不需要依赖后面需要做出的选择\n最优子结构：如果一个问题的最优解包含其子问题的最优解，则此问题具备最优子结构的性质。问题的最优子结构性质是该问题是否可以用贪心算法求解的关键所在\n\n回溯算法回溯算法，也是算法设计中的一种思想，是一种渐进式寻找并构建问题解决方式的策略。\n回溯算法会先从一个可能的工作开始解决问题，如果不行，就回溯并选择另一个动作，直到将问题解决。\n使用回溯算法的问题，有如下特性：\n\n有很多路，例如一个矩阵的方向或者树的路径\n在这些的路里面，有死路也有生路，思路即不符合题目要求的路，生路则符合\n通常使用递归来模拟所有的路\n\n例如经典使用回溯算法为解决全排列的问题，如下：\n一个不含重复数字的数组 nums ，我们要返回其所有可能的全排列，解决这个问题的思路是：\n\n用递归模拟所有的情况\n遇到包含重复元素的情况则回溯\n收集到所有到达递归终点的情况，并返回\n\n用代码表示则如下：\nvar permute = function(nums) &#123;  const res = [], path = [];  backtracking(nums, nums.length, []);  return res;  function backtracking(n, k, used) &#123;    if(path.length === k) &#123;      res.push(Array.from(path));      return;    &#125;    for (let i = 0; i &lt; k; i++ ) &#123;      if(used[i]) continue;      path.push(n[i]);      used[i] = true; // 同支      backtracking(n, k, used);      path.pop();      used[i] = false;    &#125;  &#125;&#125;;\n\n总结分而治之、动态规划、贪心策略三者对应的经典问题如下：\n分治法\n\n归并排序\n最大子数组问题1\n逆序计数问题\n快速排序\n次序选择问题\n\n动态规划\n\n0-1背包问题\n最大子数组问题2\n最长公共子序列问题\n最长公共子串问题\n最小编辑距离问题\n钢条切割问题\n矩阵链乘法问题\n\n贪心算法\n\n部分背包问题\n霍夫曼编码\n活动选择问题\n\n","categories":["算法"],"tags":["分治法","动态规划","贪心算法","回溯算法"]},{"title":"js事件循环","url":"/2022/10/23/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","content":"事件循环JavaScript 有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。这个模型与其它语言中的模型截然不同，比如 C 和 Java。\n栈函数调用形成了一个由若干帧组成的栈。\nfunction foo(b) &#123;  let a = 10;  return a + b + 11;&#125;function bar(x) &#123;  let y = 3;  return foo(x * y);&#125;console.log(bar(7)); // 返回 42\n\n当调用 bar 时，第一个帧被创建并压入栈中，帧中包含了 bar 的参数和局部变量。当 bar 调用 foo 时，第二个帧被创建并被压入栈中，放在第一个帧之上，帧中包含 foo 的参数和局部变量。当 foo 执行完毕然后返回时，第二个帧就被弹出栈（剩下 bar 函数的调用帧）。当 bar 也执行完毕然后返回时，第一个帧也被弹出，栈就被清空了。\n堆对象被分配在堆中，堆是一个用来表示一大块（通常是非结构化的）内存区域的计算机术语。\n队列一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数。\n在 事件循环 期间的某个时刻，运行时会从最先进入队列的消息开始处理队列中的消息。被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。\n函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。\n同步任务和异步任务在JavaScript中，所有的任务都可以分为\n\n同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行\n异步任务：异步执行的任务，比如ajax网络请求，setTimeout定时函数等\n\n同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就事件循环。\n宏任务与微任务异步任务还可以细分为微任务与宏任务\n微任务一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前\n常见的微任务有：\n\nPromise.then\nMutaionObserver\nObject.observe（已废弃；Proxy 对象替代）\nprocess.nextTick（Node.js）\n\n宏任务宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合\n常见的宏任务有：\n\nscript （整体代码）\nsetTimeout/setInterval\nUI rendering/UI事件\npostMessage、MessageChannel\nsetImmediate、I/O（Node.js）\nrequestAnimationFrame （浏览器独有）\n\n宏任务setTimeout的误区setTimeout的回调不一定在指定时间后能执行。而是在指定时间后，将回调函数放入事件循环的队列中。\n如果时间到了，JS引擎还在执行同步任务，这个回调函数需要等待；如果当前事件循环的队列里还有其他回调，需要等其他回调执行完。\n另外，setTimeout 0ms 也不是立刻执行，它有一个默认最小时间，为4ms。\n所以下面这段代码的输出结果不一定：\n// nodesetTimeout(() =&gt; &#123;  console.log(&#x27;setTimeout&#x27;)&#125;, 0)setImmediate(() =&gt; &#123;  console.log(&#x27;setImmediate&#x27;)&#125;)\n\n因为取出第一个宏任务之前在执行全局Script，如果这个时间大于 4ms，这时 setTimeout 的回调函数已经放入队列，就先执行 setTimeout；如果准备时间小于 4ms，就会先执行 setImmediate。\n执行机制\n首先，事件循环从宏任务队列开始。此时，宏任务队列中，只有一个 script (整体代码)任务\n同步任务直接进入主线程中执行\n异步任务则判断为宏任务还是微任务，放入对应的任务队列中\n一旦执行栈中的所有同步任务执行完毕，查询微任务队列，取出一个任务，进入执行栈执行（从第二步开始重复上述步骤）\n微任务队列清空完毕后，渲染并且更新界面\n处理worker相关的任务\n开启下一轮的事件循环，查询宏任务队列，加载下一个宏任务\n\n每轮循环都是由一个宏任务+多个微任务组成。\n为什么分宏任务与微任务微任务是线程之间的切换，速度快。不用进行上下文切换，可以快速的一次性做完所有的微任务。\n宏任务是进程之间的切换，速度慢，且每次执行需要切换上下文。因此一个Eventloop中只执行一个宏任务。\n事件循环中的任务被分为宏任务和微任务，是为了给高优先级任务一个插队的机会：微任务比宏任务有更高优先级。由于微任务执行快，一次性可以执行很多个，在当前宏任务执行后立刻清空微任务可以达到伪同步的效果，这对视图渲染效果起到至关重要的作用。\n例子async function async1() &#123;  console.log(&#x27;async1 start&#x27;)  await async2()  console.log(&#x27;async1 end&#x27;)&#125;async function async2() &#123;  console.log(&#x27;async2&#x27;)&#125;console.log(&#x27;script start&#x27;)setTimeout(function () &#123;  console.log(&#x27;settimeout&#x27;)&#125;)async1()new Promise(function (resolve) &#123;  console.log(&#x27;promise1&#x27;)  resolve()&#125;).then(function () &#123;  console.log(&#x27;promise2&#x27;)&#125;)console.log(&#x27;script end&#x27;)\n\n分析过程：\n\n执行整段代码，遇到 console.log(&#39;script start&#39;) 直接打印结果，输出 script start\n遇到定时器了，它是宏任务，先放着不执行\n遇到 async1()，执行 async1 函数，先打印 async1 start，下面遇到await怎么办？先执行 async2，打印 async2，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码\n跳到 new Promise 这里，直接执行，打印 promise1，下面遇到 .then()，它是微任务，放到微任务列表等待执行\n最后一行直接打印 script end，现在同步代码执行完了，开始执行微任务，即 await下面的代码，打印 async1 end\n继续执行下一个微任务，即执行 then 的回调，打印 promise2\n上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 settimeout\n\n所以最后的结果是：script start、async1 start、async2、promise1、script end、async1 end、promise2、settimeout\n","categories":["JavaScript"],"tags":["EventLoop"]},{"title":"二分查找","url":"/2022/05/14/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","content":"二分法在计算机科学中，二分查找算法，也称折半搜索算法，是一种在有序数组中查找某一特定元素的搜索算法\n想要应用二分查找法，则这一堆数应有如下特性：\n\n存储在数组中\n有序排序\n\n搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束\n如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较\n如果在某一步骤数组为空，则代表找不到\n这种搜索算法每一次比较都使搜索范围缩小一半\nconst arr = [1, 2, 3, 4, 6, 8, 11, 17, 23, 24, 30]function find(arr, num) &#123;  if (!Array.isArray(arr) || arr.length === 0) &#123;    return false  &#125;  let l = 0  let r = arr.length - 1  while (l &lt;= r) &#123;    let mid = Math.floor((l + r) / 2)    if (arr[mid] === num) &#123;      return true    &#125; else if (arr[mid] &lt; num) &#123;      l = mid + 1    &#125; else &#123;      r = mid - 1    &#125;  &#125;  return false&#125;console.log(find(arr,3))//trueconsole.log(find(arr,13))//falseconsole.log(find(arr,23))//trueconsole.log(find(arr,33))//false\n","categories":["算法"],"tags":["二分法"]},{"title":"时间复杂度和空间复杂度","url":"/2022/05/17/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","content":"时间复杂度常数时间的操作\n常见的算术运算(+、-、*、&#x2F;、%等)\n常见的位运算(&gt;&gt;、&gt;&gt;&gt;、&lt;&lt;、|、&amp;、^、~等)\n赋值、比较、自增、自减操作等\n数组寻址操作\n\n总之，执行时间固定的操作都是常数时间的操作。反之，执行时间不固定的操作，都不是常数时间的操作。\n估算时间复杂度\n想象该算法流程所处理的数据状况，要按照最差情况来。\n把整个流程彻底拆分为一个个基本动作，保证每个动作都是常数时间的操作。\n如果数据量为N，看看基本动作的数量和N是什么关系。\n当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。记为:O(忽略掉系数的高阶项)\n\n比如：常数时间的操作的次数为xN^2+yN+z,则时间复杂度为O(N^2)\n常见的时间复杂度O(1)、O(N)、O(logN)、O(N*logN)、O(N^2)、O(N^3)、O(N^k)、O(2^N)、O(3^N)、O(k^N)、O(N!)\n额外空间复杂度你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。作为输入参数的空间,不算额外空间。作为输出结果的空间，也不算额外空间。因为这些都是必要的、和现实目标有关的。所以都不算。但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是额外空间。如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。\n最优解一般情况下，认为解决一个问题的算法流程,在时间复杂度的指标上，一定要尽可能的低，先满足了时间复杂度最低这个指标之后，使用最少的空间的算法流程，叫这个问题的最优解。一般说起最优解都是忽略掉常数项这个因素的,因为这个因素只决定了实现层次的优化和考虑，而和怎么解决整个问题的思想无关。\n异或运算\n不申请额外的存储空间，交换两个整数的值：\nlet a = 1let b = -1a = a ^ bb = a ^ ba = a ^ bconsole.log(a) //-1console.log(b) //1\n\n一个数组中有一个数出现了奇数次，其余的数都出现偶数次，找出那个数：\nlet arr = [1,3,2,1,4,3,3,4,2]let eor = 0arr.forEach(value =&gt; &#123;  eor ^= value&#125;)console.log(eor) //3\n\n参考视频\n","categories":["算法"],"tags":["时间复杂度","额外空间复杂度"]},{"title":"DOM","url":"/2022/10/24/DOM/","content":"DOM文档对象模型 (DOM) 是 HTML 和 XML 文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将 web 页面和脚本或程序语言连接起来。\n一个 web 页面是一个文档。这个文档可以在浏览器窗口或作为 HTML 源码显示出来。但上述两个情况中都是同一份文档。文档对象模型（DOM）提供了对同一份文档的另一种表现，存储和操作的方式。DOM 是 web 页面的完全的面向对象表述，它能够使用如 JavaScript 等脚本语言进行修改。\n常用APIdocumentgetElementByIdvar element = document.getElementById(id);\n\n\n**element**是一个 Element 对象。如果当前文档中拥有特定 ID 的元素不存在则返回 null。\n**id**是大小写敏感的字符串，代表了所要查找的元素的唯一 ID。\n\ngetElementsByTagNamevar elements = document.getElementsByTagName(name);\n\n\nelements 是一个由发现的元素出现在树中的顺序构成的动态的 HTML 集合 HTMLCollection (但是，这个方法在 WebKit 内核的浏览器中返回一个 NodeList ） 。\nname 是一个代表元素的名称的字符串。特殊字符 “*” 代表了所有元素。\n\ncreateElementvar element = document.createElement(tagName[, options]);\n\n\ntagName 指定要创建元素类型的字符串。\noptions 一个可选的参数ElementCreationOptions 是包含一个属性名为 is 的对象，该对象的值是用 customElements.define() 方法定义过的一个自定义元素的标签名。\n返回值：新建的元素（Element）。\n\nNodeappendChildelement.appendChild(aChild)\n\n\naChild：要追加给父节点（通常为一个元素）的节点。\n返回值：返回追加后的子节点（aChild），除非 aChild 是一个文档片段（DocumentFragment），这种情况下将返回空文档片段（DocumentFragment）。\n\ncloneNodevar dupNode = node.cloneNode(deep);\n\n\nnode：将要被克隆的节点\ndupNode：克隆生成的副本节点\ndeep ：可选，是否采用深度克隆，如果为 true，则该节点的所有后代节点也都会被克隆，如果为 false，则只克隆该节点本身。在最新的规范里，其默认值为 false。\n\ninnerText表示一个节点及其后代的“渲染”文本内容。\nvar renderedText = HTMLElement.innerText; // 获取的文本有层次结构HTMLElement.innerText = string;\n\n只展示给人看的元素（不包括 script 和 style 元素）；受 CSS 样式的影响，并且不会返回隐藏元素的文本。\n修改innerText 会删除它的所有子节点，替换为给定的文本节点，\\n被替换为 &lt;br&gt;元素。\ntextContent属性表示一个节点及其后代的文本内容。\n可获取所有元素的内容，包括 script 和 style 元素\nlet text = someNode.textContent; // 获取的文本没有层次结构someOtherNode.textContent = string;\n\n在节点上设置 textContent 属性的话，会删除它的所有子节点，并替换为一个具有给定值的文本节点。\n使用 textContent 可以防止 XSS 攻击。\nElementinnerHTML设置或获取 HTML 语法表示的元素的后代。\nconst content = element.innerHTML;element.innerHTML = htmlString;\n\nsetAttributeelement.setAttribute(name, value);\n\n\nname：表示属性名称的字符串。\nvalue：属性的值&#x2F;新值。\n\ngetAttributelet attribute = element.getAttribute(attributeName);\n\n\nattribute 是一个包含 attributeName 属性值的字符串。\nattributeName 是你想要获取的属性值的属性名称。\n\naddEventListenerwindowonloadload 事件在整个页面及所有依赖资源如样式表和图片都已完成加载时触发。它与 DOMContentLoaded 不同，后者只要页面 DOM 加载完成就触发，无需等待依赖资源的加载。\n该事件不可取消，也不会冒泡。\n当页面完全加载后在控制台打印一段信息：\nwindow.addEventListener(&#x27;load&#x27;, (event) =&gt; &#123;  console.log(&#x27;page is fully loaded&#x27;);&#125;);\n\n也可以使用 onload 事件处理器属性实现：\nwindow.onload = (event) =&gt; &#123;  console.log(&#x27;page is fully loaded&#x27;);&#125;;\n","categories":["JavaScript"],"tags":["DOM","document"]},{"title":"事件监听器","url":"/2022/10/24/%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8/","content":"addEventListenerEventTarget.addEventListener() 方法将指定的监听器注册到 EventTarget 上，当该对象触发指定的事件时，指定的回调函数就会被执行。事件目标可以是一个文档上的元素 Element、Document 和 Window，也可以是任何支持事件的对象（比如 XMLHttpRequest）。\naddEventListener() 的工作原理是将实现 EventListener 的函数或对象添加到调用它的 EventTarget 上的指定事件类型的事件侦听器列表中。如果要绑定的函数或对象已经被添加到列表中，该函数或对象不会被再次添加。\n使用addEventListener(type, listener);addEventListener(type, listener, options);addEventListener(type, listener, useCapture);// 返回值为undefined\n\n参数\ntype\n表示监听事件类型的大小写敏感的字符串。\n\nlistener\n\n: 当所监听的事件类型触发时，会接收到一个事件通知（实现了 Event 接口的对象）对象。listener 必须是一个实现了 EventListener 接口的对象，或者是一个函数。\n\n\noptions\n 一个指定有关listener属性的可选参数对象。可用的选项如下：\n\ncapture (可选)\n一个布尔值，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。\n\nonce (可选)\n一个布尔值，表示 listener 在添加之后最多只调用一次。如果为 true，listener 会在其被调用之后自动移除。\n\npassive (可选)\n一个布尔值，设置为 true 时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。\n\nsignal (可选)\nAbortSignal，该 AbortSignal 的 abort() 方法被调用时，监听器会被移除。\n\n\n\nuseCapture\n一个布尔值，表示在 DOM 树中注册了 listener 的元素，是否要先于它下面的 EventTarget 调用该 listener。当 useCapture（设为 true）时，沿着 DOM 树向上冒泡的事件不会触发 listener。当一个元素嵌套了另一个元素，并且两个元素都对同一事件注册了一个处理函数时，所发生的事件冒泡和事件捕获是两种不同的事件传播方式。事件传播模式决定了元素以哪个顺序接收事件。如果没有指定，useCapture 默认为 false。\n\n\nremoveEventListenerEventTarget 的 removeEventListener() 方法可以删除使用 EventTarget.addEventListener() 方法添加的事件。可以使用事件类型，事件侦听器函数本身，以及可能影响匹配过程的各种可选择的选项的组合来标识要删除的事件侦听器。\n调用 removeEventListener() 时，若传入的参数不能用于确定当前注册过的任何一个事件监听器，该函数不会起任何作用。\n使用：\nremoveEventListener(type, listener);removeEventListener(type, listener, options);removeEventListener(type, listener, useCapture);\n\n\ntype\n\n一个字符串，表示需要移除的事件类型。\n\nlistener\n\n需要从目标事件移除的事件监听器函数。\n\noptions (可选)\n一个指定事件侦听器特征的可选对象。可选项有：\n\ncapture: 一个布尔值，指定需要移除的事件监听器函数是否为捕获监听器。如果未指定此参数，默认值为 false。\n\n\nuseCapture (可选)\n\n\n一个布尔值，指定需要移除的事件监听器函数是否为捕获监听器。如果未指定此参数，默认值为 false。\n例子1：\nelement.addEventListener(&quot;mousedown&quot;, handleMouseDown, true);element.removeEventListener(&quot;mousedown&quot;, handleMouseDown, false);     // 失败element.removeEventListener(&quot;mousedown&quot;, handleMouseDown, true);      // 成功\n\n第一个调用失败是因为 useCapture 没有匹配。第二个调用成功，是因为 useCapture 匹配相同。\n例子2：\nelement.addEventListener(&quot;mousedown&quot;, handleMouseDown, &#123; passive: true &#125;);\n\n这里，我们在 options 对象里将 passive 设成 true，其他 options 配置都是默认值 false。\n现在我们看下下面的 removeEventListener()。当配置 capture 或 useCapture 为 true 时，移除事件失败；其他所有都是成功的。这说明只有 capture 配置影响 removeEventListener()。js\nelement.removeEventListener(&quot;mousedown&quot;, handleMouseDown, &#123; passive: true &#125;);     // 成功element.removeEventListener(&quot;mousedown&quot;, handleMouseDown, &#123; capture: false &#125;);    // 成功element.removeEventListener(&quot;mousedown&quot;, handleMouseDown, &#123; capture: true &#125;);     // 失败element.removeEventListener(&quot;mousedown&quot;, handleMouseDown, &#123; passive: false &#125;);    // 成功element.removeEventListener(&quot;mousedown&quot;, handleMouseDown, false);                 // 成功element.removeEventListener(&quot;mousedown&quot;, handleMouseDown, true);                  // 失败\n","categories":["JavaScript"],"tags":["addEventListener","removeEventListener"]},{"title":"js循环","url":"/2022/10/24/js%E5%BE%AA%E7%8E%AF/","content":"遍历器JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。\n遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\nIterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。\nIterator 的遍历过程是这样的:\n\n创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\n\n第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。\n\n第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。\n\n不断调用指针对象的next方法，直到它指向数据结构的结束位置。\n\n\n每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。\nSymbol.iteratorES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内。\n原生具备 Iterator 接口的数据结构如下。\n\nArray\nMap\nSet\nString\nTypedArray\n函数的 arguments 对象\nNodeList 对象\n\n对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。\nclass RangeIterator &#123;  constructor(start, stop) &#123;    this.value = start;    this.stop = stop;  &#125;  [Symbol.iterator]() &#123; return this; &#125;  next() &#123;    var value = this.value;    if (value &lt; this.stop) &#123;      this.value++;      return &#123;done: false, value: value&#125;;    &#125;    return &#123;done: true, value: undefined&#125;;  &#125;&#125;function range(start, stop) &#123;  return new RangeIterator(start, stop);&#125;for (var value of range(0, 3)) &#123;  console.log(value); // 0, 1, 2&#125;\n\n上面代码是一个类部署 Iterator 接口的写法。Symbol.iterator属性对应一个函数，执行后返回当前对象的遍历器对象。\n有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for...of循环，还有几个别的场合:\n\n解构赋值\nlet set = new Set().add(&#x27;a&#x27;).add(&#x27;b&#x27;).add(&#x27;c&#x27;);let [x,y] = set;// x=&#x27;a&#x27;; y=&#x27;b&#x27;let [first, ...rest] = set;// first=&#x27;a&#x27;; rest=[&#x27;b&#x27;,&#x27;c&#x27;];\n\n扩展运算符(…)\n这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。\nlet arr = [...iterable];\n\nyield*\nyield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。\nlet generator = function* () &#123;  yield 1;  yield* [2,3,4];  yield 5;&#125;;var iterator = generator();iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: 3, done: false &#125;iterator.next() // &#123; value: 4, done: false &#125;iterator.next() // &#123; value: 5, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125;\n\nArray.from()\n\nMap(), Set(), WeakMap(), WeakSet()（比如new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])）\n\nPromise.all()\n\nPromise.race()\n\n\nfor 循环for 是最早出现的循环，也是最常用的，它是一种循环机制，能够满足大部分的遍历。主要是依靠角标来获取数组内成员。\n// 三个语句都可省略for (语句 1; 语句 2; 语句 3) &#123;   循环 执行的代码块...&#125;\n\nwhile 循环while 循环只要指定条件结果为 true，循环就可以一直执行代码块。\nwhile (条件)&#123;    需要执行的代码&#125;\n\ndo while 循环do**…** while 循环是 while 循环的变体。该循环会在判断条件是否为真之前执行一次代码块，然后如果条件为真的话，就会重复这个循环。\ndo&#123;    需要执行的代码&#125;while (条件);\n\nfor in 循环for … in 是在 ES5 中新增的，遍历所有可枚举的属性（包括原型上的），最好只用来循环对象。\nfor(let 成员 in 对象)&#123;    循环的代码块&#125;\n\nfor in 会遍历到对象上的原型方法,如果不想遍历原型方法和属性值，可以在循环内部判断一下,hasOwnPropery方法可以判断某属性是否是该对象的实例属性\nfor (let key in object) &#123;  if (Object.hasOwnProperty.call(object, key)) &#123;    const element = object[key];  &#125;&#125;\n\n遍历顺序：先遍历出整数属性（integer properties，按照升序），然后其他属性按照创建时候的顺序遍历出来。\nfor of 循环for…of 是在 ES6 中新增的 语句，它遍历一个可迭代的对象，Object是不行的。\nforEach 循环forEach 是 ES5 提出的，挂载在可迭代对象原型上的方法。forEach是一个遍历器，负责遍历可迭代对象。\n速度比较各循环执行速度从快到慢排序如下：\n\nfor循环、while循环、do while循环\nfor of循环\nforEach循环、map循环、reduce循环\nfor in循环\n\n","categories":["JavaScript"]},{"title":"Promise、Generator和async函数","url":"/2022/10/27/Promise%E3%80%81Generator%E5%92%8Casync%E5%87%BD%E6%95%B0/","content":"PromisePromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。\n所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\nPromise对象有以下两个特点：\n\n对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。\n一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。\n\nPromise也有一些缺点：\n\n首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。\n其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。\n第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n\n使用ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。\nconst promise = new Promise(function(resolve, reject) &#123;  // ... some code  if (/* 异步操作成功 */)&#123;    resolve(value);  &#125; else &#123;    reject(error);  &#125;&#125;);\n\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n\nresolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\nreject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\nPromise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。\npromise.then(function(value) &#123;  // success&#125;, function(error) &#123;  // failure&#125;);\n\nthen方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。这两个函数都是可选的，不一定要提供。它们都接受Promise对象传出的值作为参数。\nPromise 新建后就会立即执行。\nlet promise = new Promise(function(resolve, reject) &#123;  console.log(&#x27;Promise&#x27;);  resolve();&#125;);promise.then(function() &#123;  console.log(&#x27;resolved.&#x27;);&#125;);console.log(&#x27;Hi!&#x27;);// Promise// Hi!// resolved\n\n上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。\n注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。\nnew Promise((resolve, reject) =&gt; &#123;  resolve(1);  console.log(2);&#125;).then(r =&gt; &#123;  console.log(r);&#125;);// 2// 1\n\n上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。\n一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。\nnew Promise((resolve, reject) =&gt; &#123;  return resolve(1);  // 后面的语句不会执行  console.log(2);&#125;)\n\n实例方法thenPromise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数，它们都是可选的。\nthen方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\ngetJSON(&quot;/post/1.json&quot;).then(  post =&gt; getJSON(post.commentURL)).then(  comments =&gt; console.log(&quot;resolved: &quot;, comments),  err =&gt; console.log(&quot;rejected: &quot;, err));\n\n采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。\ncatchPromise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。\ngetJSON(&#x27;/posts.json&#x27;).then(function(posts) &#123;  // ...&#125;).catch(function(error) &#123;  // 处理 getJSON 和 前一个回调函数运行时发生的错误  console.log(&#x27;发生错误！&#x27;, error);&#125;);\n\n上面代码中，getJSON()方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then()方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch()方法指定的回调函数，处理这个错误。另外，then()方法指定的回调函数，如果运行中抛出错误，也会被catch()方法捕获。\nPromise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。\n一般来说，不要在then()方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。\nfinallyfinally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。\npromise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;);\n\n上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。\nfinally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。\nPromise方法allPromise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。\nconst p = Promise.all([p1, p2, p3]);\n\n上面代码中，Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。\np的状态由p1、p2、p3决定，分成两种情况：\n\n只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。\n\n只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。\n\n\n注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。\nconst p1 = new Promise((resolve, reject) =&gt; &#123;  resolve(&#x27;hello&#x27;);&#125;).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123;  throw new Error(&#x27;报错了&#x27;);&#125;).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// [&quot;hello&quot;, Error: 报错了]\n\n上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。\nracePromise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。\nconst p = Promise.race([p1, p2, p3]);\n\n上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。\nPromise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。\n下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。\nconst p = Promise.race([  fetch(&#x27;/resource-that-may-take-a-while&#x27;),  new Promise(function (resolve, reject) &#123;    setTimeout(() =&gt; reject(new Error(&#x27;request timeout&#x27;)), 5000)  &#125;)]);p.then(console.log).catch(console.error);\n\n上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。\nallSettledES2020 引入了Promise.allSettled()方法，用来确定一组异步操作是否都结束了（不管成功或失败）。所以，它的名字叫做”Settled“，包含了”fulfilled“和”rejected“两种情况。\nPromise.allSettled()方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是fulfilled还是rejected），返回的 Promise 对象才会发生状态变更。\n该方法返回的新的 Promise 实例，一旦发生状态变更，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 Promise 对象。\nconst resolved = Promise.resolve(42);const rejected = Promise.reject(-1);const allSettledPromise = Promise.allSettled([resolved, rejected]);allSettledPromise.then(function (results) &#123;  console.log(results);&#125;);// [//    &#123; status: &#x27;fulfilled&#x27;, value: 42 &#125;,//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;// ]\n\nresults的每个成员是一个对象，对象的格式是固定的，对应异步操作的结果。\n// 异步操作成功时&#123;status: &#x27;fulfilled&#x27;, value: value&#125;// 异步操作失败时&#123;status: &#x27;rejected&#x27;, reason: reason&#125;\n\n成员对象的status属性的值只可能是字符串fulfilled或字符串rejected，用来区分异步操作是成功还是失败。如果是成功（fulfilled），对象会有value属性，如果是失败（rejected），会有reason属性，对应两种状态时前面异步操作的返回值。\nanyES2021 引入了Promise.any()方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。\nPromise.any([  fetch(&#x27;https://v8.dev/&#x27;).then(() =&gt; &#x27;home&#x27;),  fetch(&#x27;https://v8.dev/blog&#x27;).then(() =&gt; &#x27;blog&#x27;),  fetch(&#x27;https://v8.dev/docs&#x27;).then(() =&gt; &#x27;docs&#x27;)]).then((first) =&gt; &#123;  // 只要有一个 fetch() 请求成功  console.log(first);&#125;).catch((error) =&gt; &#123; // 所有三个 fetch() 全部请求失败  console.log(error);&#125;);\n\n只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。\nresolve有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。\nPromise.resolve()方法的参数分成四种情况：\n\n参数是一个 Promise 实例\n如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。\n\n参数是一个thenable对象\nthenable对象指的是具有then方法的对象，比如下面这个对象。\nlet thenable = &#123;  then: function(resolve, reject) &#123;    resolve(42);  &#125;&#125;;\n\nPromise.resolve()方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then()方法。\n\n参数不是具有then()方法的对象，或根本就不是对象\n如果参数是一个原始值，或者是一个不具有then()方法的对象，则Promise.resolve()方法返回一个新的 Promise 对象，状态为resolved。Promise.resolve()方法的参数，会同时传给回调函数。\nconst p = Promise.resolve(&#x27;Hello&#x27;);p.then(function (s) &#123;  console.log(s)&#125;);// Hello\n\n不带有任何参数\nPromise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。\n\n\nrejectPromise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。\nconst p = Promise.reject(&#x27;出错了&#x27;);// 等同于const p = new Promise((resolve, reject) =&gt; reject(&#x27;出错了&#x27;))p.then(null, function (s) &#123;  console.log(s)&#125;);// 出错了\n\nPromise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。\nGeneratorGenerator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。\nGenerator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\n执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态。\nfunction* helloWorldGenerator() &#123;  yield &#x27;hello&#x27;;  yield &#x27;world&#x27;;  return &#x27;ending&#x27;;&#125;var hw = helloWorldGenerator();\n\n上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。\n然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是一个遍历器对象。\n下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。\nhw.next()// &#123; value: &#x27;hello&#x27;, done: false &#125;hw.next()// &#123; value: &#x27;world&#x27;, done: false &#125;hw.next()// &#123; value: &#x27;ending&#x27;, done: true &#125;hw.next()// &#123; value: undefined, done: true &#125;\n\nyield 表达式由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。\n遍历器对象的next方法的运行逻辑如下：\n\n遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。\n下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。\n如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。\n如果该函数没有return语句，则返回的对象的value属性值为undefined。\n\n需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。\nfunction* gen() &#123;  yield  123 + 456;&#125;\n\n上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。\n另外，yield表达式如果用在另一个表达式之中，必须放在圆括号里面。\nfunction* demo() &#123;  console.log(&#x27;Hello&#x27; + yield); // SyntaxError  console.log(&#x27;Hello&#x27; + yield 123); // SyntaxError  console.log(&#x27;Hello&#x27; + (yield)); // OK  console.log(&#x27;Hello&#x27; + (yield 123)); // OK&#125;\n\nyield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。\nfunction* demo() &#123;  foo(yield &#x27;a&#x27;, yield &#x27;b&#x27;); // OK  let input = yield; // OK&#125;\n\nnext 方法yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。\nfunction* f() &#123;  for(var i = 0; true; i++) &#123;    var reset = yield i;    if(reset) &#123; i = -1; &#125;  &#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;g.next(true) // &#123; value: 0, done: false &#125;\n\nthrow和return方法Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。\nvar g = function* () &#123;  try &#123;    yield;  &#125; catch (e) &#123;    console.log(&#x27;内部捕获&#x27;, e);  &#125;&#125;;var i = g();i.next();try &#123;  i.throw(&#x27;a&#x27;);  i.throw(&#x27;b&#x27;);&#125; catch (e) &#123;  console.log(&#x27;外部捕获&#x27;, e);&#125;// 内部捕获 a// 外部捕获 b\n\nGenerator 函数返回的遍历器对象，还有一个return()方法，可以返回给定的值，并且终结遍历 Generator 函数。\nfunction* gen() &#123;  yield 1;  yield 2;  yield 3;&#125;var g = gen();g.next()        // &#123; value: 1, done: false &#125;g.return(&#x27;foo&#x27;) // &#123; value: &quot;foo&quot;, done: true &#125;g.next()        // &#123; value: undefined, done: true &#125;\n\n如果return()方法调用时，不提供参数，则返回值的value属性为undefined。\n如果 Generator 函数内部有try...finally代码块，且正在执行try代码块，那么return()方法会导致立刻进入finally代码块，执行完以后，整个函数才会结束。\nfunction* numbers () &#123;  yield 1;  try &#123;    yield 2;    yield 3;  &#125; finally &#123;    yield 4;    yield 5;  &#125;  yield 6;&#125;var g = numbers();g.next() // &#123; value: 1, done: false &#125;g.next() // &#123; value: 2, done: false &#125;g.return(7) // &#123; value: 4, done: false &#125;g.next() // &#123; value: 5, done: false &#125;g.next() // &#123; value: 7, done: true &#125;\n\n共同点next()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。\nnext()是将yield表达式替换成一个值。\nconst g = function* (x, y) &#123;  let result = yield x + y;  return result;&#125;;const gen = g(1, 2);gen.next(); // Object &#123;value: 3, done: false&#125;gen.next(1); // Object &#123;value: 1, done: true&#125;// 相当于将 let result = yield x + y// 替换成 let result = 1;\n\n上面代码中，第二个next(1)方法就相当于将yield表达式替换成一个值1。如果next方法没有参数，就相当于替换成undefined。\nthrow()是将yield表达式替换成一个throw语句。\ngen.throw(new Error(&#x27;出错了&#x27;)); // Uncaught Error: 出错了// 相当于将 let result = yield x + y// 替换成 let result = throw(new Error(&#x27;出错了&#x27;));\n\nreturn()是将yield表达式替换成一个return语句。\ngen.return(2); // Object &#123;value: 2, done: true&#125;// 相当于将 let result = yield x + y// 替换成 let result = return 2;\n\nyield* 表达式如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。\nES6 提供了yield*表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。\nfunction* bar() &#123;  yield &#x27;x&#x27;;  yield* foo();  yield &#x27;y&#x27;;&#125;// 等同于function* bar() &#123;  yield &#x27;x&#x27;;  yield &#x27;a&#x27;;  yield &#x27;b&#x27;;  yield &#x27;y&#x27;;&#125;// 等同于function* bar() &#123;  yield &#x27;x&#x27;;  for (let v of foo()) &#123;    yield v;  &#125;  yield &#x27;y&#x27;;&#125;for (let v of bar())&#123;  console.log(v);&#125;// &quot;x&quot;// &quot;a&quot;// &quot;b&quot;// &quot;y&quot;\n\n从语法角度看，如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*表达式。\nasync 函数ES2017 标准引入了 async 函数，使得异步操作变得更加方便。它就是 Generator 函数的语法糖。\n一个 Generator 函数，依次读取两个文件。\nconst fs = require(&#x27;fs&#x27;);const readFile = function (fileName) &#123;  return new Promise(function (resolve, reject) &#123;    fs.readFile(fileName, function(error, data) &#123;      if (error) return reject(error);      resolve(data);    &#125;);  &#125;);&#125;;const gen = function* () &#123;  const f1 = yield readFile(&#x27;/etc/fstab&#x27;);  const f2 = yield readFile(&#x27;/etc/shells&#x27;);  console.log(f1.toString());  console.log(f2.toString());&#125;;\n\n上面代码的函数gen可以写成async函数，就是下面这样。\nconst asyncReadFile = async function () &#123;  const f1 = await readFile(&#x27;/etc/fstab&#x27;);  const f2 = await readFile(&#x27;/etc/shells&#x27;);  console.log(f1.toString());  console.log(f2.toString());&#125;;\n\nasync函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。\nasync函数对 Generator 函数的改进，体现在以下四点：\n\n内置执行器。\nGenerator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。\n上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。\n\n更好的语义。\nasync和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n\n更广的适用性。\nco模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。\n\n返回值是 Promise。\nasync函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。\n\n\n进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\n基本用法async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\nawait 命令正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。\nasync function f() &#123;  // 等同于  // return 123;  return await 123;&#125;f().then(v =&gt; console.log(v))// 123\n\n任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。\nasync function f() &#123;  await Promise.reject(&#x27;出错了&#x27;);  await Promise.resolve(&#x27;hello world&#x27;); // 不会执行&#125;\n\n上面代码中，第二个await语句是不会执行的，因为第一个await语句状态变成了reject。\n有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try...catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。\nasync function f() &#123;  try &#123;    await Promise.reject(&#x27;出错了&#x27;);  &#125; catch(e) &#123;  &#125;  return await Promise.resolve(&#x27;hello world&#x27;);&#125;f().then(v =&gt; console.log(v))// hello world\n\n另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。\nasync function f() &#123;  await Promise.reject(&#x27;出错了&#x27;)    .catch(e =&gt; console.log(e));  return await Promise.resolve(&#x27;hello world&#x27;);&#125;f().then(v =&gt; console.log(v))// 出错了// hello world\n\n错误处理如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。\nasync function f() &#123;  await new Promise(function (resolve, reject) &#123;    throw new Error(&#x27;出错了&#x27;);  &#125;);&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))// Error：出错了\n\n上面代码中，async函数f执行后，await后面的 Promise 对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。\n防止出错的方法，也是将其放在try...catch代码块之中。\nasync function f() &#123;  try &#123;    await new Promise(function (resolve, reject) &#123;      throw new Error(&#x27;出错了&#x27;);    &#125;);  &#125; catch(e) &#123;  &#125;  return await(&#x27;hello world&#x27;);&#125;\n\n如果有多个await命令，可以统一放在try...catch结构中。\nasync function main() &#123;  try &#123;    const val1 = await firstStep();    const val2 = await secondStep(val1);    const val3 = await thirdStep(val1, val2);    console.log(&#x27;Final: &#x27;, val3);  &#125;  catch (err) &#123;    console.error(err);  &#125;&#125;\n\n下面的例子使用try...catch结构，实现多次重复尝试。\nconst superagent = require(&#x27;superagent&#x27;);const NUM_RETRIES = 3;async function test() &#123;  let i;  for (i = 0; i &lt; NUM_RETRIES; ++i) &#123;    try &#123;      await superagent.get(&#x27;http://google.com/this-throws-an-error&#x27;);      break;    &#125; catch(err) &#123;&#125;  &#125;  console.log(i); // 3&#125;test();\n\n上面代码中，如果await操作成功，就会使用break语句退出循环；如果失败，会被catch语句捕捉，然后进入下一轮循环。\n注意点\nawait命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。\n\n多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。\nlet foo = await getFoo();let bar = await getBar();\n\n上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。\n// 写法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise;\n\n上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。\n\nawait命令只能用在async函数之中，如果用在普通函数，就会报错。\n\n将forEach方法的参数改成async函数，也有问题。\nfunction dbFuc(db) &#123; //这里不需要 async  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];  // 可能得到错误结果  docs.forEach(async function (doc) &#123;    await db.post(doc);  &#125;);&#125;\n\n上面代码可能不会正常工作，原因是这时三个db.post()操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。\nasync function dbFuc(db) &#123;  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];  for (let doc of docs) &#123;    await db.post(doc);  &#125;&#125;\n\n另一种方法是使用数组的reduce()方法。\nasync function dbFuc(db) &#123;  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];  await docs.reduce(async (_, doc) =&gt; &#123;    await _;    await db.post(doc);  &#125;, undefined);&#125;\n\nreduce()方法的第一个参数是async函数，导致该函数的第一个参数是前一步操作返回的 Promise 对象，所以必须使用await等待它操作结束。另外，reduce()方法返回的是docs数组最后一个成员的async函数的执行结果，也是一个 Promise 对象，导致在它前面也必须加上await。\n上面的reduce()的参数函数里面没有return语句，原因是这个函数的主要目的是db.post()操作，不是返回值。而且async函数不管有没有return语句，总是返回一个 Promise 对象，所以这里的return是不必要的。\n\n\n原理async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。\nasync function fn(args) &#123;  // ...&#125;// 等同于function fn(args) &#123;  return spawn(function* () &#123;    // ...  &#125;);&#125;\n\n所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。\n下面给出spawn函数的实现：\nfunction spawn(genF) &#123;  return new Promise(function(resolve, reject) &#123;    const gen = genF();    function step(nextF) &#123;      let next;      try &#123;        next = nextF();      &#125; catch(e) &#123;        return reject(e);      &#125;      if(next.done) &#123;        return resolve(next.value);      &#125;      Promise.resolve(next.value).then(function(v) &#123;        step(function() &#123; return gen.next(v); &#125;);      &#125;, function(e) &#123;        step(function() &#123; return gen.throw(e); &#125;);      &#125;);    &#125;    step(function() &#123; return gen.next(undefined); &#125;);  &#125;);&#125;\n\n比较Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。\n","categories":["JavaScript"],"tags":["Promise","Generator","async","await"]},{"title":"flex布局","url":"/2022/10/27/flex%E5%B8%83%E5%B1%80/","content":"flexboxFlexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。它给 flexbox 的子元素之间提供了强大的空间分布和对齐能力。一个 flexbox 一次只能处理一个维度上的元素布局，一行或者一列。作为对比的是另外一个二维布局 Grid Layout，可以同时处理行和列上的布局。\n轴线当使用 flex 布局时，首先想到的是两根轴线 — 主轴和交叉轴。主轴由 flex-direction 定义，另一根轴（交叉轴）垂直于它。我们使用 flexbox 的所有属性都跟这两根轴线有关，所以有必要在一开始首先理解它。\nflex-direction主轴由 flex-direction 定义，可以取 4 个值：\n\nrow\nrow-reverse\ncolumn\ncolumn-reverse\n\n如果你选择了 row 或者 row-reverse，你的主轴将沿着 inline 方向（水平）延伸。选择 column 或者 column-reverse 时，你的主轴会沿着垂直方向延伸，也就是 block 排列的方向。\n理解主轴和交叉轴的概念对于对齐 flexbox 里面的元素是很重要的；flexbox 的特性是沿着主轴或者交叉轴对齐之中的元素。\nFlex容器文档中采用了 flexbox 的区域就叫做 flex 容器。为了创建 flex 容器，我们把一个容器的 display 属性值改为 flex 或者 inline-flex。完成这一步之后，容器中的直系子元素就会变为 flex 元素。所有 CSS 属性都会有一个初始值，所以 flex 容器中的所有 flex 元素都会有下列行为：\n\n元素排列为一行 (flex-direction 属性的初始值是 row)。\n元素从主轴的起始线开始。\n元素不会在主轴方向拉伸，但是可以缩小。\n元素被拉伸来填充交叉轴大小。\nflex-basis 属性为 auto。\nflex-wrap 属性为 nowrap。\n\n这会让你的元素呈线形排列，并且把自己的大小作为主轴上的大小。如果有太多元素超出容器，它们会溢出而不会换行。如果一些元素比其他元素高，那么元素会沿交叉轴被拉伸来填满它的大小。\nflex-wrap虽然flexbox是一维模型，但可以使我们的flex项目应用到多行中。在这样做的时候，您应该把每一行看作一个新的flex容器。任何空间分布都将在该行上发生，而不影响该空间分布的其他行。\n为了实现多行效果，请为属性flex-wrap添加一个属性值wrap。如果您的项目太大而无法全部显示在一行中，则会换行显示。\n于flex-wrap的值设置为wrap，所以项目的子元素换行显示。若将其设置为nowrap，这也是初始值，它们将会缩小以适应容器，因为它们使用的是允许缩小的初始Flexbox值。如果项目的子元素无法缩小，使用nowrap会导致溢出，或者缩小程度还不够小。\nflex-flow 简写属性可以将两个属性 flex-direction 和 flex-wrap 组合为简写属性 flex-flow。第一个指定的值为 flex-direction ，第二个指定的值为 flex-wrap。\nflex属性为了更好地控制 flex 元素，有三个属性可以作用于它们。\nflex-basisflex-basis 定义了该元素的空间大小，flex 容器里除了元素所占的空间以外的富余空间就是可用空间。该属性的默认值是 auto 。此时，浏览器会检测这个元素是否具有确定的尺寸。如果没有给元素设定尺寸，flex-basis 的值采用元素内容的尺寸。\nflex-growflex-grow 若被赋值为一个正整数，flex 元素会以 flex-basis 为基础，沿主轴方向增长尺寸。这会使该元素延展，并占据此方向轴上的可用空间。如果有其他元素也被允许延展，那么他们会各自占据可用空间的一部分。\nflex-grow 属性可以按比例分配空间。一行上有三个元素时，如果第一个元素 flex-grow 值为 2，其他元素值为 1，则第一个元素将占有 2&#x2F;4, 另外两个元素各占有 1&#x2F;4。\nflex-shrink与flex-grow 相反，flex-shrink属性是处理 flex 元素收缩的问题。\n如果我们的容器中没有足够排列 flex 元素的空间，那么可以把 flex 元素flex-shrink属性设置为正整数来缩小它所占空间到flex-basis以下。与flex-grow属性一样，可以赋予不同的值来控制 flex 元素收缩的程度 —— 给flex-shrink属性赋予更大的数值可以比赋予小数值的同级元素收缩程度更大。\n在计算 flex 元素收缩的大小时，它的最小尺寸也会被考虑进去，就是说实际上 flex-shrink 属性可能会和 flex-grow 属性表现的不一致。\nflex 简写属性Flex 简写形式允许你把三个数值按这个顺序书写 ： flex-grow，flex-shrink，flex-basis。\n第一个数值是 flex-grow。赋值为正数的话是让元素增加所占空间。第二个数值是flex-shrink — 正数可以让它缩小所占空间，但是只有在 flex 元素总和超出主轴才会生效。最后一个数值是 flex-basis；flex 元素是在这个基准值的基础上缩放的。\n大多数情况下还可以用预定义的简写形式：\n\nflex: initial\n是把 flex 元素重置为 Flexbox 的初始值，它相当于 flex: 0 1 auto。\n\nflex: auto\n等同于 flex: 1 1 auto。\n\nflex: none\n可以把 flex 元素设置为不可伸缩。它和设置为 flex: 0 0 auto 是一样的。\n\nflex: &lt;positive-number&gt;\n常看到的 flex: 1 或者 flex: 2 等等。它相当于flex: 1 1 0。元素可以在flex-basis为 0 的基础上伸缩。\n\n\nalign-itemsalign-items 属性可以使元素在交叉轴方向对齐。\n\nstretch：初始值，最高的元素定义了容器的高度。\nflex-start：按 flex 容器的顶部对齐。\nflex-end：按 flex 容器的尾部对齐。\ncenter：居中对齐。\n\njustify-contentjustify-content属性用来使元素在主轴方向上对齐，主轴方向是通过 flex-direction 设置的方向。\n\nflex-start：初始值，元素从容器的起始线排列。\n\nflex-end：从终止线开始排列。\n\ncenter：在中间排列。\n\nspace-between：把元素排列好之后的剩余空间拿出来，平均分配到元素之间，所以元素之间间隔相等。\n\nspace-around：使每个元素的左右空间相等。\n\n\n","categories":["css"],"tags":["flex"]},{"title":"this对象","url":"/2022/10/29/this%E5%AF%B9%E8%B1%A1/","content":"定义函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别。\n在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定）。\nthis 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象，指代函数当前的运行环境。\n同时，this在函数执行过程中，this一旦被确定了，就不可以再更改。\n默认绑定全局环境中定义person函数，内部使用this关键字\nvar name = &#x27;Jenny&#x27;;function person() &#123;    return this.name;&#125;console.log(person());  //Jenny\n\n上述代码输出Jenny，原因是调用函数的对象在游览器中位window，因此this指向window，所以输出Jenny\n注意：严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象。\n隐式绑定函数还可以作为某个对象的方法调用，这时this就指这个上级对象\nfunction test() &#123;  console.log(this.x);&#125;var obj = &#123;&#125;;obj.x = 1;obj.m = test;obj.m(); // 1\n\n这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象\nvar o = &#123;  a:10,  b:&#123;    fn:function()&#123;      console.log(this.a); //undefined    &#125;  &#125;&#125;o.b.fn();\n\n上述代码中，this的上一级对象为b，b内部并没有a变量的定义，所以输出undefined\nvar o = &#123;  a:10,  b:&#123;    a:12,    fn:function()&#123;      console.log(this.a); //undefined      console.log(this); //window    &#125;  &#125;&#125;var j = o.b.fn;j();\n\n此时this指向的是window，这里的大家需要记住，this永远指向的是最后调用它的对象，虽然fn是对象b的方法，但是fn赋值给j时候并没有执行，所以最终指向window\nnew绑定通过构建函数new关键字生成一个实例对象，此时this指向这个实例对象\nfunction test() &#123;　this.x = 1;&#125;var obj = new test();obj.x // 1\n\n上述代码之所以能过输出1，是因为new关键字改变了this的指向\nnew过程遇到return一个对象，此时this指向为返回的对象\nfunction fn() &#123;    this.user = &#x27;xxx&#x27;;    return &#123;&#125;;  &#125;var a = new fn();  console.log(a.user); //undefined\n\n如果返回一个简单类型的时候，则this指向实例对象\nfunction fn() &#123;    this.user = &#x27;xxx&#x27;;    return 1;&#125;var a = new fn;  console.log(a.user); //xxx\n\n注意的是null虽然也是对象，但是此时new仍然指向实例对象\nfunction fn() &#123;    this.user = &#x27;xxx&#x27;;    return null;&#125;var a = new fn;  console.log(a.user); //xxx\n\n显示修改apply()、call()、bind()是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时this指的就是这第一个参数\nvar x = 0;function test() &#123;　console.log(this.x);&#125;var obj = &#123;&#125;;obj.x = 1;obj.m = test;obj.m.apply(obj) // 1\n\n箭头函数在 ES6 的语法中还提供了箭头函语法，让我们在代码书写时就能确定 this 的指向（编译时绑定）\nconst obj = &#123;  sayThis: () =&gt; &#123;    console.log(this);  &#125;&#125;;obj.sayThis(); // window 因为 JavaScript 没有块作用域，所以在定义 sayThis 的时候，里面的 this 就绑到 window 上去了const globalSay = obj.sayThis;globalSay(); // window \n\n虽然箭头函数的this能够在编译的时候就确定了this的指向，但也需要注意一些潜在的坑。\n\n绑定事件监听\n\nconst button = document.getElementById(&#x27;mngb&#x27;);button.addEventListener(&#x27;click&#x27;, ()=&gt; &#123;    console.log(this === window) // true    this.innerHTML = &#x27;clicked button&#x27;&#125;)\n\n上述可以看到，我们其实是想要this为点击的button，但此时this指向了window\n\n在原型上添加方法时候，此时this指向window\n\nCat.prototype.sayName = () =&gt; &#123;    console.log(this === window) //true    return this.name&#125;const cat = new Cat(&#x27;mm&#x27;);cat.sayName()\n\n同样的，箭头函数不能作为构建函数\n事件中的this在HTML事件句柄中，this指向了接收事件的HTML元素\nlet oBtn = document.querySelector(&#x27;#btn&#x27;);oBtn.addEventListener(&#x27;click&#x27;,function()&#123;  console.log(this); //oBtn&#125;)\n\n定时器会改变this指向\noBtn.addEventListener(&#x27;click&#x27;,function()&#123;  setTimeout(function()&#123;    console.log(this); //Window  &#125;,1000)&#125;)//显示修改thisoBtn.addEventListener(&#x27;click&#x27;,function()&#123;  setTimeout(function()&#123;    console.log(this); //oBtn  &#125;.bind(this),1000) &#125;)//使用箭头函数oBtn.addEventListener(&#x27;click&#x27;,function()&#123;  setTimeout(()=&gt;&#123;    console.log(this); //oBtn  &#125;,1000)&#125;)\n\n优先级new绑定优先级 &gt; 显示绑定优先级 &gt; 隐式绑定优先级 &gt; 默认绑定优先级\n","categories":["JavaScript"],"tags":["this"]},{"title":"vue中的diff算法","url":"/2022/10/30/vue%E4%B8%AD%E7%9A%84diff%E7%AE%97%E6%B3%95/","content":"diff算法diff 算法是一种通过同层的树节点进行比较的高效算法。\n其有两个特点：\n\n比较只会在同层级进行, 不会跨层级比较\n在diff比较的过程中，循环从两边向中间比较\n\ndiff 算法在很多场景下都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较。\n比较方式传统diff算法处理方案: 循环递归每一个节点\n算法复杂度能达到O(n^2) ，查找完差异后还需计算最小转换方式，最终达到的算法复杂度是O(n^3)。\n\n将两颗树中所有的节点一一对比需要O(n²)的复杂度，在对比过程中发现旧节点在新的树中未找到，那么就需要把旧节点删除，删除一棵树的一个节点(找到一个合适的节点放到被删除的位置)的时间复杂度为O(n),同理添加新节点的复杂度也是O(n),合起来diff两个树的复杂度就是O(n³)\n\n优化的diff算法diff整体策略为：深度优先，同层比较\n\n比较只会在同层级进行, 不会跨层级比较\n比较的过程中，循环从两边向中间收拢\n\n时间复杂度为O(n)\n原理当数据发生改变时，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图。\npatchpatch函数前两个参数位为oldVnode 和 Vnode ，分别代表新的节点和之前的旧节点，主要做了四个判断：\n\n没有新节点，直接触发旧节点的destory钩子\n没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 createElm\n旧节点和新节点自身一样，通过 sameVnode 判断节点是否一样，一样时，直接调用 patchVnode去处理这两个节点\n旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点\n\npatchVnodepatchVnode用来比较两个虚拟节点的子节点并更新其子节点对应的真实Dom节点。\npatchVnode主要做了几个判断：\n\n新节点是否是文本节点，如果是，则直接更新dom的文本内容为新节点的文本内容\n新节点和旧节点如果都有子节点，则处理比较更新子节点\n只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新DOM，并且添加进父节点\n只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把DOM 删除\n\n子节点不完全一致，则调用updateChildren\nupdateChildrenupdateChildren是vue diff的核心。\nupdateChildren主要做了以下操作：\n\n设置新旧VNode的头尾指针\n新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode 节点再分情况操作\n\n过程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较。\nkey\n当我们在使用v-for时，需要给单元加上key\n\n&lt;ul&gt;    &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;...&lt;/li&gt;&lt;/ul&gt;\n\n\n用+new Date()生成的时间戳作为key，手动强制触发重新渲染\n\n&lt;Comp :key=&quot;+new Date()&quot; /&gt;\n\nkey是给每一个vnode的唯一id，也是diff的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode节点。\nvue3的diff算法Vue3.x借鉴了 ivi算法和 inferno算法。在创建VNode时就确定其类型，以及在mount&#x2F;patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。\n该算法中还运用了动态规划的思想求解最长递归子序列。\n总结由于diff算法对比的是虚拟Dom，而虚拟Dom是呈树状的，所以我们可以发现，diff算法中充满了递归。总结起来，其实diff算法就是一个 patch —&gt; patchVnode —&gt; updateChildren —&gt; patchVnode —&gt; updateChildren —&gt; patchVnode这样的一个循环递归的过程。\n","categories":["vue"],"tags":["diff算法","key"]},{"title":"nextTick原理","url":"/2022/10/30/nextTick%E5%8E%9F%E7%90%86/","content":"NextTick官方定义：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。\n我们可以理解成，Vue 在更新 DOM 时是异步执行的。当数据发生变化，Vue将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新。\n&#123;&#123;num&#125;&#125;for(let i=0; i&lt;100000; i++)&#123;    num = i&#125;\n\n如果没有 nextTick 更新机制，那么 num 每次更新值都会触发视图更新(上面这段代码也就是会更新10万次视图)，有了nextTick机制，只需要更新一次，所以nextTick本质是一种优化策略\n使用// 类型function nextTick(callback?: () =&gt; void): Promise&lt;void&gt;\n\n你可以传递一个回调函数作为参数，或者 await 返回的 Promise。\n&lt;script setup&gt;import &#123; ref, nextTick &#125; from &#x27;vue&#x27;const count = ref(0)async function increment() &#123;  count.value++  // DOM 还未更新  console.log(document.getElementById(&#x27;counter&#x27;).textContent) // 0  await nextTick()  // DOM 此时已经更新  console.log(document.getElementById(&#x27;counter&#x27;).textContent) // 1&#125;&lt;/script&gt;&lt;template&gt;  &lt;button id=&quot;counter&quot; @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;\n\n原理Vue在更新dom时是异步执行的。只要监听到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓存时去重对于避免不必要的计算和dom操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用。 \nnextTick 主要使用了宏任务和微任务。根据执行环境分别尝试采用：\n\nPromise\nMutationObserver：微任务，创建并返回一个新的 MutationObserver 它会在指定的 DOM 发生变化时被调用\nsetImmediate：宏任务，可以用来替代 setTimeout(fn, 0)\n如果以上都不行则采用 setTimeout\n\n过程：\n\n把回调函数放入callbacks等待执行\n根据执行环境，将执行函数放到微任务或者宏任务中\n事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调\n\n","categories":["vue"],"tags":["nextTick"]},{"title":"虚拟DOM","url":"/2022/10/30/%E8%99%9A%E6%8B%9FDOM/","content":"虚拟DOM实际上它只是一层对真实DOM的抽象，以JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上。\n在Javascript对象中，虚拟DOM 表现为一个 Object对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性，不同框架对这三个属性的命名可能会有差别。\n通过VNode，vue可以对这颗抽象树进行创建节点,删除节点以及修改节点的操作， 经过diff算法得出一些需要修改的最小单位,再更新视图，减少了dom操作，提高了性能。\n为什么需要DOM是很慢的，其元素非常庞大，页面的性能问题，大部分都是由DOM操作引起的。真实的DOM节点，哪怕一个最简单的div也包含着很多属性。操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验。\n举个例子：\n你用传统的原生api或jQuery去操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。当你在一次操作时，需要更新10个DOM节点，浏览器没这么智能，收到第一个更新DOM请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程。\n而通过VNode，同样更新10个DOM节点，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，避免大量的无谓计算。\n优点\ndiff算法：减少 JavaScript 操作真实 DOM 的带来的性能消耗。\n跨平台：抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是小程序，也可以是各种GUI。\n\n","categories":["JavaScript"],"tags":["VNode"]},{"title":"发布订阅模式和观察者模式","url":"/2022/10/30/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","content":"观察者模式观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。\n观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯。\n被观察者：\nclass Subject &#123;  constructor() &#123;    this.observerList = [];  &#125;  addObserver(observer) &#123;    this.observerList.push(observer);  &#125;  removeObserver(observer) &#123;    const index = this.observerList.findIndex(o =&gt; o.name === observer.name);    this.observerList.splice(index, 1);  &#125;  notifyObservers(message) &#123;    const observers = this.observeList;    observers.forEach(observer =&gt; observer.notified(message));  &#125;&#125;\n\n观察者：\nclass Observer &#123;  constructor(name, subject) &#123;    this.name = name;    if (subject) &#123;      subject.addObserver(this);    &#125;  &#125;  notified(message) &#123;    console.log(this.name, &#x27;got message&#x27;, message);  &#125;&#125;\n\n使用代码如下：\nconst subject = new Subject();const observerA = new Observer(&#x27;observerA&#x27;, subject);const observerB = new Observer(&#x27;observerB&#x27;);subject.addObserver(observerB);subject.notifyObservers(&#x27;Hello from subject&#x27;);subject.removeObserver(observerA);subject.notifyObservers(&#x27;Hello again&#x27;);\n\n上述代码中，观察者主动申请加入被观察者的列表，被观察者主动将观察者加入列表\n发布订阅模式发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。\nxxxxxxxxxx25 1const arr &#x3D; [1, 2, 3, 4, 6, 8, 11, 17, 23, 24, 30]2​3function find(arr, num) {4  if (!Array.isArray(arr) || arr.length &#x3D;&#x3D;&#x3D; 0) {5    return false6  }7  let l &#x3D; 08  let r &#x3D; arr.length - 19  while (l &lt;&#x3D; r) {10    let mid &#x3D; Math.floor((l + r) &#x2F; 2)11    if (arr[mid] &#x3D;&#x3D;&#x3D; num) {12      return true13    } else if (arr[mid] &lt; num) {14      l &#x3D; mid + 115    } else {16      r &#x3D; mid - 117    }18  }19  return false20}21​22console.log(find(arr,3))&#x2F;&#x2F;true23console.log(find(arr,13))&#x2F;&#x2F;false24console.log(find(arr,23))&#x2F;&#x2F;true25console.log(find(arr,33))&#x2F;&#x2F;falsejs\n发布者和订阅者需要通过发布订阅中心进行关联，发布者的发布动作和订阅者的订阅动作相互独立，无需关注对方，消息派发由发布订阅中心负责。\nclass PubSub &#123;  constructor() &#123;    this.messages = &#123;&#125;;    this.listeners = &#123;&#125;;  &#125;  // 添加发布者  publish(type, content) &#123;    const existContent = this.messages[type];    if (!existContent) &#123;      this.messages[type] = [];    &#125;    this.messages[type].push(content);  &#125;  // 添加订阅者  subscribe(type, cb) &#123;    const existListener = this.listeners[type];    if (!existListener) &#123;      this.listeners[type] = [];    &#125;    this.listeners[type].push(cb);  &#125;  // 通知  notify(type) &#123;    const messages = this.messages[type];    const subscribers = this.listeners[type] || [];    subscribers.forEach((cb, index) =&gt; cb(messages[index]));  &#125;&#125;\n\n发布者代码如下：\nclass Publisher &#123;  constructor(name, context) &#123;    this.name = name;    this.context = context;  &#125;  publish(type, content) &#123;    this.context.publish(type, content);  &#125;&#125;\n\n订阅者代码如下：\nclass Subscriber &#123;  constructor(name, context) &#123;    this.name = name;    this.context = context;  &#125;  subscribe(type, cb) &#123;    this.context.subscribe(type, cb);  &#125;&#125;\n\n使用代码如下：\nconst TYPE_A = &#x27;music&#x27;;const TYPE_B = &#x27;movie&#x27;;const TYPE_C = &#x27;novel&#x27;;const pubsub = new PubSub();const publisherA = new Publisher(&#x27;publisherA&#x27;, pubsub);publisherA.publish(TYPE_A, &#x27;we are young&#x27;);publisherA.publish(TYPE_B, &#x27;the silicon valley&#x27;);const publisherB = new Publisher(&#x27;publisherB&#x27;, pubsub);publisherB.publish(TYPE_A, &#x27;stronger&#x27;);const publisherC = new Publisher(&#x27;publisherC&#x27;, pubsub);publisherC.publish(TYPE_C, &#x27;a brief history of time&#x27;);const subscriberA = new Subscriber(&#x27;subscriberA&#x27;, pubsub);subscriberA.subscribe(TYPE_A, res =&gt; &#123;  console.log(&#x27;subscriberA received&#x27;, res)&#125;);const subscriberB = new Subscriber(&#x27;subscriberB&#x27;, pubsub);subscriberB.subscribe(TYPE_C, res =&gt; &#123;  console.log(&#x27;subscriberB received&#x27;, res)&#125;);const subscriberC = new Subscriber(&#x27;subscriberC&#x27;, pubsub);subscriberC.subscribe(TYPE_B, res =&gt; &#123;  console.log(&#x27;subscriberC received&#x27;, res)&#125;);pubsub.notify(TYPE_A);pubsub.notify(TYPE_B);pubsub.notify(TYPE_C);\n\n区别\n在观察者模式中，观察者是知道被观察者的，被观察者一直保持对观察者发送记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在，它们只有通过消息代理进行通信。\n在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。\n观察者模式大多数时候是同步的，比如当事件触发，被观察者就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）\n\nvue中的应用\n观察者模式\n\nvue中数据响应式是观察者模式。\nVue2 的响应式是通过 Object.defineProperty 对数据进行劫持，并结合发布订阅者模式实现。 Vue 利用 Object.defineProperty 创建一个 observe 来劫持监听所有的属性，把这些属性全部转为 getter 和 setter。Vue 中每个组件实例都会对应一个 watcher 实例，它会在组件渲染的过程中把使用过的数据属性通过 getter 收集为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。\n\n发布订阅模式\n\nvue中的事件总线就是使用的发布订阅模式。\n","categories":["设计模式"],"tags":["vue","观察者模式","发布订阅模式"]},{"title":"type和interface区别","url":"/2022/10/31/type%E5%92%8Cinterface%E5%8C%BA%E5%88%AB/","content":"定义类型范围interface只能定义对象类型，而type声明可以声明任何类型，包括基础类型、联合类型、元组类型、交叉类型。\n// 基本类型 type person = string // 对象类型interface Dog &#123; name: string;&#125;interface Cat &#123; age: number;&#125;// 联合类型type animal = Dog | Cat // 元组类型type animal = [Dog, Cat]\n\n扩展性\n接口可以extends、implements扩展多个接口或类。\n\n// interface extends interfaceinterface Person &#123;  name: string&#125;interface User extends Person &#123;  age: number&#125; // interface extends typetype Person = &#123;  name: string&#125;interface User extends Person &#123;  age: number&#125;\n\n\ntype可以使用交叉类型&amp;，来使成员类型合并。\n\n// type &amp; typetype Person = &#123;   name: string&#125;type User = Person &amp; &#123; age: number &#125; // type &amp; interfaceinterface Person &#123;  name: string&#125;type User = &#123;age: number&#125; &amp; Person\n\n合并声明定义两个相同名称的接口会合并声明；而定义两个同名的type会出现异常。\ninterface Person &#123;   name: string&#125;interface Person &#123;  age: number&#125;// 合并为:// interface Person &#123; //   name: string //   age: number// &#125;\n\n映射类型type 能使用 in 关键字生成映射类型，但 interface 不行。\ntype Keys = &#x27;firstname&#x27; | &#x27;surname&#x27;;type DudeType = &#123;  [key in Keys]: string;&#125;;const test: DudeType = &#123;  firstname: &#x27;Pawel&#x27;,  surname: &#x27;Grzybek&#x27;,&#125;;\n\ntypeoftype可以使用typeof获取实例类型\nlet div = document.createElement(&#x27;div&#x27;);type B = typeof div\n\n默认导出方式inerface 支持同时声明 和 默认导出；而type必须先声明后导出\nexport default interface Config &#123;  name: string;&#125;\n\ntype Config2 = &#123;name: string&#125;export default Config2\n\n","categories":["TypeScript"],"tags":["type","interface"]},{"title":"ts内置类型","url":"/2022/11/01/ts%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/","content":""},{"title":"ts泛型","url":"/2022/11/01/ts%E6%B3%9B%E5%9E%8B/","content":""},{"title":"WebSocket","url":"/2022/11/01/WebSocket/","content":""},{"title":"首屏和白屏时间","url":"/2022/10/31/%E9%A6%96%E5%B1%8F%E5%92%8C%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4/","content":"","categories":["Web性能"]},{"title":"深浅拷贝","url":"/2022/11/01/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/","content":""}]