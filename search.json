[{"title":"Echarts的容器宽高使用rem，渲染出的图表很小的问题","url":"/2022/03/06/Echarts%E7%9A%84%E5%AE%B9%E5%99%A8%E5%AE%BD%E9%AB%98%E4%BD%BF%E7%94%A8rem%EF%BC%8C%E6%B8%B2%E6%9F%93%E5%87%BA%E7%9A%84%E5%9B%BE%E8%A1%A8%E5%BE%88%E5%B0%8F%E7%9A%84%E9%97%AE%E9%A2%98/","content":"主要是因为div还没有创建出来echarts就已经加载了，因为获取不到宽高，所以会缩小在一起。参考了几篇文章，我在echarts配置后加入如下代码，解决了问题：\nmyChart.setOption(option); //延迟resize setTimeout(function ()&#123;\t myChart.resize() &#125;,200)//随屏幕大小改变 window.addEventListener(&#x27;resize&#x27;,function()&#123;\t myChart.resize() &#125;)\nCSDN:https://blog.csdn.net/cjhsyc/article/details/122584331参考文章：https://www.cnblogs.com/xxxx0130/p/14182677.htmlhttps://blog.csdn.net/weixin_40180205/article/details/106116073\n","categories":["数据可视化","Echarts"],"tags":["Echarts"]},{"title":"js严格模式","url":"/2022/03/09/js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","content":"严格模式使用严格模式&quot;use strict&quot;\n\n变量a = 10console.log(a)//严格模式报错（必须使用var等声明变量）\n\n静默失败 &#x3D;&gt; 报错var b = 2console.log(Object.getOwnPropertyDescriptor(window, &#x27;b&#x27;))/*configurable: false //var声明的变量默认不可删除enumerable: truevalue: 2writable: true*/delete b//未删除，非严格模式下不报错，程序继续进行（静默失败）//严格模式下报错console.log(b)//2\n\n函数参数唯一function test(a,a)&#123;    console.log(a)//undefined(第二个a),严格模式报错&#125;test(10)\n\n实参和形参的映射关系不存在function test1(a) &#123;    a = 20    console.log(arguments[0])//非严格模式:20,严格模式:10&#125;test1(10)function test2(a = 20) &#123;//参数设置初始后自动开启严格模式    a = 30    console.log(arguments[0])//10&#125;test2(10)\n\n函数的this默认指向undefinedfunction test()&#123;    console.log(this)//undefined&#125;test()\n\n不能使用arguments.callee和callerfunction test()&#123;    console.log(arguments.callee === test)//true,严格模式无法使用    console.log(test.caller === out)//true,严格模式无法使用&#125;function out()&#123;    test()&#125;out()\n\n不能使用eval()和with()eval(&#x27;var a=2&#x27;)console.log(a)//2,严格模式无法使用const obj=&#123;    a:3&#125;function test()&#123;    with (obj) &#123;//改变this指向        console.log(a)//3,严格模式无法使用    &#125;&#125;test()\n\neval和arguments不能作为标识符let eval=&#x27;111&#x27;//严格模式报错\n\n\n\n\n\n\n\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"less预处理语言","url":"/2022/03/08/less%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%AD%E8%A8%80/","content":"变量声明和使用//定义变量@color: red;@var: a;@attr: color;@&#123;var&#125; &#123; //作为选择器或者属性名需要添加大括号    @&#123;attr&#125;: @color; //作为属性值直接使用&#125;@btn: &#123;    width: 100px;    height: 40px;    background-color: aqua;&#125;.btn &#123;    @btn(); //需要括号&#125;    @url: &#x27;https://cdn.jsdelivr.net/gh/cjhsyc/image-hosting@master/头像.677yiujw5980.webp&#x27;;.img&#123;    background-image: url(&quot;@&#123;url&#125;&quot;); //作为url使用    background-size: 100px;    width: 100px;    height: 100px;&#125;\n\n运算可以使用+、-、*、&#x2F;进行运算\n@a: 100px + 20px; //120px@b: @a*2; //240px@c: #666/2; //#333\n\n嵌套.parent&#123;    width: 100px;    height: 100px;    border: 1px solid gray;    .child&#123;        background-color: skyblue;        @media (min-width: 900px)&#123;            background-color: pink;        &#125;        @media (min-width: 500px) and (max-width: 900px)&#123;            background-color: greenyellow;        &#125;    &#125;&#125;\n\n相当于\n.parent &#123;  width: 100px;  height: 100px;  border: 1px solid gray;&#125;.parent .child &#123;  background-color: skyblue;&#125;@media (min-width: 900px) &#123;    .parent .child &#123;        background-color: pink;    &#125;&#125;@media (min-width: 500px) and (max-width: 900px) &#123;    .parent .child &#123;        background-color: greenyellow;    &#125;&#125;\n\n混合.mixins &#123;    border: 2px solid skyblue;    width: 300px;    height: 30px;&#125;.box &#123;    .mixins(); //括号可加可不加&#125;\n\n函数使用函数自定义一个绘制三角形的函数\n.triangle(top,@color:black,@height:50px) &#123;    border-color: transparent transparent @color transparent;&#125;.triangle(left,@color:black,@height:50px) &#123;    border-color: transparent @color transparent transparent;&#125;.triangle(bottom,@color:black,@height:50px) &#123;    border-color: @color transparent transparent transparent;&#125;.triangle(right,@color:black,@height:50px) &#123;    border-color: transparent transparent transparent @color;&#125;.triangle(@dir,@color:black,@height:50px) &#123;//@dir用来匹配第一个参数，后面的参数都要一致    width: 0;    height: 0;    border-width: @height;    border-style: solid;&#125;.triangleBox &#123;    .triangle(top,red);//绘制尖朝上的三角形,后两个参数不写则使用默认值&#125;\n\n命名空间和逻辑判断#card&#123;    //when:进行逻辑判断    //not:取反,and:且,或运算使用逗号    .border(@width,@color,@style) when not(@width &gt; 30px) , (@color &gt;= #666) and (@style = solid)&#123;        border: @width @style @color;    &#125;&#125;#main &#123;    //调用其他作用域的函数（ &#x27;&gt;&#x27; 可以省略 ）    #card &gt; .border(40px, #666, solid); //符合条件才生效    //#card.border(40px, #666, solid);//效果同上&#125;\n\n不定参数.boxShadow(@a,@b,...)&#123;//不定参数    box-shadow: @arguments;//@arguments:所有的参数,包括@a,@b    width: 200px;&#125;#box1&#123;    .boxShadow(0,0,10px,gray);&#125;#box2&#123;    .boxShadow(inset,0,0,5px,gray);&#125;\n\n循环//循环（递归调用函数）.columns(@n,@i:1) when (@i &lt;= @n) &#123;    .column-@&#123;i&#125; &#123;        width: @i*100% / @n;        height: 20px;        background-color: pink;    &#125;    .columns(@n, @i+1)&#125;.columns(4);\n\n属性合并.bg&#123;    width: 200px;    height: 200px;    //+ :属性用逗号隔开    //+_ :属性用空格隔开    background+: #666666;    background+_: url(&quot;@&#123;url&#125;&quot;);    background+_: no-repeat;    background+_: center;    box-shadow+: 0 0 5px greenyellow;    box-shadow+: 0 0 10px #000;    background-size: 100px;&#125;\n\n相当于\n.bg &#123;  width: 200px;  height: 200px;  background: #666666 url(&quot;@&#123;url&#125;&quot;) no-repeat center;  box-shadow: 0 0 5px greenyellow,0 0 10px #000;  background-size: 100px;&#125;\n\n继承.linkBtn &#123;    display: block;    width: 200px;    height: 80px;&#125;.linkBtn &#123;    color: white;    background-color: skyblue;&#125;.link:extend(.linkBtn) &#123;    text-decoration: none;    border: 4px solid orange;&#125;\n\n使用混合也可以实现相同的效果，但混合是相当于把代码再复制一份，而继承不是，上述代码转CSS如下：\n.linkBtn,.link &#123;  display: block;  width: 200px;  height: 80px;&#125;.linkBtn,.link &#123;  color: white;  background-color: skyblue;&#125;.link &#123;  text-decoration: none;  border: 4px solid orange;&#125;\n\n导入导入其他less文件\n@import &quot;./assets/style.less&quot;@import (reference) &quot;./assets/style.less&quot;//添加reference后，未被调用的代码不加载\n\n\n\n参考视频\n","categories":["样式","less"],"tags":["less"]},{"title":"webpack配置","url":"/2022/03/07/webpack%E9%85%8D%E7%BD%AE/","content":"webpack.config.js入口和出口文件const path = require(&#x27;path&#x27;)//引入path模块module.exports = &#123;    entry: &#x27;./src/index.js&#x27;,//打包的入口文件    output: &#123;//出口        filename: &quot;bundle.js&quot;,//出口文件名        path: path.resolve(__dirname, &quot;./dist&quot;),//出口文件路径需要绝对路径        clean: true,//打包前清理dist文件夹    &#125;&#125;\n\n生成HTML文件安装html-webpack-plugin插件\nnpm i html-webpack-plugin -D\n\n该模块用于自动生成HTML文件。在webpack.config.js中引入：\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); //通过 npm 安装\n\n通过plugins配置插件：\nplugins: [    new HtmlWebpackPlugin(&#123;//可不传配置项（默认配置）        template: &quot;./index.html&quot;,//以index.html为模板生成html文件        filename: &quot;app.html&quot;,        inject: &#x27;body&#x27;,//指定script标签写在body标签中（默认为head）    &#125;)]\n\n代码有修改后自动打包：\nwebpack --watch\n\n开发环境安装webpack-dev-server插件\nnpm i webpack-dev-server -D\n\n//开发模式mode: &quot;development&quot;,devtool: &#x27;inline-source-map&#x27;,//精确显示代码位置（比如报错时）devServer: &#123;//开发服务器    static:&#x27;./dist&#x27;&#125;,\n\n命令行执行：\nwebpack-dev-server\n\n无需打包，通过浏览器访问8080端口实时查看页面效果\n资源模块Resource资源加载资源导出url\nmodule:&#123;    rules: [        &#123;            test:/\\.png$/,//匹配.png文件            type: &quot;asset/resource&quot;,//加载资源导出url            generator: &#123;//指定打包的路径（可省略）                filename: &#x27;images/[contenthash][ext]&#x27;//[contenthash]:哈希值作为文件名，[ext]:扩展名            &#125;        &#125;    ]&#125;\n\n示例：在index.js中导入png图片\nimport imgsrc from &#x27;../asset/微信.png&#x27;//图片url(http://localhost:8080/images/a2769eaec65049f8919b.png)const img = document.createElement(&#x27;img&#x27;)img.src = imgsrcdocument.body.appendChild(img)\n\n也可再output中使用assetModuleFilename指定打包路径，优先级低于rules中的配置\noutput: &#123;//出口    filename: &quot;bundle.js&quot;,//出口文件名    path: path.resolve(__dirname, &quot;./dist&quot;),//出口文件路径需要绝对路径    clean: true,//打包前清理dist文件夹    assetModuleFilename: &quot;images/[contenthash][ext]&quot;,//[contenthash]:哈希值作为文件名，[ext]:扩展名&#125;,\n\ninline资源导出为Data URL base64格式\n&#123;    test: /\\.svg$/,    type: &quot;asset/inline&quot;,//导出为Data URL base64格式&#125;,\n\n示例：导入svg图片\nimport logoSvg from &#x27;./asset/logo.svg&#x27;//(data:image/svg+xml;base64,PHN2ZyB4bWxucz......)const img2 = document.createElement(&#x27;img&#x27;)img2.src = logoSvgimg2.style.cssText=&#x27;width:400px;height:600px&#x27;document.body.appendChild(img2)\n\nsource资源导出文件源码\n&#123;    test: /\\.txt$/,    type: &quot;asset/source&quot;,//导出文件源码&#125;\n\n示例：导入源码\nimport helloTxt from &#x27;./asset/hello.txt&#x27;//txt的文本内容const block = document.createElement(&#x27;div&#x27;)block.style.cssText = &#x27;width:200px;height:200px;border:1px solid gray&#x27;block.textContent = helloTxtdocument.body.appendChild(block)\n\n通用资源类型自动选择资源类型，小于maxSize用inline类型，大于则用resource类型\n&#123;    test: /\\.jpg$/,    type: &quot;asset&quot;,//自动选择资源类型，小于maxSize用inline类型，大于则用resource类型    parser: &#123;//自定义条件（可省略）        dataUrlCondition:&#123;            maxSize: 4 * 1024//默认为4 * 1024        &#125;    &#125;&#125;\n\n示例：导入jpg图片\nimport jpgMap from &#x27;./asset/头像.jpg&#x27;//因为大于4k所以是url格式const block = document.createElement(&#x27;div&#x27;)block.style.cssText = &#x27;width:200px;height:200px;border:1px solid gray&#x27;block.textContent = helloTxtdocument.body.appendChild(block)\n\nloader加载CSS安装loader\nnpm i css-loader -Dnpm i style-loader -D\n\n在module &gt; rules中配置\n&#123;    test: /\\.css$/,    //css-loader写在style-loader后面，先加载    //如果需要CSS预处理语言，安装相应的loader，写在css-loader后面    use: [&#x27;style-loader&#x27;,&#x27;css-loader&#x27;],//css-loader允许打包css文件，style-loader将样式加到html页面上&#125;\n\n抽离和压缩CSS安装插件\nnpm i mini-css-extract-plugin -Dnpm i css-minimizer-webpack-plugin -D\n\n引入插件\nconst MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)const CssMinimizerPlugin = require(&#x27;css-minimizer-webpack-plugin&#x27;)\n\n在plugin中使用MiniCssExtractPlugin（用于以link标签的形式在html中导入css文件）\nnew MiniCssExtractPlugin(&#123;\tfilename:&#x27;styles/[contenthash].css&#x27;//自定义打包路径&#125;)\n\n&#123;    test: /\\.css$/,    //&#x27;style-loader&#x27;换为MiniCssExtractPlugin    use: [MiniCssExtractPlugin.loader,&#x27;css-loader&#x27;],//css-loader允许打包css文件，style-loader将样式加到html页面上&#125;\n\n新配置项optimization中使用CssMinimizerPlugin（用于压缩css文件）\noptimization: &#123;    minimizer: [        new CssMinimizerPlugin()    ]&#125;,mode:&#x27;production&#x27;//生产环境下才会压缩（会有其他报错）\n\nbabel-loader如果浏览器不支持ES6语法，使用babel-loader，将ES6转为ES5\n安装babel-loader，@babel&#x2F;core，@babel&#x2F;preset-env\nnpm i babel-loader @babel/core @babel/preset-env -Dnpm i @babel/runtime -Dnpm i @babel/plugin-transform-runtime -D\n\nmodule &gt; rules中配置\n&#123;    test:/\\.js$/,    exclude: /node_modules/,//排除node_modules中的js文件    use:&#123;        loader:&#x27;babel-loader&#x27;,        options: &#123;            presets:[&#x27;@babel/preset-env&#x27;],            plugins: [                [                    &#x27;@babel/plugin-transform-runtime&#x27;                ]            ]        &#125;    &#125;&#125;\n\n代码分离多入口entry中设置多入口文件，修改output中的filename\nentry: &#123;    //两个文件都引入了lodash模块    index: &#x27;./src/index.js&#x27;,    another: &#x27;./src/another.js&#x27;&#125;,//打包的入口文件output: &#123;//出口    filename: &quot;[name].bundle.js&quot;,//出口文件名（[name]:入口文件的键值）    path: path.resolve(__dirname, &quot;./dist&quot;),//出口文件路径需要绝对路径    clean: true,//打包前清理dist文件夹    assetModuleFilename: &quot;images/[contenthash][ext]&quot;,//[contenthash]:哈希值作为文件名，[ext]:扩展名&#125;,\n\n防止重复optimization: &#123;    splitChunks: &#123;        chunks: &quot;all&quot;//自动抽离公共代码模块    &#125;&#125;\n","categories":["工程化"],"tags":["webpack"]},{"title":"实用网站","url":"/2022/03/22/%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99/","content":"JavaScriptES6ECMAScript 6 入门-阮一峰\n面试题前端面试web前端面试 - 面试官系列\n大厂面试题每日一题\nTypeScriptTypeScript入门教程\n","categories":["网站"],"tags":["JavaScript","面试题","ES6"]},{"title":"数据可视化","url":"/2022/03/20/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/","content":"canvascanvas基本使用canvas标签\n &lt;!--canvas：画布，html5新增--&gt;&lt;!--有默认宽高：300 * 150--&gt;&lt;!--浏览器默认canvas标签是一张图片--&gt;&lt;!--给canvas添加文本和子节点无效--&gt;&lt;!--需要通过js操作画布显示内容--&gt;&lt;!--不要通过样式设置canvas的宽高，而通过标签的属性来设置--&gt;&lt;canvas width=&quot;500px&quot; height=&quot;300px&quot;&gt;&lt;/canvas&gt;\n\n通过js操作canvas\nlet canvas = document.querySelector(&#x27;canvas&#x27;)// 获取画布上下文let ctx = canvas.getContext(&#x27;2d&#x27;)// 绘制线段(起点)ctx.moveTo(100, 200)ctx.lineTo(200, 250)//终点（第二个点）ctx.lineTo(150, 300)//第三点ctx.closePath()//连接起点和第三个点ctx.fillStyle = &#x27;red&#x27;//设置填充的颜色ctx.fill()//填充ctx.strokeStyle = &#x27;blue&#x27;//设置线段颜色ctx.lineWidth = &#x27;5&#x27;//设置线段宽度ctx.stroke()//画出线/三角形边框\n\n绘制矩形const canvas = document.querySelector(&#x27;canvas&#x27;)const ctx = canvas.getContext(&#x27;2d&#x27;)//绘制矩形：参数为 左上点坐标和宽高ctx.strokeRect(100,200,300,100)//填充矩形：默认黑色ctx.fillRect(100,400,300,100)\n\n绘制圆形const canvas = document.querySelector(&#x27;canvas&#x27;)const ctx = canvas.getContext(&#x27;2d&#x27;)//开始绘制圆形ctx.beginPath()//画圆:arc(x,y,r,sAngle,eAngle,counterclockwise);//x,y:圆心，r：半径，sAngle：起始弧度，eAngle：结束弧度，(0到2PI绘制一个完整的圆)//counterclockwise：可选。规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针。ctx.arc(300, 200, 100, 0, 2 * Math.PI)//设置填充颜色ctx.fillStyle = &#x27;red&#x27;ctx.fill()//完成绘制ctx.stroke()\n\n清除画布与绘制文字const canvas = document.querySelector(&#x27;canvas&#x27;)const ctx = canvas.getContext(&#x27;2d&#x27;)ctx.fillRect(200,100,300,200)//清除画布(一个矩形范围内)ctx.clearRect(0,0,700,500)//设置字体ctx.font=&#x27;20px 微软雅黑&#x27;ctx.fillStyle=&#x27;red&#x27;//文字颜色//绘制文字(参数：文本内容和起始位置)ctx.fillText(&#x27;数据可视化&#x27;,50,20)\n\nsvg基本使用&lt;!--默认宽高：300*150,可通过样式设置宽高--&gt;&lt;!--在svg内部使用相应的标签绘图--&gt;&lt;svg class=&quot;box&quot;&gt;  &lt;!--画线:属性包括两点的坐标，stroke：线的颜色（必选），stroke-width：线的宽度--&gt;  &lt;line x1=&quot;100&quot; y1=&quot;100&quot; x2=&quot;200&quot; y2=&quot;300&quot; stroke=&quot;red&quot; stroke-width=&quot;5&quot;&gt;&lt;/line&gt;  &lt;!--折线：points：各个点的坐标--&gt;  &lt;!--会自动填充颜色（黑色），fill-opacity：填充颜色透明度--&gt;  &lt;polyline points=&quot;300 300,50 100,120 400&quot; stroke=&quot;green&quot; fill-opacity=&quot;0&quot;&gt;&lt;/polyline&gt;  &lt;!--矩形：默认填充黑色,fill:设置填充颜色--&gt;  &lt;rect x=&quot;400&quot; y=&quot;200&quot; width=&quot;150&quot; height=&quot;50&quot; fill=&quot;pink&quot;&gt;&lt;/rect&gt;  &lt;!--圆形：自动填充黑色，style：设置样式，r：半径，cx、cy：圆心坐标--&gt;  &lt;circle r=&quot;50&quot; cx=&quot;100&quot; cy=&quot;100&quot; style=&quot;stroke: skyblue;fill: none&quot;&gt;&lt;/circle&gt;  &lt;!--椭圆：rx：水平半径，ry：垂直半径--&gt;  &lt;ellipse rx=&quot;100&quot; ry=&quot;50&quot; cx=&quot;400&quot; cy=&quot;400&quot; style=&quot;stroke: skyblue;fill: none&quot;&gt;&lt;/ellipse&gt;  &lt;!--多边形--&gt;  &lt;polygon points=&quot;300 100,400 200,350 300&quot; stroke=&quot;blue&quot; fill=&quot;none&quot;&gt;&lt;/polygon&gt;  &lt;!--任意图形--&gt;  &lt;!--d:M:起点，L：线终点，Z：连接起点--&gt;  &lt;path d=&quot;M 10 10 L 120 70 L 30 140 L 60 340 L 432 110 Z&quot; fill=&quot;none&quot; stroke=&quot;red&quot;&gt;&lt;/path&gt;&lt;/svg&gt;\n\nEChartsECharts官网\n引入ECharts&lt;!--引入ECharts--&gt;&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/echarts/5.3.1/echarts.min.js&quot;&gt;&lt;/script&gt;\n\nimport引入：\nimport * as echarts from &#x27;echarts&#x27;\n\n基本使用&lt;!--准备一个容器--&gt;&lt;div style=&quot;width: 800px;height: 500px&quot; id=&quot;main&quot;&gt;&lt;/div&gt;\n\n初始化echarts实例：\nconst myCharts = echarts.init(document.getElementById(&#x27;main&#x27;));\n\n绘制柱状图\nmyCharts.setOption(&#123;  //标题  title:&#123;    text:&#x27;数据可视化&#x27;,//主标题    subtext:&#x27;echarts基本使用&#x27;,//副标题    textAlign:&#x27;center&#x27;,//居中对齐    left:&#x27;center&#x27;,//title 组件离容器左侧的距离。  &#125;,  //x轴配置  xAxis:&#123;    //数据    data:[&#x27;衣服&#x27;,&#x27;食品&#x27;,&#x27;游戏&#x27;,&#x27;电影&#x27;],  &#125;,  //y轴配置  yAxis: &#123;    axisLine:&#123;//线      show:true    &#125;,    axisTick:&#123;//刻度      show:true    &#125;  &#125;,  //系列的设置：图表的类型和数据  series:[    &#123;      //图标类型      type:&#x27;bar&#x27;,//bar：柱状图，line：折线图      data:[10,30,40,20],//数据      color:&#x27;pink&#x27;,//颜色    &#125;  ]&#125;)\n\n一个容器显示多个图表在series中配置多个图表\nseries: [      &#123;        //图标类型        type: &#x27;bar&#x27;,//bar：柱状图，line：折线图        data: [10, 30, 40, 20],//数据        color: &#x27;pink&#x27;,//颜色      &#125;,      &#123;        type: &#x27;line&#x27;,        data: [10, 30, 40, 20],//数据        color: &#x27;gray&#x27;      &#125;,      &#123;        type: &#x27;pie&#x27;,//pie:饼图        data: [&#123;name: &#x27;衣服&#x27;, value: 10&#125;, &#123;name: &#x27;食品&#x27;, value: 30&#125;, &#123;name: &#x27;游戏&#x27;, value: 40&#125;, &#123;name: &#x27;电影&#x27;, value: 20&#125;],        width: 300,//包括文字内容的大小范围        height: 150,        left: 500,//距离左侧的距离        radius: 50,//半径      &#125;    ]\n\ndataset数据集准备数据集（二维数组）\n//数据集const data = [  [&#x27;衣服&#x27;, 10, 20, &#x27;饮料&#x27;, 22],  [&#x27;食品&#x27;, 30, 10, &#x27;电器&#x27;, 44],  [&#x27;游戏&#x27;, 40, 40, &#x27;小说&#x27;, 11],  [&#x27;电影&#x27;, 20, 30, &#x27;音乐&#x27;, 33],]\n\n在echarts的配置对象中设置字符集\n//设置字符集dataset:&#123;  //数据源  source:data,&#125;,\n\nseries中的data换成encode，指定使用的数据的索引值\nseries: [  &#123;    //图标类型    type: &#x27;bar&#x27;,//bar：柱状图，line：折线图    // data: [10, 30, 40, 20],//数据    color: &#x27;pink&#x27;,//颜色    encode: &#123;      x: 0,      y: 1,    &#125;  &#125;,  &#123;    type: &#x27;line&#x27;,    // data: [10, 30, 40, 20],//数据    color: &#x27;gray&#x27;,    encode: &#123;      x: 0,      y: 2,    &#125;  &#125;,  &#123;    type: &#x27;pie&#x27;,//pie:饼图    // data: [&#123;name: &#x27;衣服&#x27;, value: 10&#125;, &#123;name: &#x27;食品&#x27;, value: 30&#125;, &#123;name: &#x27;游戏&#x27;, value: 40&#125;, &#123;name: &#x27;电影&#x27;, value: 20&#125;],    width: 300,//包括文字内容的大小范围    height: 150,    left: 500,//距离左侧的距离    radius: 50,//半径    encode: &#123;      //饼图旁边的文字      itemName: 3,      value: 4,    &#125;  &#125;]\n\n组件提示组件//提示组件(鼠标悬浮时显示)tooltip:&#123;  textStyle:&#123;    //文字颜色    color:&#x27;red&#x27;  &#125;&#125;\n\n系列切换组件给图表添加name属性\nseries: [  &#123;    name:&#x27;柱状图&#x27;,    type: &#x27;bar&#x27;,    encode: &#123;      x: 0,      y: 1,    &#125;  &#125;,  &#123;    name:&#x27;折线图&#x27;,    type: &#x27;line&#x27;,    encode: &#123;      x: 0,      y: 2,    &#125;  &#125;,],//系列切换组件legend:&#123;  data:[&#x27;柱状图&#x27;,&#x27;折线图&#x27;],  right: &#x27;20%&#x27;&#125;\n\n工具栏组件// 工具栏组件toolbox: &#123;  show: true,  feature: &#123;    dataZoom: &#123;      yAxisIndex: &quot;none&quot;    &#125;,    dataView: &#123;      readOnly: false    &#125;,    magicType: &#123;      type: [&quot;line&quot;, &quot;bar&quot;]    &#125;,    restore: &#123;&#125;,    saveAsImage: &#123;&#125;  &#125;&#125;,\n\n双坐标两个x轴\nmyCharts.setOption(&#123;  title: &#123;    text: &#x27;echarts坐标系&#x27;,    left: &#x27;center&#x27;,    textAlign: &#x27;center&#x27;,  &#125;,  //多个坐标系，使用数组  xAxis: [    &#123;      data: [&#x27;衣服&#x27;, &#x27;食品&#x27;, &#x27;游戏&#x27;, &#x27;电影&#x27;],    &#125;,    &#123;&#125;,  ],  yAxis: &#123;&#125;,  series: [    &#123;      type: &#x27;scatter&#x27;,//散点图      data: [        [11, 87],        [34, 45],        [64, 23],        [43, 54],        [12, 40],      ],      xAxisIndex: 1,//使用第二个x轴    &#125;,    &#123;      type: &#x27;bar&#x27;,      data: [10, 30, 40, 20],      xAxisIndex: 0,//使用第一个x轴    &#125;  ]&#125;)\n","categories":["数据可视化"],"tags":["Echarts","canvas","svg"]},{"title":"防抖节流","url":"/2022/03/09/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/","content":"防抖function debounce(fn, duration = 500) &#123;//自定义防抖函数,默认0.5秒内没有再次触发该函数时执行    let timer    return function (...args) &#123;        timer &amp;&amp; clearTimeout(timer)        timer = setTimeout(() =&gt; &#123;            typeof fn === &#x27;function&#x27; &amp;&amp; fn.apply(this, args)        &#125;, duration)    &#125;&#125;const input = document.getElementById(&#x27;input&#x27;)input.addEventListener(&#x27;input&#x27;, debounce(event =&gt; &#123;    console.log(event.target.value)&#125;));\n\n节流function throttle(fn, duration = 1000) &#123; //自定义节流函数，1秒内只触发一次    let time = 0    return function (...args) &#123;        if (new Date() - time &gt; duration) &#123;            typeof fn === &#x27;function&#x27; &amp;&amp; fn.apply(this, args)            time = new Date()        &#125;    &#125;&#125;const btn = document.getElementById(&#x27;btn&#x27;)btn.addEventListener(&#x27;click&#x27;, throttle(event =&gt; &#123;    console.log(event.target.innerText)&#125;));\n\n","categories":["JavaScript","手写"],"tags":["JavaScript"]},{"title":"HTTP缓存","url":"/2022/03/27/HTTP%E7%BC%93%E5%AD%98/","content":"强制缓存对于强制缓存而言，如果浏览器判断所请求的目标资源有效命中，则可直接从强制缓存中返回请求响应，无需与服务器进行任何通信。\nExpires服务器返回资源时在响应头中设置Expires字段，指定过期时间。在过期时间之前，浏览器再次访问该资源，则直接从强制缓存中获取。\nExpires:New Date(&#x27;2022-03-27 15:08:38&#x27;).toUTCString()\n\n缺点这个方式存在一个很大的漏洞，即对本地时间戳过分依赖，如果客户端本地的时间与服务器端的时间不同步，或者对客户端时间进行主动修改，那么对于缓存过期的判断可能就无法和预期相符。\ncache-controlmax-agecache-control设置max-age&#x3D;60属性值来控制响应资源的有效期，它是一个以秒为单位的时间长度，表示该资源在被请求到后的60秒内有效，如此便可避免服务器端和客户端时间戳不同步而造成的问题。\ncache-control:max-age=60//滑动时间，单位为秒\n\ncache-control还可以配置一些其他属性值，下面介绍。\nno-store和no-cacheno-store和no-cache是一组互斥属性\nno-store：表示禁止使用缓存\nno-cache：表示强制进行协商缓存\npublic和privatepublic和private是一组互斥属性\npublic：表示响应资源既可以被浏览器缓存，又可以被代理服务器缓存。\nprivate：响应资源只能被浏览器缓存，若未显式指定则默认值为private。\n对于应用程序中不会改变的文件，你通常可以在发送响应头前添加积极缓存（public）。这包括例如由应用程序提供的静态文件，例如图像，CSS 文件和JavaScript文件。\ns-maxages-maxage：表示代理服务器缓存的过期时间。\n协商缓存协商缓存就是在使用本地缓存之前，需要向服务器端发起一次GET请求，与之协商当前浏览器保存的本地缓存是否已经过期。\nlast-modified&#x2F;if-modified-since响应头中设置：\ncache-control:no-cache//进行协商缓存last-modified:xxx//资源最后一次修改的时间\n\n浏览器再次访问时请求头中会加上if-modified-since字段：\nif-modified-since:xxx//值为上次请求时响应头的last-modified的值\n\n服务器判断if-modified-since和此次的last-modified是否一致。如果一致则只需返回状态码304，表示从缓存中获取数据计可。如果不一致，就需要返回新的数据和last-modified。\n缺陷首先，它只是根据资源最后的修改时间戳进行判断的，虽然请求的文件资源进行了编辑，但内容并没有发生任何变化，时间戳也会更新，从而导致协商缓存时关于有效性的判断验证为失效，需要重新进行完整的资源请求。这无疑会造成网络带宽资源的浪费，以及延长用户获取到目标资源的时间。\n其次，标识文件资源修改的时间戳单位是秒，如果文件修改的速度非常快，假设在几百毫秒内完成，那么上述通过时间戳的方式来验证缓存的有效性，是无法识别出该次文件资源的更新的。\netag和if-none-match其内容主要是服务器为不同资源进行哈希运算所生成的一个字符串，只要文件内容编码存在差异，对应的 etag标签值就会不同，因此可以使用etag对文件资源进行更精准的变化感知。\n响应头中设置：\netag:xxx//根据资源进行哈希运算所生成的一个字符串\n\n浏览器再次访问时请求头中会加上if-none-match字段：\nif-none-match:xxx//值为上次请求时响应头的etag的值\n\n服务器判断if-none-match和此次的etag是否一致。如果一致则只需返回状态码304，表示从缓存中获取数据计可。如果不一致，就需要返回新的数据和etag。\n缺陷一方面，服务器对于生成文件资源的etag需要付出额外的计算开销，如果资源的尺寸较大，数量较多且修改比较频繁，那么生成etag的过程就会影响服务器的性能。\n另一方面，etag字段值的生成分为强验证和弱验证，强验证根据资源内容进行生成，能够保证每个字节都相同;弱验证则根据资源的部分属性值来生成，生成速度快但无法确保每个字节都相同，并且在服务器集群场景下，也会因为不够准确而降低协商缓存有效性验证的成功率，所以恰当的方式是根据具体的资源使用场景选择恰当的缓存校验方式。\n参考视频\n","categories":["HTTP","HTTP缓存"],"tags":["HTTP"]},{"title":"Vue解决SEO","url":"/2022/03/27/Vue%E8%A7%A3%E5%86%B3SEO/","content":"SEO：搜索引擎优化seo需要的几个关键点：\n\n多页面\ntitle、描述、关键词\n网站的内容\n\nvue-cli无法实现以上三点：\n\nvue项目是SPA：单页面应用\nvue项目只有一套title、描述、关键词\nvue项目的内容是通过引入js文件加载的，无法通过源代码的HTML文件中直接读取\n\n预渲染在html页面生成之前数据就已经加载完成。预渲染的流程：\n\n读取配置，获取需要预渲染的页面\n\n发布机模拟浏览器环境打开页面\n\n页面脚本触发渲染时机\n\n渲染出当前的页面内容\n\n获取当前所有的DOM结构\n\n生成HTML文件\n\n\nprerender-spa-plugin提供一个预渲染解决方案。\n安装插件prerender-spa-plugin：\nnpm i prerender-spa-plugin\n\n在vue.config.js中进行配置：\nconst path = require(&#x27;path&#x27;)const PrerenderSPAPlugin = require(&#x27;prerender-spa-plugin&#x27;) module.exports = &#123;\tpublicPath:&#x27;./&#x27;,\tconfigureWebpack:&#123;    \tplugins: [\t        new PrerenderSPAPlugin(&#123;          \t\tstaticDir: path.join(__dirname, &#x27;dist&#x27;),          \t\t//将指定的路由分别预渲染为HTML页面(打包后生成多个HTML页面)         \t\troutes: [ &#x27;/&#x27;, &#x27;/about&#x27;, &#x27;/some/deep/nested/route&#x27; ],        \t&#125;)      \t]\t&#125; &#125;\n\nvue-meta-info修改title、描述、关键词。\nnpm i vue-meta-info\n\n在路由对应 的Vue文件中设置对应的meta-info：\n&lt;template&gt;    ...&lt;/template&gt; &lt;script&gt;  export default &#123;    metaInfo: &#123;      title: &#x27;My Example App&#x27;, // 设置title      meta: [&#123;                         name: &#x27;keyWords&#x27;,//关键字        content: &#x27;My Example App&#x27;//描述      &#125;]      /*link: [&#123;//设置link        rel: &#x27;asstes&#x27;,        href: &#x27;https://assets-cdn.github.com/&#x27;      &#125;]*/    &#125;  &#125;&lt;/script&gt; \n\n存在的问题prerender-spa-plugin无法配置动态路由，适合一个项目只需要其中几个页面需要做seo。\nvue-meta-info无法给title、描述和关键字设置动态数据。\n服务器渲染（SSR）在客户端和后端之间再添加一个服务器端（比如node.js）,后端将返回的数据交给服务器端，服务器端将html返回给客户端。\nNUXTNUXT中文官网\n一个基于 Vue.js 的服务端渲染应用框架\n安装:\nnpx create-nuxt-app &lt;项目名&gt;\n\n安装时需要进行一些选择\n目录结构pages：文件夹中放置路由组件。在该文件夹下的组件会在.nuxt文件夹下的router.js中自动配置路由。\ncomponents：文件夹中放置全局组件，使用其中的组件时无需import，可直接使用。因为配置文件nuxt.config.js配置文件中的components: true（改为false后需要手动引入组件）\nstore：store 目录用于组织应用的 Vuex 状态树 文件。 Nuxt.js 框架集成了 Vuex 状态树 的相关功能配置，在 store 目录下创建一个 index.js 文件可激活这些配置。\nNUXT生命周期服务端生命周期nuxtServerInit在store 目录下新建index.js。在vuex的actions模块中使用nuxtServerInit\nexport const state = () =&gt; &#123;&#125;export const mutations = &#123;&#125;export const actions = &#123;  //参数1：vuex上下文  //参数2：nuxt上下文  //只能在index.js中使用，其他的js文件会被当成子模块，子模块中使用nuxtServerInit无效  nuxtServerInit(store, context) &#123;    console.log(&#x27;nuxtServerInit&#x27;)  &#125;&#125;\n\nmiddleware（中间件）根目录下新建middleware目录，添加js文件（name.js）:\nexport default (&#123;store,route,req,res,redirect,query,params&#125;) =&gt; &#123;//可接收很多参数  console.log(&#x27;middleware&#x27;)    if(route.name=&#x27;home&#x27;)&#123;//前往home路由        redirect(&#x27;/login&#x27;)//重定向到login路由    &#125;&#125;\n\n全局middleware：nuxt.config.js中添加：\nrouter:&#123;  middleware:&#x27;name&#x27;,//对应middleware目录下的js文件名&#125;\n\n局部（组件内）middleware：\n&lt;template&gt;  &lt;Tutorial/&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;IndexPage&#x27;,  // middleware:&#x27;name&#x27;,  middleware()&#123;//不需要在middleware目录下写js文件    console.log(&#x27;局部middleware&#x27;)  &#125;&#125;&lt;/script&gt;\n\nvalidate用于校验路由参数\n在组件中使用：\n&lt;template&gt;  &lt;Tutorial/&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;IndexPage&#x27;,  validate(&#123;params,query&#125;)&#123;//接收路由的参数    console.log(&#x27;validate&#x27;)    return /^\\d+$/.test(query.id)//返回值为true时才能正常访问  &#125;&#125;&lt;/script&gt;\n\nasyncData只能在页面组件中使用，在组件每次加载之前调用，一般用来发送请求、获取数据。\nfetch可以在所有组件中使用\n服务端和客户端共有的生命周期beforeCreate&#x2F;created在NUXT服务器和客户端都执行\n客户端生命周期和vue中一致：\n\nbeforeMount&#x2F;mounted\n\nbeforeUpdate&#x2F;updated\n\nbeforeDestroy&#x2F;destroyed\n\n\nNUXT路由nuxt-link&lt;nuxt-link&gt; 的作用和&lt;router-link&gt;一致。为了提高 Nuxt.js 应用程序的响应能力，当链接将显示在视口中时，Nuxt.js 将自动预获取代码分割页面。\nnuxt中不使用路由懒加载。\n子路由在pages目录下新一个和父路由同名的文件夹，该文件夹下的.vue文件为子路由\n&lt;nuxt-child&gt;相当于&lt;router-view&gt;\n动态路由.vue文件以下划线（’_’）开头的为动态路由\n手动配置router.js使用@nuxtjs&#x2F;router\nnpm i @nuxtjs/router\n\nnuxt.config.js中配置：\nmodules:[\t&#x27;@nuxtjs/router&#x27;]\n\n在根目录下创建router.js文件，手动配置路由，与vue中不同的是向外暴露的不是router实例而是一个函数\nimport Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;Vue.use(Router)import MyPage from &#x27;~/components/my-page&#x27;const routes = [&#123;        path: &#x27;/&#x27;,        component: MyPage      &#125;]export function createRouter() &#123;  return new Router(&#123;    mode: &#x27;history&#x27;,    routes  &#125;)&#125;\n\n路由导航守卫在router.js中使用和vue-cli中一样 (全局守卫，路由独享守卫)\nnuxtjs自动生成路由时使用：\n\n中间件：middleware\n\n配置插件\n根目录新建plugins/router.js\nexport default (&#123;app&#125;) =&gt; &#123;  app.router.beforeEach((to,from,next)=&gt;&#123;    console.log(&#x27;beforeEach&#x27;)    next()  &#125;)&#125;\n\nnuxt.config.js中设置：\nplugins:[\t&#x27;@/plugins/router.js&#x27;]\n\n注意导航守卫在服务器端就已经执行，无法获取localStorage和cookie\n解决方法：安装cookie-universal-nuxt\nnpm i cookie-universal-nuxt\n\nnuxt.config.js中:\nmodules:[\t&#x27;cookie-universal-nuxt&#x27;,]\n\n即可正常使用，如：\n\nthis.$cookies.set\nthis.$cookies.get\n\n配置（nuxt.config.js）headhead用于配置title、描述、关键字：\nhead: &#123;  title: &#x27;app&#x27;,  htmlAttrs: &#123;    lang: &#x27;en&#x27;  &#125;,  meta: [    &#123; charset: &#x27;utf-8&#x27; &#125;,//网页编码    &#123; name: &#x27;viewport&#x27;, content: &#x27;width=device-width, initial-scale=1&#x27; &#125;,    &#123; hid: &#x27;description&#x27;, name: &#x27;description&#x27;, content: &#x27;&#x27; &#125;,    &#123; name: &#x27;format-detection&#x27;, content: &#x27;telephone=no&#x27; &#125;  ],  link: [    &#123; rel: &#x27;icon&#x27;, type: &#x27;image/x-icon&#x27;, href: &#x27;/favicon.ico&#x27; &#125;//网页图标  ]&#125;,\n\n如果当前页面的.vue文件没有单独配置head，则使用nuxt.config.js中的head\n在每个页面中单独配置：（使用函数的形式）\n&lt;template&gt;  &lt;div&gt;about&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;About&quot;,  head() &#123;    return &#123;      title: &#x27;about&#x27;,//可以设置为动态数据      meta: [        &#123;hid: &#x27;keywords&#x27;,name:&#x27;keywords&#x27;,content: &#x27;网站关键字&#x27;&#125;,        &#123;hid: &#x27;description&#x27;, name: &#x27;description&#x27;, content: &#x27;网站描述&#x27;&#125;,      ]    &#125;  &#125;&#125;&lt;/script&gt;\n\ncss配置全局的css文件：（比如：初始化css、UI组件库的css文件）\ncss: [  &#x27;@/static/reset.css&#x27;//static下准备样式初始化文件],\n\nplugins配置全局js文件：（比如：axios二次封装、UI组件库）\nplugins: [  &#x27;@/plugins/router.js&#x27;//plugins文件夹下准备全局js文件],\n\nmodulesmodules是Nuxt.js扩展\nnuxt中安装axios(方式一)：\nnpm i @nuxtjs/axios\n\nmodules中配置：\nmodeules:[\t&#x27;@nuxtjs/axios&#x27;]\n\n方式二：\nnpm i axios\n\n由于nuxt项目中没有main.js文件，使用时需要在.vue文件中单独import。\n这里使用方式一：\n在pages下 的页面组件中使用sayncData发送请求：\n&lt;template&gt;  &lt;div&gt;首页&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;IndexPage&#x27;,  data()&#123;    return&#123;      list:[]      &#125;  &#125;,  async asyncData(&#123;$axios&#125;)&#123;//接收一个参数是页面组件上下文    const res = await $axios.get(&#123;url:&#x27;http://xxxxxxxxxxxxx&#x27;&#125;)    return&#123;//asyncData中的this为undefined，需使用return返回数据，返回的数据会合并到组件的data中      list:res.data    &#125;  &#125;&#125;&lt;/script&gt;\n\n在components下的组件使用fetch发送请求获取数据：\n&lt;template&gt;  &lt;div&gt;news&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;News&quot;,  data() &#123;    return &#123;      list: []    &#125;  &#125;,  async fetch() &#123;//也接收一个参数是页面组件上下文，components下的组件接收不到      //fetch函数的this是组件实例，该函数不能直接将数据返回给页面组件，所有可以在components下的组件使用      //如果要在页面组件中使用需要将数据传到vuex中    const res = await this.$axios.get(&#123;url: &#x27;http://xxxxxxxxxxxxx&#x27;&#125;)    this.list = res.data  &#125;&#125;&lt;/script&gt;\n\n配置代理安装aixos和proxy：\nnpm i @nuxtjs/axiosnpm i @nuxtjs/proxy\n\n配置：\nmodules: [  &#x27;@nuxtjs/axios&#x27;,  &#x27;@nuxtjs/proxy&#x27;,],axios: &#123;  proxy: true,//是否可以跨域  baseUrl: &#x27;xxxxxxx&#x27;,  retry: &#123;retries: 3&#125;,//超时重试次数&#125;,proxy: &#123;//配置代理  &#x27;/api&#x27;: &#123;    target: &#x27;http://localhost:8080&#x27;,    pathRewrite: &#123;      &#x27;^/api&#x27;: &#x27;&#x27;    &#125;  &#125;&#125;,\n\naxios二次封装新建plugins/axios,js:\nexport default (&#123;$axios&#125;) =&gt; &#123;  $axios.defaults.timeout = 10000//超时时间  //请求拦截器  $axios.onRequest(config =&gt; &#123;    console.log(config)  &#125;)  //错误拦截器  $axios.onError((error =&gt; &#123;    console.log(error)  &#125;))  //响应拦截器  $axios.onResponse(response =&gt; &#123;    return response.data  &#125;)&#125;\n\n配置:\nplugins: [  &#x27;@/plugins/axios.js&#x27;,],\n\nloading (加载进度条)配置关闭loading：\nloading:false,//默认为true\n\n配置样式：\nloading:&#123;\tcolor:&#x27;blue&#x27;,\theight:&#x27;5px&#x27;&#125;\n\nVuex状态树新建store/index.js：\nexport const state = () =&gt; &#123;//state使用函数，避免返回引用&#125;export const mutations = &#123;&#125;export const actions = &#123;&#125;export const getters = &#123;&#125;\n\n模块：\n新建js文件，模块名就是文件名\nnuxt项目上线\n打包\nnpm run build\n\n将.nuxt、static、nuxt.config.js、package.json四个文件放到服务器中，服务器下载node环境。\n\n服务器安装依赖并启动（依旧是localhost:3000）\nnpm installnpm run start\n\nnginx代理\n\n\n参考视频\n","categories":["SEO","服务端渲染","NUXT"],"tags":["Vue","SEO","Nuxt"]},{"title":"nginx","url":"/2022/03/30/nginx/","content":"前言已准备好如下软件：\n\nVMware\nXshell和Xftp\n\n安装CentOS7.4下载CentOS7.4下载地址\n选择CentOS-7-x86_64-Minimal-1708.iso进行下载\n使用VMware运行虚拟机\n联网修改网卡配置文件：\nvi /etc/sysconfig/network-scripts/ifcfg-ens33\n将ONBOOT=no改为ONBOOT=yes\n保存退出后，执行：（重启网卡）\nsystemctl restart network\n使用ping命令测试可以联网\n重启网卡失败有可能是VMware软件的问题，可卸载重装\n设置静态ip使用Xshell连接虚拟机（Xshell终端的操作更方便）：\n使用ip addr查看ens33的IP地址\n打开Xshell新建连接：\n\n名称随意、主机填写IP地址\n填写用户名（root）和密码、完成连接\n\n修改配置文件：\nvi /etc/sysconfig/network-scripts/ifcfg-ens33\n将BOOTPROTO=dhcp改为BOOTPROTO=static\n添加如下配置ip地址、子网掩码、网关、DNS：（每人的ip地址不同）\nIPADDR=192.168.181.128NETMASK=255.255.255.0GATEWAY=192.168.181.2DNS1=8.8.8.8\n\n查看网关是否正确：\n\nVMware左上角点击编辑\n虚拟网络编辑器\n更改设置\n选择VMnet8\n点击NET设置即可查看网关\n\n重启网卡：systemctl restart network\nping命令测试联网成功（ping 8.8.8.8）\nNginx安装和启动在安装之前可将虚拟机克隆一份：\n\n虚拟机关机\n右键-管理-克隆\n\nnginx官网\n下载地址： nginx-1.21.6\n点击nginx-1.21.6进行下载、完成后通过Xftp将压缩包传到虚拟机上\n也可以直接在虚拟机里使用wget下载\n可参考文章\n安装所需环境：\n\n安装gcc：yum install -y gcc\n\n安装PCRE pcre-devel：yum install -y pcre pcre-devel\n\n安装zlib：yum install -y zlib zlib-devel\n\n\n解压安装nginx：\n\n解压：tar zxvf nginx-1.21.6.tar.gz \n进入 ：cd nginx-1.21.6\n配置并指定安装目录：./configure --prefix=/usr/local/nginx\n编译、安装：make；make install\n\n启动nginx：\n\n进入安装目录：cd /usr/local/nginx/sbin/\n启动：./nginx\n验证：浏览器访问虚拟机的ip地址（需关闭防火墙）\n\n防火墙：\n\n关闭：systemctl stop firewalld.service\n禁止防火墙开机启动：systemctl disable firewalld.service\n\nnginx服务脚本：\n\n创建脚本文件：vi /usr/lib/systemd/system/nginx.service\n\n文件内容：\n[Unit]Description=nginx - web serverAfter=network.target remote-fs.target nss-lookup.target[Service]Type=forkingPIDFile=/usr/local/nginx/logs/nginx.pidExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.confExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.confExecReload=/usr/local/nginx/sbin/nginx -s reloadExecStop=/usr/local/nginx/sbin/nginx -s stopExecQuit=/usr/local/nginx/sbin/nginx -s quitPrivateTmp=true[Install]WantedBy=multi-user.target\n\n保存退出\n\n重新加载系统服务：systemctl daemon-reload\n\n关闭nginx：./nginx -s stop\n\n启动服务：systemctl start nginx.service\n\n查看：systemctl status nginx.service，出现active (running)表示成功\n\n开机启动： systemctl enable nginx.service\n\n重启：reboot，等待一会后浏览器可访问虚拟机ip地址表示脚本成功执行\n\n\nnginx基本使用在修改配置之前克隆一份虚拟机\n目录结构可使用Xftp查看&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;\n\nconf：配置文件\nhtml：静态页面\nlogs：日志\nsbin：nginx的主程序\n\n“_temp”结尾的文件夹是nginx运行时才生成的\n基本运行原理nginx启动后有一个主进程（Master）和多个子进程（Worker）\nMaster校验配置文件，协调子进程\nWorker处理和响应请求\n配置文件（nginx.conf）进入&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;\n使用Xftp时，右键文件可以通过记事本进行编辑\n编辑nginx.conf：（如下是开头的两行）\n#user  nobody;#该符号表示注释worker_processes  1;\n\n先不看带注释的配置：（最小配置文件）\nworker_processes  1; #子进程个数events &#123;    worker_connections  1024; #单个子进程可接受的连接数&#125;http &#123;    include       mime.types; #include：引入其他配置文件；mime.types：指定各种文件后缀的资源类型    default_type  application/octet-stream; #默认类型        sendfile        on; #使用linux的 sendfile(socket, file, len) 高效网络传输，也就是数据0拷贝。        keepalive_timeout  65;        server &#123; #虚拟主机，可以有多个（vhost）        listen       80; #监听的端口号        server_name  localhost; #域名或主机名（可以写多个，用空格隔开）        location / &#123; #uri            root   html; #根目录（html相当于/usr/local/nginx/html/）            index  index.html index.htm; #默认页        &#125;        error_page   500 502 503 504  /50x.html; #服务器错误时的页面        location = /50x.html &#123;            root   html;        &#125;    &#125;&#125;\n\n虚拟主机配置多个server：\nserver &#123;     listen       80;     server_name  www.my.com; #(需在阿里云购买域名)    location / &#123;        root   /www/www; #在虚拟机上创建对应的目录和目录下的资源        index  index.html index.htm;     &#125;    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   html;    &#125;&#125;server &#123;     listen       80;     server_name  *.my.com; # *号表示通配符（匹配所有的三级域名），域名解析时先匹配前面的server，再匹配第二个    location / &#123;        root   /www/video;        index  index.html index.htm;     &#125;    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   html;    &#125;&#125;\n\n修改配置后重新加载nginx：ststemctl reload nginx\nserver_name:还可以使用正则表达式进行匹配\n可以修改本机的hosts文件进行server_name的测试：C:\\Windows\\System32\\drivers\\etc\\hosts（需管理员权限）\n在最后添加：192.168.181.128 x.com,前者为虚拟机ip地址，后者为自定义域名\n修改后可以在本机通过域名访问虚拟机ip地址\n反向代理反向代理服务器（比如nginx）位于用户和目标服务器（比如Tomcat）之间，用户无法直接访问Tomcat，而由nginx接收请求，然后转发给Tomcat，返回数据给nginx后，再返回给用户。\nproxy_pass配置反向代理：\nserver &#123;\n    listen       80;\n    server_name  localhost;\n    location / &#123; #在这里配置proxy_pass，且不需要root和index\n        proxy_pass  http://www.qq.com; #指定服务器\n        #root   html;\n        #index  index.html index.htm;\n    &#125;\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html &#123;\n        root   html;\n    &#125;\n&#125;\n\n重新加载nginx：systemctl reload nginx\n浏览器再次访问虚拟机ip会重定向到腾讯网（外网服务器）(301：重定向，地址栏改变)\n测试代理内网服务器：\n\n克隆一份虚拟机（刚安装配置好nginx的状态）\n\n修改配置文件：vi /etc/sysconfig/network-scripts/ifcfg-ens33\n\n修改IPADDR=192.168.181.128为IPADDR=192.168.181.129\n\n重启网卡：systemctl restart network\n\nXshell连接192.168.181.129\n\n修改&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;index.html\n\nXshell连接192.168.181.128\n\n修改配置：proxy_pass http://192.168.181.129 ; #指定服务器\n\n重新加载nginx：systemctl reload nginx\n\n浏览器访问192.168.181.128，显示192.168.181.129上的index.html（地址栏不变）\n\n\n负载均衡反向代理多个服务器，当nginx接收到请求时，通过轮询的方式将请求转发给服务器（轮流）\n按照之前的流程再克隆一个虚拟机，ip设置为192.168.181.130并修改index.html\nXshell连接192.168.181.128，进行配置：\nupstream httpds&#123; #upstream:对应多组服务器，httpds：自定名称\tserver 192.168.181.129;\tserver 192.168.181.130;&#125;server &#123;    listen       80;    server_name  localhost;    location / &#123;    \tproxy_pass  http://httpds; #httpds:对应upstream的名称    &#125;    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   html;    &#125;&#125;\n\nupstream和server同级\n重新加载nginx：systemctl reload nginx\n浏览器多次访问192.168.181.128，轮流显示两个服务器中index.html的内容\n负载均衡策略\n权重 weight\nupstream httpds&#123;\tserver 192.168.181.129 weight=8; #添加weight：值越大，访问该服务器的概率越大\tserver 192.168.181.130 weight=2;&#125;\n\n下线 down\nupstream httpds&#123;\tserver 192.168.181.129 weight=8 down; #down：该服务器不会被访问（出现故障时下线该服务器）\tserver 192.168.181.130 weight=2;&#125;\n\n备用 backup\nupstream httpds&#123;\tserver 192.168.181.129 weight=8 down;\tserver 192.168.181.130 weight=2 backup; #backup：备用机，只有其他服务器都不可用时才会被使用&#125;\n\n都需要手动配置文件然后reload nginx\n动静分离将静态资源（比如图片、css、js）放在nginx上\n在nginx配置中的server下配置多个location即可（也可使用正则）：\nlocation / &#123;\n    proxy_pass  192.168.181.129;\n&#125;\n\n# ~号表示开始正则匹配，*号表示不区分大小写\nlocation ~*/(img|css|js) &#123; #匹配根目录下的三种文件夹（img|css|js），优先级比location /高\n    root html; #根目录：/usr/local/nginx/html/\n    index index.html index.htm;\n&#125;\n\nURLRewrite重写url，可以隐藏真实的url\nlocation / &#123;\trewrite  ^/([0-9]+).html$  /index.html?pageNum=$1  break;\tproxy_pass  192.168.181.129;&#125;\n\nrewrite  &lt;正则&gt;  &lt;真实uri&gt;  &lt;标识&gt;;\n^:正则开始，$:正则结束\n将匹配到的正则替换为真实uri（$1:表示正则表达式的第一个括号里匹配到的内容）\n四种标识:\n\nlast #本条规则匹配完成后，继续向下匹配新的location URI规则 \nbreak #本条规则匹配完成即终止，不再匹配后面的任何规则 \nredirect #返回302临时重定向，浏览器地址会显示跳转后的URL地址 \npermanent #返回301永久重定向，浏览器地址栏会显示跳转后的URL地址\n\n参考视频\n","categories":["nginx"],"tags":["nginx","CentOS"]},{"title":"手写vue-lazyload","url":"/2022/04/03/%E6%89%8B%E5%86%99vue-lazyload/","content":"vue-lazyloadmain.js中引入vue-lazyload：\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import VueLazyload from &quot;vue-lazyload&quot;;Vue.use(VueLazyload,&#123;  loading:&#x27;http://localhost:3000/img/loading.gif&#x27;, //图片加载中显示的图片  error:&#x27;http://localhost:3000/img/error-img.png&#x27;, //图片加载错误显示的图片  preLoad:1 //超出1倍屏幕高度的图片先不加载&#125;)\n\n.vue文件中使用：\n使用指令v-lazy代替img标签的src属性，表示该图片使用懒加载\n&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;div v-for=&quot;(item,index) in imgData&quot; :key=&quot;index&quot;&gt;      &lt;div class=&quot;img&quot;&gt;        &lt;img v-lazy=&quot;item.img&quot; alt=&quot;img&quot;&gt;      &lt;/div&gt;      &lt;div class=&quot;content&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &#x27;axios&#x27;export default &#123;  name: &#x27;App&#x27;,  data() &#123;    return &#123;      imgData: []    &#125;  &#125;,  mounted() &#123;    this.getImgs()  &#125;,  methods: &#123;    async getImgs() &#123;      const res = await axios.get(&#x27;http://localhost:3000/imgs&#x27;)      this.imgData = res.data    &#125;  &#125;&#125;&lt;/script&gt;\n\n自定义指令实现v-lazy手写插件vue-lazyload新建文件modules/vue-lazyload/index.js:\nexport default &#123; //默认暴露一个带有install方法的对象  install(Vue,options)&#123; //Vue：Vue构造器，options：使用插件时传入的配置对象      &#125;&#125;\n\nmain.js中引入自己的插件：\nimport VueLazyload from &quot;./modules/vue-lazyload&quot;;\n\n自定义指令export default &#123;  install(Vue, options) &#123;    //自定义指令,参数一：自定义指令名，参数二：定义该指令功能的对象    Vue.directive(&#x27;lazy&#x27;, &#123;      //指令定义对象可以调用一些钩子函数：比如bind、inserted      //钩子函数的参数，el：指令所绑定的元素，binding：一个对象，vnode：虚拟节点      //bind：只调用一次，指令第一次绑定到元素时调用      bind(el,binding,vnode)&#123;      &#125;    &#125;)  &#125;&#125;\n\n功能实现的类接下来就需要在bind钩子函数中实现功能逻辑，为了更好的扩展性，将功能封装成一个类：\n创建modules/vue-lazyload/lazy.js：\nexport default function (Vue) &#123; //暴露一个函数，接收Vue构造器  return class Lazy &#123; //返回一个类，接收options    constructor(options) &#123;      this.options = options    &#125;      //实现功能的函数    bindLazy(el, binding) &#123;    &#125;  &#125;&#125;\n\nmodules/vue-lazyload/index.js:\nimport lazy from &#x27;./lazy&#x27; //导入lazy.jsexport default &#123;  install(Vue, options) &#123;    const LazyClass = lazy(Vue)    const lazyload = new LazyClass(options)    Vue.directive(&#x27;lazy&#x27;, &#123;      bind: lazyload.bindLazy.bind(lazyload) //绑定函数，注意修改this指向    &#125;)  &#125;&#125;\n\n准备一个函数，用于获取dom的最近的滚动父节点（overflow：scroll）\n创建modules/vue-lazyload/util.js:\nexport function getScrollParent(el) &#123;  let _parent = el.parentNode  while (_parent) &#123;      //getComputedStyle：获取目标的所有css属性    const overflow = getComputedStyle(_parent)[&#x27;overflow&#x27;] //获取overflow属性值    if (/(scroll)|(auto)/.test(overflow)) &#123;      return _parent    &#125;    _parent = _parent.parentNode  &#125;&#125;\n\nlazy.js中使用Vue.nextTick:\nimport &#123;getScrollParent&#125; from &#x27;./util&#x27;export default function (Vue) &#123;  return class Lazy &#123;    constructor(options) &#123;      this.options = options      this.isAddScrollListener = false     &#125;    bindLazy(el, binding) &#123;      Vue.nextTick(() =&gt; &#123;        const scrollParent = getScrollParent(el)        if (scrollParent &amp;&amp; !this.isAddScrollListener) &#123; //如果还没有绑定事件          scrollParent.addEventListener(&#x27;scroll&#x27;,this.handleScroll.bind(this))        &#125;      &#125;)    &#125;    //滚动事件    handleScroll()&#123;    &#125;  &#125;&#125;\n\n图片实例的类创建modules/vue-lazyload/lazyimg.js:\nexport default class Lazyimg &#123;  constructor(&#123;el, src, options, imgRender&#125;) &#123;    this.el = el    this.src = src    this.options = options    this.imgRender = imgRender    this.loaded = false //已经加载过    this.state = &#123;      loading: false, //加载成功      error: false //加载失败    &#125;  &#125;i  //图片是否在指定范围内  checkIsVisible() &#123;    const &#123;top&#125; = this.el.getBoundingClientRect() //获取元素距顶部的距离    return top &lt; window.innerHeight * (this.options.preLoad || 1.3) //判断是否在范围内，preLoad默认1.3  &#125;  //加载图片（未完成，第二个参数先写死成loading，参数一为该图片实例）  loadImg() &#123;    this.imgRender(this,&#x27;loading&#x27;) //加载图片，图片加载中时显示的图片  &#125;&#125;\n\nlazy.js:每次触发bind时创建一个图片实例，保存到数组\nimport &#123;getScrollParent&#125; from &#x27;./util&#x27;import &#123;throttle&#125; from &#x27;lodash&#x27; //节流import Lazyimg from &quot;./lazyimg&quot;;export default function (Vue) &#123;  return class Lazy &#123;    constructor(options) &#123;      this.options = options      this.isAddScrollListener = false      this.lazyimgPool = [] //图片实例数组    &#125;    bindLazy(el, binding) &#123;      Vue.nextTick(() =&gt; &#123;        const scrollParent = getScrollParent(el)        if (scrollParent &amp;&amp; !this.isAddScrollListener) &#123;          scrollParent.addEventListener(&#x27;scroll&#x27;, throttle(this.handleScroll.bind(this), 200))          this.isAddScrollListener = true        &#125;          //创建一个新的图片实例        const lazyimg = new Lazyimg(&#123;           el,          src: binding.value, //v-lazy指令绑定的值          options: this.options,          imgRender: this.imgRender.bind(this)        &#125;)        this.lazyimgPool.push(lazyimg)        this.handleScroll() //滚动事件在一开始就执行一次      &#125;)    &#125;    //滚动事件    handleScroll() &#123;    &#125;    //图片渲染函数    imgRender() &#123;    &#125;  &#125;&#125;\n\n滚动事件handleScroll() &#123;  let isVisible = false  this.lazyimgPool.forEach(lazyimg =&gt; &#123;    if (!lazyimg.loaded) &#123; //图片还没有加载      isVisible = lazyimg.checkIsVisible() //图片是否出现在指定的范围内（perLoad指定的）      isVisible &amp;&amp; lazyimg.loadImg() //如果出现在范围内，则加载图片    &#125;  &#125;)&#125;\n\n渲染图片imgRender(lazyimg, state) &#123;  const &#123;el, options&#125; = lazyimg  const &#123;loading, error&#125; = options  let src = &#x27;&#x27;  switch (state) &#123;    case &#x27;loading&#x27;: //加载中      src = loading || &#x27;&#x27;      break    case &#x27;error&#x27;: //加载错误      src = error || &#x27;&#x27;      break    default: //加载完成，显示真正的目标图片      src = lazyimg.src  &#125;  el.setAttribute(&#x27;src&#x27;,src) //设置或改变图片的src&#125;\n\n渲染完成util.js中添加：\nexport function imgLoad(src) &#123;  return new Promise(((resolve, reject) =&gt; &#123;    const oImg = new Image()    oImg.src = src    oImg.onload = resolve //加载成功    oImg.onerror = reject //加载失败  &#125;))&#125;\n\nlazy.js:\nloadImg() &#123;  this.imgRender(this, &#x27;loading&#x27;)  imgLoad(this.src).then(() =&gt; &#123;//成功    this.state.loading = true    this.imgRender(this, &#x27;ok&#x27;)     this.loaded = true  &#125;).catch(() =&gt; &#123;//失败    this.state.error = true    this.imgRender(this, &#x27;error&#x27;)    this.loaded = true  &#125;)&#125;\n\n通过IntersectionObserver实现export default &#123;  install(Vue, options) &#123;    Vue.directive(&#x27;lazy&#x27;, &#123;      bind(el, binding) &#123;        init(el, binding.value, options.loading)      &#125;,      inserted(el) &#123;        observer(el)      &#125;    &#125;)  &#125;&#125;// 初始化function init(el, src, loading) &#123;  el.setAttribute(&#x27;data-src&#x27;, src)  el.setAttribute(&#x27;src&#x27;, loading)&#125;// 利用IntersectionObserver监听elfunction observer(el) &#123;  let observer = new IntersectionObserver(entries =&gt; &#123;    if (entries[0].isIntersecting)&#123; //进入视口      let realSrc=el.dataset.src      if (realSrc)&#123;        el.setAttribute(&#x27;src&#x27;,realSrc)        el.removeAttribute(&#x27;data-src&#x27;)      &#125;    &#125;  &#125;)  observer.observe(el)&#125;\n\n生成观察器实例：let observer = new IntersectionObserver(callback,option)\n接收两个参数，callback：可见性变化时的回调函数，option：可选的配置项\ncallback：\n一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。\nlet io = new IntersectionObserver(  entries =&gt; &#123;    console.log(entries);  &#125;)\n\nenteries：是一个数组，每个成员是IntersectionObserverEntry对象，如果同时有多个被观察的对象的可见性发生变化，enteries数组就有多个成员。\nIntersectionObserverEntry对象的部分属性：\n\nisIntersecting：是否可见\ntime：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒\nboundingClientRect：目标元素的矩形区域信息\nintersectionRatio：目标元素的可见比例，完全可见时为1，完全不可见时小于等于0\nintersectionRect：目标元素与视口（或根元素）的交叉区域的信息\ntarget：目标元素\nrootBounds：根元素的矩形区域的信息\n\noption对象属性：\n\nthreshold：数组，决定何时触发回调函数，比如，[0, 0.25, 0.5, 0.75, 1]就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。\nroot、rootMargin：root属性指定目标元素所在的容器节点（即根元素）。注意，容器元素必须是目标元素的祖先节点。rootMargin属性。后者定义根元素的margin，用来扩展或缩小rootBounds这个矩形的大小，从而影响intersectionRect交叉区域的大小。它使用CSS的定义方法，比如10px 20px 30px 40px，表示 top、right、bottom 和 left 四个方向的值。\n\n参考文档\n参考视频\n","categories":["手写","vue"],"tags":["vue","vue-lazyload","图片懒加载","插件","自定义指令","IntersectionObserver"]},{"title":"js垃圾回收","url":"/2022/04/06/js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","content":"js垃圾回收机制\n找出不在使用的变量\n释放器内存空间\n固定的时间间隔执行\n\n标记清除当变量进入执行环境是，就标记这个变量为“进入环境“，进入环境的变量所占用的内存就不能释放。当变量离开环境时，则将其标记为“离开环境“。\n被标记为“离开环境”的变量等待垃圾回收。\n全局变量和闭包所形成的特殊的变量不会被标记为“离开环境”：\nfunction f1()&#123;    let a=1    return function f2()&#123;        a++        console.log(a)    &#125;&#125;const f3 = f1()f3() //2f3() //3\n\n在上述代码中，函数执行完之后变量a并没有消失，因为不会被标记清除，也就是不会被垃圾回收。\n解决：\nf3 = null\n\n引用计数根据一个值的引用次数来判断是否进行垃圾回收，如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。\nconst a = new Object() //a的引用数:1const b = new Object() //b的引用数:1let c = a //a的引用数:2let c = b //a的引用数:1,b的引用数:2a.prop = bb.prop = a //a的引用数:2,b的引用数:2\n\n如上所示，a和b的引用数永远都大于0，不会被垃圾回收。所以使用引用计数来进行垃圾回收的浏览器较少。\n解决：(解除引用)\na = nullb = null\n\nV8引擎垃圾回收V8是一个由Google开源的采用C++编写的高性能JavaScript和WebAssembly引擎，应用在 Chrome和Node.js等。\n在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象(大部分对象)，老生代中存放的生存时间久的对象（比如Vue）。\n新生代的内存空间小（16&#x2F;32M），老生代的内存空间大（0.7&#x2F;1.4G）\n新时代的对象被使用很多次之后会被转移到老生代中，老生代使用的垃圾回收机制就是标记清除。\n新时代的垃圾回收机制是Scavenge，Scavenge又是基于cheney算法的：\ncheney算法将内存分为from和to两个区域（各一半），正在使用的对象都存在from中，假如有一个对象被赋值为null（等待垃圾回收）\n\n将需要被回收的对象留在from中，其他数据转移到to中\n将from和to中的所有数据互换\n将to中的数据回收\n\ncheney算法用空间换取时间（有一半内存不能用）\n参考视频\n","categories":["JavaScript"],"tags":["JavaScript","垃圾回收","V8引擎"]},{"title":"古典密码Vigenere算法","url":"/2022/04/08/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81Vigenere%E7%AE%97%E6%B3%95/","content":"代码如下（html文件）：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Title&lt;/title&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;style&gt;    #root &#123;      width: 60%;      margin: auto;    &#125;    .header &#123;      width: 360px;      margin: auto;    &#125;    .main &#123;      display: flex;      justify-content: left;      padding-top: 20px;    &#125;    .area &#123;      width: 40%;      padding-right: 80px;    &#125;    .area textarea &#123;      width: 100%;      height: 120px;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;root&quot;&gt;  &lt;div class=&quot;header&quot;&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;请输入密钥&quot; v-model.lazy.trim=&quot;key&quot; @blur=&quot;setKey&quot;&gt;    &lt;button @click=&quot;encryption&quot;&gt;加密&lt;/button&gt;    &lt;button @click=&quot;decrypt&quot;&gt;解密&lt;/button&gt;  &lt;/div&gt;  &lt;div class=&quot;main&quot;&gt;    &lt;div class=&quot;area&quot;&gt;      &lt;textarea placeholder=&quot;请输入明文/密文&quot; v-model.lazy.trim=&quot;put&quot;&gt;&lt;/textarea&gt;    &lt;/div&gt;    &lt;div class=&quot;area&quot;&gt;      &lt;textarea placeholder=&quot;加密/解密的结果&quot; v-model.lazy.trim=&quot;out&quot;&gt;&lt;/textarea&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;&lt;script&gt;  Vue.config.productionTip = false;   //阻止 vue 在启动时生成生产提示  new Vue(&#123;    el: &quot;#root&quot;,    data: &#123;      key: &#x27;&#x27;,      put: &#x27;&#x27;,//输入      out: &#x27;&#x27;,//输出    &#125;,    computed: &#123;      table() &#123;        const obj = &#123;&#125;        let c1 = &#x27;&#x27;, c2 = &#x27;&#x27;, r = &#x27;&#x27;        for (let i = 97; i &lt; 123; i++) &#123;          c1 = String.fromCharCode(i)          obj[c1] = &#123;&#125;          for (let n = 97; n &lt; 123; n++) &#123;            let res = n + i - 97            c2 = String.fromCharCode(n)            r = String.fromCharCode(res &gt; 122 ? res - 26 : res)            obj[c1][c2] = r          &#125;        &#125;        return obj      &#125;    &#125;,    methods: &#123;      setKey() &#123;        if (!/^[a-z|A-Z]+$/.test(this.key)) &#123;          this.key = &#x27;&#x27;        &#125;      &#125;,      //加密按钮回调      encryption() &#123;        let &#123;put, key&#125; = this        key = key.toLowerCase()        let out = []        let n = 0        const l = key.length - 1        if (put &amp;&amp; key) &#123;          for (let i = 0; i &lt; put.length; i++) &#123;            if (/[a-z]/.test(put[i])) &#123;              out.push(this.table[key[n]][put[i]])            &#125; else if (/[A-Z]/.test(put[i])) &#123;              let char = this.table[key[n]][put[i].toLowerCase()]              out.push(char.toUpperCase())            &#125; else &#123;              out.push(put[i])            &#125;            n === l ? n = 0 : n++          &#125;          this.out = out.join(&#x27;&#x27;)        &#125;      &#125;,      //解密按钮回调      decrypt() &#123;        let &#123;put, key&#125; = this        key = key.toLowerCase()        let out = []        let n = 0        const l = key.length - 1        if (put &amp;&amp; key) &#123;          for (let i = 0; i &lt; put.length; i++) &#123;            if (/[a-z]/.test(put[i])) &#123;              out.push(this.decryptUtil(key[n], put[i]))            &#125; else if (/[A-Z]/.test(put[i])) &#123;              let char = this.decryptUtil(key[n], put[i].toLowerCase())              out.push(char.toUpperCase())            &#125; else &#123;              out.push(put[i])            &#125;            n === l ? n = 0 : n++          &#125;          this.out = out.join(&#x27;&#x27;)        &#125;      &#125;,      //解密      decryptUtil(key, value) &#123;        for (let i = 97; i &lt; 123; i++) &#123;          if (this.table[key][String.fromCharCode(i)] === value) &#123;            return String.fromCharCode(i)          &#125;        &#125;      &#125;    &#125;  &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n","categories":["信息安全","古典密码"],"tags":["JavaScript","Vue","Vigenere"]},{"title":"axios","url":"/2022/04/08/axios/","content":"axios基本使用安装：\nnpm install axios\n\n发送请求：\naxios(&#123;          url:&#x27;xxx&#x27;,    // 设置请求的地址  method:&quot;GET&quot;, // 设置请求方法  params:&#123;      // get请求使用params进行参数凭借,如果是post请求用data    type: &#x27;&#x27;,    page: 1  &#125;&#125;).then(res =&gt; &#123;    // res为后端返回的数据  console.log(res);   &#125;)\n\n二次封装const requests = axios.create(&#123;    //配置对象    baseURL: process.env.VUE_APP_BASEURL,//基础路径，自动加在端口后    timeout: 5000,//超时的时间    headers:&#123;...&#125;//通用请求头&#125;)\n\n请求拦截器axios.interceptors.request.use(  config =&gt; &#123;    if (store.state.user.token) &#123;        config.headers.token = store.state.user.token    &#125;    return config  &#125;,  error =&gt; &#123;    return Promise.error(error)  &#125;)\n\n响应拦截器requests.interceptors.response.use((res) =&gt; &#123;    //成功的回调    return res.data//返回数据部分&#125;, (err) =&gt; &#123;    //失败的回调    return Promise.reject(new Error(&#x27;失败&#x27;))&#125;)\n\n取消请求方式一：\nconst CancelToken = axios.CancelToken;const source = CancelToken.source(); axios.post(url, &#123;    data&#125;, &#123;    cancelToken: source.token&#125;)// 取消请求 (请求原因是可选的)source.cancel(&#x27;主动取消请求&#x27;);\n\n方式二：\nconst CancelToken = axios.CancelToken;let cancel;axios.get(url, &#123;  cancelToken: new CancelToken(function executor(c) &#123;    cancel = c;  &#125;)&#125;);cancel(&#x27;主动取消请求&#x27;);\n\n简易原理class Axios &#123;    constructor() &#123;    &#125;    request(config) &#123;        return new Promise(resolve =&gt; &#123;            const &#123;url = &#x27;&#x27;, method = &#x27;get&#x27;, data = &#123;&#125;&#125; = config;            // 发送ajax请求            const xhr = new XMLHttpRequest();            //参数3：是否为异步请求，默认为true            xhr.open(method, url, true);            xhr.onload = function() &#123;                console.log(xhr.responseText)                resolve(xhr.responseText);            &#125;            xhr.send(data);        &#125;)    &#125;&#125;//生成axios实例function CreateAxiosFn() &#123;    let axios = new Axios();    let req = axios.request.bind(axios);    return req;&#125;// 得到最后的全局变量axioslet axios = CreateAxiosFn();\n","categories":["axios"],"tags":["axios","xhr","ajax"]},{"title":"ArrayBuffer","url":"/2022/04/09/ArrayBuffer/","content":"ArrayBuffer存储固定btye（字节）的二进制数据，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。\n使用：\nconst buf = new ArrayBuffer(32) //生成一段32字节的连续内存空间，每个字节的值默认都是 0。\n\nbtyeLength二进制数组的字节长度\nconst buffer = new ArrayBuffer(32)buffer.byteLength // 32\n\nslice截取\nconst buffer = new ArrayBuffer(32)const newBuffer = buffer.slice(2,6) //拷贝第2至5个字节\n\nisView表示参数是否为ArrayBuffer的视图实例。\nconst buffer = new ArrayBuffer(8);ArrayBuffer.isView(buffer) // falseconst v = new Int32Array(buffer);ArrayBuffer.isView(v) // true\n\nTypedArray视图TypedArray一共包括九种：\n\nInt8Array：8 位有符号整数，长度 1 个字节。\nUint8Array：8 位无符号整数，长度 1 个字节。\nUint8ClampedArray：8 位无符号整数，长度 1 个字节，溢出处理不同。\nInt16Array：16 位有符号整数，长度 2 个字节。\nUint16Array：16 位无符号整数，长度 2 个字节。\nInt32Array：32 位有符号整数，长度 4 个字节。\nUint32Array：32 位无符号整数，长度 4 个字节。\nFloat32Array：32 位浮点数，长度 4 个字节。\nFloat64Array：64 位浮点数，长度 8 个字节。\n\n以上九种构造函数统称为TypedArray视图，数组的大部分方法它们都能使用。（concat不能）\n特点：\n\n每个数组成员的类型相同\n每个数组成员的默认值为0\n\n使用：\nconst b = new ArrayBuffer(8);// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾const v1 = new Int32Array(b);// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾const v2 = new Uint8Array(b, 2);// 创建一个指向b的Int16视图，开始于字节2，长度为2const v3 = new Int16Array(b, 2, 2);\n\n参数1：ArrayBuffer对象，参数2：视图开始的字节数，必须为每个成员字节数的整数倍（可选），参数3：视图的长度（可选）\n上面三个视图指向同一个ArrayBuffer对象，只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。\nTypedArray视图还可以不接收ArrayBuffer生成：\n\n数字（长度）：const f64a = new Float64Array(8) //8个Float64  \n普通数组：const typedArray = new Uint8Array([1, 2, 3, 4])\n另一个TypedArray\n\nDataView视图使用：\nconst buffer = new ArrayBuffer(24);const dv = new DataView(buffer);\n\n参数1：ArrayBuffer对象，参数2：视图开始的字节数（可选），参数3：视图的长度（可选）\nDataView实例提供 8 个方法读取内存：（参数：开始的字节序号）\n\ngetInt8：读取 1 个字节，返回一个 8 位整数。\ngetUint8：读取 1 个字节，返回一个无符号的 8 位整数。\ngetInt16：读取 2 个字节，返回一个 16 位整数。\ngetUint16：读取 2 个字节，返回一个无符号的 16 位整数。\ngetInt32：读取 4 个字节，返回一个 32 位整数。\ngetUint32：读取 4 个字节，返回一个无符号的 32 位整数。\ngetFloat32：读取 4 个字节，返回一个 32 位浮点数。\ngetFloat64：读取 8 个字节，返回一个 64 位浮点数。\n\nDataView 视图提供 8 个方法写入内存：（参数1：开始的字节序号，参数2：写入的数据）\n\nsetInt8：写入 1 个字节的 8 位整数。\nsetUint8：写入 1 个字节的 8 位无符号整数。\nsetInt16：写入 2 个字节的 16 位整数。\nsetUint16：写入 2 个字节的 16 位无符号整数。\nsetInt32：写入 4 个字节的 32 位整数。\nsetUint32：写入 4 个字节的 32 位无符号整数。\nsetFloat32：写入 4 个字节的 32 位浮点数。\nsetFloat64：写入 8 个字节的 64 位浮点数。\n\nget和set方法还可接收最后一个参数：false：表示使用大端字节序（默认），true：表示使用小端字节序\n\n大端字节序：从多字节数据类型的第一个字节开始读取（或存储）\n小端字节序：从多字节数据类型的最后一个字节开始读取（或存储）\n\n参考文献\n","categories":["ES6"],"tags":["ES6","ArrayBuffer","TypedArray","DataView"]},{"title":"MongoDB","url":"/2022/04/10/MongoDB/","content":"安装（win系统）下载下载地址\n下载zip压缩包，并解压。\n创建服务在mongodb目录下创建两个目录data和logs，分别用于存放数据和日志（和bin目录同级）\n管理员身份运行cmd，进入mongodb下的bin目录。\ncmd下进行安装：（两个path后输入自己新建的两个目录的地址，logs目录后需要加上mongodb.log）\nmongod --install --dbpath D:\\MongoDB\\data --logpath D:\\MongoDB\\logs\\mongodb.log\n\n没有报错即为成功\n验证：键盘点击win+R，输入services.msc，能找到MongoDB即可\n启动服务cmd中：\nnet start mongodb #启动mongo #进入mongodbexit #退出\n\n\n\n基本使用MongoDB/bin下打开cmd：输入mongo开始使用\n\n查看数据库：show databases\n选择数据库：use test1（隐式创建：选择不存在的数据库不会报错，如果之后该数据库有数据时会自动创建）\n查看集合：show collections\n创建集合：db.createCollection(&#39;集合名&#39;)\n删除集合：db.集合名.drop()\n\n增删改查\n插入数据：db.集合名.insert(JSON数据)\nuse test2db.c1.insert(&#123;uname:&#x27;luo&#x27;,age:18&#125;) #注：集合不存在则隐式创建#注：MongoDB会给每条数据添加一个_id(全球唯一)\n\n一次性插入多条数据：插入数组即可\n多次插入数据：mongodb支持部分js语法，所以可以使用循环：\nfor(var i=0;i&lt;3;i++)&#123;    db.c1.insert(&#123;uname:&#x27;a&#x27;+i,age:i&#125;) &#125;\n\n查询数据：db.集合名.find()\ndb.c1.find() #查询所有数据#输出：&#123; &quot;_id&quot; : ObjectId(&quot;6252c272dbdf6baae7f71b64&quot;), &quot;uname&quot; : &quot;luo&quot;, &quot;age&quot; : 18 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;6252e60235f4e186f4e8dbfa&quot;), &quot;uname&quot; : &quot;a0&quot;, &quot;age&quot; : 0 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;6252e60235f4e186f4e8dbfb&quot;), &quot;uname&quot; : &quot;a1&quot;, &quot;age&quot; : 1 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;6252e60235f4e186f4e8dbfc&quot;), &quot;uname&quot; : &quot;a2&quot;, &quot;age&quot; : 2 &#125;#注：MongoDB会给每条数据添加一个_id(全球唯一)\n\n格式化输出数据：db.集合名.find().pretty()\n条件查询：db.集合名.find(条件)\ndb.c1.find(&#123;age:1&#125;) #age=1的数据db.c1.find(&#123;uname:&#x27;a0&#x27;,age:0&#125;) #多条件查询\n\n其他运算符：db.集合名.find(&#123;键:&#123;运算符:值&#125;)\n\n\n\n运算符\n作用\n\n\n\n$gt\n大于\n\n\n$gte\n大于等于\n\n\n$lt\n小于\n\n\n$lte\n小于等于\n\n\n$ne\n不等于\n\n\n$in\nin\n\n\n$nin\nnot in\n\n\ndb.c1.find(&#123;age:&#123;&amp;gt:1&#125;) #age&gt;1的数据db.c1.find(&#123;age:&#123;&amp;in:[0,2]) #age=0或2的值\n\n查询列：（传入第二个参数）\ndb.c1.find(&#123;&#125;,&#123;age:1&#125;) #只显示age列db.c1.find(&#123;&#125;,&#123;age:0&#125;) #显示除了age列的其他列#注：无论何时_id都会显示\n\n修改数据：db.集合名.update(条件,新数据)\ndb.c1.update(&#123;uname:&#x27;luo&#x27;&#125;,&#123;uname:&#x27;zhang&#x27;&#125;) #不只是修改uname，而是直接用新数据替换（所以修改后age没有了）#注：默认只修改符合条件的第一条数据\n\n其他运算符：\n\n\n\n修改器\n作用\n\n\n\n$inc\n递增\n\n\n$rename\n修改列名\n\n\n$set\n修改列值\n\n\n$unset\n删除列\n\n\ndb.c1.update(&#123;uname:&#x27;luo&#x27;&#125;,&#123;$set:&#123;uname:&#x27;zhang&#x27;&#125;&#125;) #只修改uname，所以age还在db.c1.update(&#123;uname:&#x27;luo&#x27;&#125;,&#123;$inc:&#123;age:3&#125;&#125;) #age增加3（负数为减）db.c1.update(&#123;uname:&#x27;luo&#x27;&#125;,&#123; #同时进行多种修改\t$set:&#123;uname:&#x27;zhang&#x27;&#125;,\t$inc:&#123;age:3&#125;&#125;)\n\n是否新增：第三个参数（true：未匹配到数据则新插入一条数据，false：默认值，不新增）\n是否修改多条：第四个参数（true：修改所有匹配的数据，false：默认值，修改匹配到的第一条数据）\n\n删除数据：db.集合名.remove(条件)\n是否只删除一条：第二个参数（true：只删除第一条数据，false：默认值，删除所有匹配的数据）\n\n\n排序和分页\n排序：db.集合名.find().sort(&#123;键：值&#125;)\ndb.c1.find().sort(&#123;age:0&#125;) #根据age进行排序，1表示升序，-1表示降序\n\n分页：db.集合名.find().skip(数字).limit(数字)\ndb.c1.find().limit(2) #查询两条数据，limit：限制查询的数量db.c1.find().skip(1) #skip：跳过指定的数量db.c1.find().skip(1).limit(2) #一起使用时，skip写在前面db.c1.find().count() #count:计数，显示结果的条数\n\n聚合查询db.集合名.aggregate([\t&#123;管道:&#123;表达式&#125;&#125;\t...])\n\n常用管道\n$group\t将集合中的文档分组，用于统计结果$match\t过滤数据，只要输出符合条件的文档$sort\t聚合数据进一步排序$skip\t跳过指定文档数$limit\t限制集合数据返回文档数\n\n常用表达式\n$sum\t总和$avg\t平均$min\t最小值$max\t最大值\n\n\n分组\ndb.c1.aggregate([\t&#123;\t\t$group:&#x27;$sex&#x27;,  # $group：分组，按sex进行分组，sex前需加上$符\t\tsum:&#123;$sum:&#x27;$age&#x27;&#125; # $sum：总和，同一组的age的总和，age前需加上$符，并将结果显示在sum列中\t&#125;])db.c1.aggregate([\t&#123;\t\t$group:null, # $group为null表示不分组\t\tsum:&#123;$sum:1&#125;, # $sum为1表示统计每组的数据条数\t\tavg:&#123;$avg:&#x27;$age&#x27;&#125; # $avg：平均值\t&#125;])\n\n多个管道\ndb.c1.aggregate([\t&#123;\t\t$group:&#x27;$sex&#x27;,\t\tsum:&#123;$sum:&#x27;$age&#x27;&#125;\t&#125;，\t&#123;\t\t$sort:&#123;sum:1&#125; #sort:排序，sum:1表示按照sum升序\t&#125;])\n\n索引索引是一个排序好的数据结构，可以提高数据查询的效率，但大量索引也会影响数据，因为每次插入和修改数据都需要更新索引\n\n创建索引：db.集合名.createIndex(待创建索引的列)\ndb.c1.createIndex(&#123;uname:1&#125;) #按照name字段升序创建索引db.c1.createIndex(&#123;uname:1,age:1&#125;) #复合索引\n\n自定义索引名：(第二个参数对象中，name:指定索引名)\ndb.c1.createIndex(&#123;uname:1&#125;,&#123;name:&#x27;unameIndex&#x27;&#125;)\n\n唯一索引：(第二个参数对象中，unique:是否唯一)\n#建立唯一索引后，所有数据的uname不能重复db.c1.createIndex(&#123;uname:1&#125;,&#123;unique:true&#125;)\n\n查看索引：db.集合名.getIndexes()\ndb.c1.getIndexes()#结果：[        &#123;                &quot;v&quot; : 2,                &quot;key&quot; : &#123;                        &quot;_id&quot; : 1                &#125;,                &quot;name&quot; : &quot;_id_&quot;        &#125;,        &#123;                &quot;v&quot; : 2,                &quot;key&quot; : &#123; #根据哪个key建立的索引                        &quot;uname&quot; : 1                &#125;,                &quot;name&quot; : &quot;uname_1&quot; #索引名        &#125;]\n\n删除索引：db.集合名.dropIndex(索引名)\n#先通过getIndexes()查看索引名db.c1.dropIndex(&#x27;uname_1&#x27;)db.c1.dropIndexes() #删除全部索引（除系统自带的）\n\n分析（explain）explain()帮助我们查看此次查询的相关数据（是否使用索引查询，查询速度）\n基本使用：\ndb.c1.find(&#123;age:1&#125;).explain()\n\n权限机制开启验证模式\n添加超级管理员（输入mongo进入MongoDB后use admin）\n#创建账号db.createUser(&#123;\t&quot;user&quot;:&quot;账号&quot;,\t&quot;pwd&quot;:&quot;密码&quot;,\t&quot;roles&quot;:[&#123;\t\trole:&quot;角色&quot;,\t\tdb:&quot;所属数据库&quot; #就是admin\t&#125;]&#125;)#比如：db.createUser(&#123;\tuser:&#x27;admin&#x27;,\tpwd:&#x27;123456&#x27;,\troles:[&#123;\t\trole:&#x27;root&#x27;,\t\tdb:&#x27;admin&#x27;\t&#125;]&#125;)\n\n卸载服务（管理员身份运行cmd）\n#在MongoDB/bin目录下执行mongod --remove\n\n安装需要身份验证的MongoDB服务（添加--auth）\nmongod --install --dbpath D:\\MongoDB\\data --logpath D:\\MongoDB\\logs\\mongodb2.log --auth注：.log文件名不能和之前安装时的重复#启动服务net start mongodb\n\n登录\n#进入MongoDBmongo#查看数据库，结果为空，因为没有身份验证show dbs\n\n通过超级管理员登录：\n\n方式一：mongo IP地址:端口/数据库 -u 用户名 -p 密码\n#默认端口：27017mongo 127.0.0.1:27017/admin -u admin -p 123456#即可查看数据库show dbs\n\n方式二：\n#先进入mongo#使用数据库use admin#登录(输出1：表示成功)db.auth(&#x27;admin&#x27;,&#x27;123456&#x27;)\n\n创建其他角色#角色种类超级用户角色:root数据库用户角色：read,readWrite数据库管理角色:dbAdmin,userAdmin集群管理角色:clusterAdmin、clusterManager、clusterMontitor、hostManager;备份恢复角色:backup、restore;所有数据库角色:readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase#角色说明root：只在admin数据库中可用。超级账号，超级权限read：允许用户读取指定数据库readWrite：允许用户读写指定数据库dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除、查看统计或访问system.profile\n\n例：创建角色test1可以读写test1数据库\nuse test1db.createUser(&#123;\tuser:&#x27;test1&#x27;,\tpwd:&#x27;test1&#x27;,\troles:[&#123;\t\trole:&#x27;readWrite&#x27;,\t\tdb:&#x27;test1&#x27;\t&#125;]&#125;)#注：创建的角色信息存在admin数据库下的system.usersuse admindb.system.users.find().pretty()\n\n退出，并登录为test1后，只能读写test1数据库\n\n\n备份还原安装MongoDB Database Tools下载地址\n选择zip进行下载，解压后将bin目录下的内容复制到MongoDB/bin下即可\nmongodump(备份)语法：\n# 导出数据mongodump -h -port -u -p -d -o# 说明# -h\thost \t服务器IP地址(一般不写 默认本机)# -port\t\t \t端口(一般不写 默认27017)# -u\tuser \t账号# -p \tpwd\t \t密码# -d\tdatabase数据库(注意：数据库不写则导出全局)# -o\topen\t备份到指定目录下\n\n备份所有数据：\n# MongoDB/bin下执行，需新建一个备份目录（bak）mongodump -u admin -p 123456 -o D:\\MongoDB\\bak\n\n备份指定数据：\nmongodump -u test1 -p test1 -d test1 -o D:\\MongoDB\\bak2# 注：超级管理员只能备份全部数据库，不能备份单个数据库\n\nmongoerstore（还原）语法：\nmongorestore -h -port -u -p -d --drop 备份数据目录#说明:# -d\t\t不写则还原全部数据库# --drop\t表示先删除数据库再导入\n\n还原所有数据库\nmongorestore -u admin -p 123456 --drop D:\\MongoDB\\bak\n\n还原指定数据库\nmongorestore -u test1 -p test1 -d test1 --drop D:\\MongoDB\\bak2\\test1\n\nmongoose是Node中提供的用来操作MongoDB的模块\nmongoose文档\n安装:\nyarn add mongoose或npm i mongoose\n\n使用：（js文件，node命令运行）\n//导入mongoose const mongoose = require(&#x27;mongoose&#x27;)//连接数据库(参数1：url，参数2：options，参数3：回调函数)const db = mongoose.connect(&#x27;mongodb://admin:123456@localhost/admin&#x27;, &#123;&#125;, error =&gt; &#123;  if (error) &#123;    console.log(&#x27;error:&#x27; + error)  &#125; else &#123;    console.log(&#x27;ok&#x27;)  &#125;&#125;)\n\nSchemaMongoose 的一切始于 Schema。每个 schema 都会映射到一个 MongoDB 集合，并定义这个集合里的文档的构成。\nconst Schema = mongoose.Schema;const mySchema = new Schema(&#123;  name: String,  age: Number,  date: &#123;type: Date, default: Date.now()&#125; //date字段的数据类型是Date，默认值为Date.now&#125;);\n\n允许使用的 SchemaTypes 有:\n\nString\nNumber\nDate\nBuffer\nBoolean\nMixed\nObjectId\nArray\n\nModelModel是从 Schema 编译来的构造函数。 它们的实例就代表着可以从数据库保存和读取的 documents（文档）。 从数据库创建和读取 document 的所有操作都是通过 model 进行的。\n//参数1：集合名（不是s结尾会自动加上s）const model = mongoose.model(&#x27;user&#x27;, mySchema)\n\n添加数据：\nconst insertObj = new model(&#123;  name: &#x27;罗小黑&#x27;,  age: 8&#125;)insertObj.save().then(res =&gt; &#123;  console.log(res)&#125;)\n\n查询数据：\n//查询一条model.findOne(&#123;age: 8&#125;).then(res =&gt; &#123;  console.log(res)&#125;)//查询所有model.find(&#123;age: 8&#125;).then(res =&gt; &#123;  console.log(res)&#125;)//跳过和分页model.find(&#123;age: 8&#125;).skip(1).limit(1).then(res =&gt; &#123;  console.log(res)&#125;)\n\n接口接口就是一个文件（js&#x2F;json&#x2F;php等），主要响应JSON数据或XML数据。\n推荐的JSON数据格式：\n&#123;\tmeta:&#123;\t\tstatus:状态码,\t\tmsg:&#x27;提示信息&#x27;\t&#125;,\tdata:数据&#125;\n\n接口开发规范（Restful API）Restful API：提供了接口设计规则和约束条件（一个规范），统一开发标准，便于团队协作。\n举例：\n列表页:访问-/模块名\t\t\t\t (get)详情页:访问-/模块名/编号\t\t\t(get)添加页:访问-/模块名/create\t\t (get)处理:访问-/模块名\t\t\t\t  (post)修改页:访问-/模块名/编号/edit\t\t(get)处理:访问-/模块名/编号\t\t\t (put)删除:访问-/模块名/编号\t\t\t(delete)HTTP动词: get、post、put、delete\n\n接口开发使用express框架：\nyarn add express\n\n新建http.js\nconst express = require(&#x27;express&#x27;)const app = express()app.listen(3000,()=&gt;&#123;  console.log(&#x27;http://localhost:3000&#x27;)&#125;)app.get(&#x27;/&#x27;,((req, res) =&gt; &#123;  res.send(&#x27;hello!&#x27;)&#125;))\n\n实战练习编写学生添加接口：\n新建models/stu.js:(操作数据库)\nconst mongoose = require(&#x27;mongoose&#x27;)mongoose.connect(&#x27;mongodb://test1:test1@localhost/test1&#x27;, &#123;&#125;, error =&gt; &#123;  if (error) &#123;    console.log(&#x27;数据库连接失败:&#x27; + error)  &#125; else &#123;    console.log(&#x27;数据库连接成功&#x27;)  &#125;&#125;)const Schema = mongoose.Schema;const mySchema = new Schema(&#123;  name: String,  age: Number,  sex: String&#125;);const model = mongoose.model(&#x27;stu&#x27;, mySchema)//添加学生const insert = (data) =&gt; &#123;  const obj = new model(data)  return obj.save().then(res =&gt; &#123;    console.log(&#x27;添加数据成功&#x27;)    return res  &#125;, err =&gt; &#123;    console.log(&#x27;添加数据失败：&#x27; + err)  &#125;)&#125;//获取学生列表const findStus = (skip,limit) =&gt; &#123;  return model.find().skip(skip).limit(limit).then(res =&gt; &#123;    console.log(&#x27;获取数据成功&#x27;)    return res  &#125;, err =&gt; &#123;    console.log(&#x27;获取数据失败：&#x27; + err)  &#125;)&#125;module.exports = &#123;  insert,findStus&#125;\n\n新建constroller/stu.js:(业务逻辑)\nconst path = require(&#x27;path&#x27;)const &#123;insert, findStus&#125; = require(path.resolve(__dirname, &#x27;../models/stu&#x27;))//添加学生const create = async (req, res) =&gt; &#123;  const data = req.body  const result = await insert(data)  if (result) &#123;    res.send(&#123;      meta: &#123;        status: 200,        msg: &#x27;ok&#x27;      &#125;,      data: result    &#125;)  &#125; else &#123;    res.send(&#123;      meta: &#123;        status: 500,        msg: &#x27;error&#x27;      &#125;    &#125;)  &#125;&#125;//获取学生列表const getStus = async (req, res) =&gt; &#123;  const &#123;pageno, pagesize&#125; = req.query //获取页数和每页显示的数量  const result = await findStus((pageno - 1) * pagesize, pagesize)  if (result) &#123;    res.send(&#123;      meta: &#123;        status: 200,        msg: &#x27;ok&#x27;      &#125;,      data: result    &#125;)  &#125; else &#123;    res.send(&#123;      meta: &#123;        status: 500,        msg: &#x27;error&#x27;      &#125;    &#125;)  &#125;&#125;module.exports = &#123;  create,  getStus&#125;\n\n安装body-parser：（在 Express 中没有内置获取表单 POST 请求体的 API , 我们需要添加第三方插件库）\nyarn add body-parser\n\nhttp.js:\nconst express = require(&#x27;express&#x27;)const path = require(&#x27;path&#x27;)const bodyParser = require(&#x27;body-parser&#x27;)const app = express()//配置 body-parser 中间件 (插件, 专门用来解析表单 POST 请求)// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded(&#123;extended: false&#125;))//parse application/jsonapp.use(bodyParser.json())app.listen(3000, () =&gt; &#123;  console.log(&#x27;http://localhost:3000&#x27;)&#125;)app.get(&#x27;/&#x27;, ((req, res) =&gt; &#123;  res.send(&#x27;hello!&#x27;)&#125;))//绝对路径const stu = require(path.resolve(__dirname, &#x27;controller/stu&#x27;))//添加学生app.post(&#x27;/stu&#x27;, stu.create)//获取学生列表app.get(&#x27;/stu&#x27;,stu.getStus)\n\n使用接口调试工具（postman等）进行测试\n接口文档（apiDoc）apiDoc文档\napiDoc是node的一个模块，能够根据注释快速生成接口文档。\n全局安装：\nnpm i apidoc -g\n\n项目根目录新建apidoc.json：\n&#123;  &quot;name&quot;: &quot;接口文档名&quot;,  &quot;version&quot;: &quot;0.1.0&quot;,  &quot;description&quot;: &quot;接口文档描述&quot;,  &quot;title&quot;: &quot;Custom apiDoc browser title&quot;,  &quot;url&quot; : &quot;http://loaclhost:3000&quot;&#125;\n\n编写注释：（在实现业务逻辑的函数前写注释）\n/** * @api &#123;get&#125; /user   学生列表 * @apiName GetUser * @apiGroup User * * @apiParam &#123;Number&#125; pageno     获取第几页 * @apiParam &#123;Number&#125; pagesize   每页显示条数 * * @apiSuccess &#123;Object&#125; meta 状态码&amp;提示 * @apiSuccess &#123;Array&#125; data  数据 */\n\n生成接口文档：apidoc -i 接口注释所在目录 -o 接口文档生成目录\napidoc -i ./controller -o ./apidoc# 根目录执行\n\n生成apidoc目录，该目录下的index.html即为接口文档\n参考视频\n","categories":["MongoDB","Node"],"tags":["MongoDB","mongoose","express","apiDoc"]},{"title":"手写flat","url":"/2022/04/18/%E6%89%8B%E5%86%99flat/","content":"手写flat（数组扁平化）Array.prototype._flat=function (depth=1)&#123;  function flatten(arr,depth)&#123;    if(depth&lt;=0) return [...arr]    return arr.reduce((pre,cur)=&gt;&#123;      if (Array.isArray(cur)) pre.push(...flatten(cur,depth-1)) //是数组，递归      else pre.push(cur) //不是数组，直接加入pre      return pre    &#125;,[])  &#125;  return flatten(this,depth)&#125;\n\nconst arr=[1,[2,3],[4,[5,6]],7]console.log(arr._flat()) //[1, 2, 3, 4, [5, 6], 7]console.log(arr._flat(1)) //[1, 2, 3, 4, [5, 6], 7]console.log(arr._flat(2)) //[1, 2, 3, 4, 5, 6, 7]console.log(arr._flat(Infinity)) //[1, 2, 3, 4, 5, 6, 7]\n\n代码简化：\nArray.prototype._flat = function (depth = 1) &#123;  function flatten(arr, depth) &#123;    return depth &lt;= 0 ?        [...arr] : arr.reduce((pre, cur) =&gt; Array.isArray(cur) ?            [...pre, ...flatten(cur, depth - 1)] : [...pre, cur], [])  &#125;  return flatten(this, depth)&#125;\n\n\n\n参考视频\n","categories":["JavaScript","手写"],"tags":["flat"]},{"title":"vue3使用tsx","url":"/2022/04/29/vue3%E4%BD%BF%E7%94%A8tsx/","content":"技术栈vue3+ts+vite\n安装@vitejs&#x2F;plugin-vue-jsxnpm i @vitejs/plugin-vue-jsx -D\n\n使用vite.config.ts中导入：\nimport &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import vueJsx from &#x27;@vitejs/plugin-vue-jsx&#x27;;export default defineConfig(&#123;  plugins: [vue(),vueJsx()]&#125;)\n\n修改tsconfig.json:（添加jsxFactory和jsxFragmentFactory）\n&#123;  &quot;compilerOptions&quot;: &#123;    &quot;jsx&quot;: &quot;preserve&quot;,    &quot;jsxFactory&quot;: &quot;h&quot;,    &quot;jsxFragmentFactory&quot;: &quot;Fragment&quot;,  &#125;,&#125;\n\ntsxsrc目录内新建tsx文件：（如：App.tsx）\nconst renderDom = () =&gt; &#123;  return (      &lt;div&gt;        hello,tsx!      &lt;/div&gt;  )&#125;export default renderDom\n\n在.vue文件中导入并使用：\n&lt;template&gt;  &lt;renderDom&gt;&lt;/renderDom&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import renderDom from &quot;./App.tsx&quot;; //导入后当成组件使用即可&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n\n展示数据变量写在单个花括号内，展示ref对象的值需要加上.value\nimport &#123;ref, Ref&#125; from &quot;vue&quot;;const text: Ref&lt;string&gt; = ref(&#x27;&#x27;)const renderDom = () =&gt; &#123;  return (      &lt;div&gt;        &lt;input type=&quot;text&quot; v-model=&#123;text.value&#125;/&gt;        &lt;span&gt;&#123;text.value&#125;&lt;/span&gt;      &lt;/div&gt;  )&#125;export default renderDom\n\nv-show和v-iftsx支持v-show，不支持v-if\n要想实现v-if的效果，需使用编程的方法\nlet flag = falseconst renderDom = () =&gt; &#123;  return (      &lt;div&gt;        &#123; flag ? &lt;div&gt;罗小黑&lt;/div&gt; : &lt;div&gt;罗小白&lt;/div&gt;&#125;      &lt;/div&gt;  )&#125;export default renderDom\n\nv-for使用Array.map()\nconst arr = [1,2,3,4]const renderDom = () =&gt; &#123;  return (      &lt;div&gt;        &#123; arr.map(item =&gt; &#123;          return &lt;div&gt;$&#123;item&#125;&lt;/div&gt;        &#125;) &#125;      &lt;/div&gt;  )&#125;export default renderDom\n\nv-bind和v-ontsx不支持v-bind和v-on\n绑定数据直接使用即可\n绑定事件使用onXXX（如onClick）即可，函数传参使用bind，不能使用事件修饰符（需自己使用js实现）\nconst arr = [1, 2, 3, 4]const clickEvent = (item: number) =&gt; &#123;  console.log(`点击了第$&#123;item&#125;个`)&#125;const renderDom = () =&gt; &#123;  return (      &lt;div&gt;        &#123;arr.map(item =&gt; &#123;          return &lt;div data-num=&#123;item&#125; onClick=&#123;clickEvent.bind(this, item)&#125;&gt;$&#123;item&#125;&lt;/div&gt;        &#125;)&#125;      &lt;/div&gt;  )&#125;export default renderDom\n\n接收props参数和emit&lt;template&gt;\t&lt;renderDom title=&quot;这是标题&quot; @getNum=&quot;getNum&quot;&gt;&lt;/renderDom&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import renderDom from &quot;./App.tsx&quot;; //导入后当成组件使用即可    const getNum = (num: number) =&gt; &#123;  console.log(num)&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n\ninterface Props &#123;  title: string&#125;const clickEvent = (ctx: any) =&gt; &#123;  ctx.emit(&#x27;getNum&#x27;, 20)&#125;const renderDom = (props: Props, ctx: any) =&gt; &#123;  return (      &lt;div&gt;        &lt;div&gt;&#123;props.title&#125;&lt;/div&gt;        &lt;button onClick=&#123;clickEvent.bind(this,ctx)&#125;&gt;按钮&lt;/button&gt;      &lt;/div&gt;  )&#125;export default renderDom\n\n\n\n参考视频\n","categories":["vue3"],"tags":["vue3","tsx","vite","jsx"]},{"title":"vue3使用router","url":"/2022/05/02/vue3%E4%BD%BF%E7%94%A8router/","content":"初始化vue3项目npm init vite@latest\n\n使用vue+ts\nvue-router基本使用安装vue-routernpm i vue-router\n\n基本使用新建src/index.ts:\nimport &#123;createRouter, createWebHashHistory, createWebHistory, RouteRecordRaw&#125; from &quot;vue-router&quot;;const routes: RouteRecordRaw[] = [  &#123;    path: &#x27;/&#x27;,    component: () =&gt; import(&#x27;../components/Login.vue&#x27;)  &#125;,  &#123;    path:&#x27;/reg&#x27;,    component: ()=&gt; import(&#x27;../components/Register.vue&#x27;)  &#125;]export default createRouter(&#123;  history: createWebHistory(), //路由模式  routes&#125;)\n\nmain.ts中导入：\nimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import Router from &#x27;./router/index&#x27;createApp(App).use(Router).mount(&#x27;#app&#x27;)\n\nrouter-view和router-linkApp.vue中：\n&lt;template&gt;  &lt;router-link to=&quot;/&quot;&gt;登录&lt;/router-link&gt;  &lt;router-link to=&quot;/reg&quot;&gt;注册&lt;/router-link&gt;  &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;&lt;/script&gt;\n\n路由模式vue2使用mode设置路由模式，vue3改为history\n对应关系：\n\n\n\nvue2\nvue3\n\n\n\nhistory\ncreateWebHistory\n\n\nhash\ncreateWebHashHistory\n\n\nabstact\ncreateMemoryHistory\n\n\nhash原理//获取当前hash值location.hash //输出：&#x27;#/&#x27;//设置hash值location.hash = &#x27;/reg&#x27; //或者&#x27;#/reg&#x27;\n\n通过onhashchange监听hash的变化:\nwindow.addEventListener(&#x27;hashchange&#x27;,(event)=&gt;&#123; //hash发生变化时触发\tconsole.log(event) //HashChangeEvent对象（包含很多属性，比如：newURL、oldURL等）&#125;)\n\nhistory原理通过onpopstate监听url的变化:\nwindow.addEventListener(&#x27;popstate&#x27;,(event)=&gt;&#123; //路径发生变化时触发\tconsole.log(event) //PopStateEvent对象（其中的state属性就包含路径信息）&#125;)\n\nhistory.state //&#123;back: &#x27;/reg&#x27;, current: &#x27;/&#x27;, forward: &#x27;/reg&#x27;, replaced: false, position: NaN, …&#125;history.pushState(&#123;&#125;,&#x27;&#x27;,&#x27;/reg&#x27;) //此方法只会改变当前地址栏的路径，并不会更新页面内容//需要在Javascript代码中调用history.back()或用户点击浏览器的回退按钮\n\n","categories":["vue3"],"tags":["vue3","router","vue-router"]}]