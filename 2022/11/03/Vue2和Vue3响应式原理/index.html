<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="灵感胜于汗水">
    
    <title>
        
            Vue2和Vue3响应式原理 |
        
        灵感胜于汗水
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/cjhsyc/image-hosting@master/头像.677yiujw5980.webp">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"cjhsyc.github.io","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"https://cdn.jsdelivr.net/gh/cjhsyc/image-hosting@master/头像.677yiujw5980.webp","favicon":"https://cdn.jsdelivr.net/gh/cjhsyc/image-hosting@master/头像.677yiujw5980.webp","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"https://cdn.jsdelivr.net/gh/cjhsyc/image-hosting@master/罗小黑战记.2g12vx9z84u8.webp","description":null},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                灵感胜于汗水
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Vue2和Vue3响应式原理</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="https://cdn.jsdelivr.net/gh/cjhsyc/image-hosting@master/%E5%A4%B4%E5%83%8F.677yiujw5980.webp">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">灵感胜于汗水</span>
                        
                            <span class="author-label">Lv5</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-11-03 13:24:53</span>
        <span class="mobile">2022-11-03 13:24</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/vue/">vue</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/vue/">vue</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>5.2k 字</span>
        </span>
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="Vue2-的响应式原理"><a href="#Vue2-的响应式原理" class="headerlink" title="Vue2 的响应式原理"></a>Vue2 的响应式原理</h1><p>所谓响应式就是首先建立响应式数据和依赖之间的关系，当这些响应式数据发生变化的时候，可以通知那些绑定这些数据的依赖进行相关操作，可以是 DOM 更新，也可以是执行一个回调函数。</p>
<p><code>vue2</code> 的对象数据是通过 <code>Object.defineProperty</code> 对每个属性进行监听，当对属性进行读取的时候，就会触发 getter，对属性进行设置的时候，就会触发 setter。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这里的函数 defineReactive 用来对 Object.defineProperty 进行封装。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">data, key, val</span>) &#123;</span><br><span class="line">   <span class="comment">// 依赖存储的地方</span></span><br><span class="line">   <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">   <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, key, &#123;</span><br><span class="line">       <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">       <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">       <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">           <span class="comment">// 在 getter 中收集依赖</span></span><br><span class="line">           dep.<span class="title function_">depend</span>()</span><br><span class="line">           <span class="keyword">return</span> val</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">           val = newVal</span><br><span class="line">           <span class="comment">// 在 setter 中触发依赖</span></span><br><span class="line">           dep.<span class="title function_">notify</span>()</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Watcher 里面进行属性读取，Watcher 也就是所谓的依赖。在 Watcher 里面读取数据的时候，会把自己设置到一个<strong>全局的变量</strong>中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 我们所讲的依赖其实就是 Watcher，我们要通知用到数据的地方，而使用这个数据的地方有很多，类型也不一样，有可能是组件的，有可能是用户写的 watch，我们就需要抽象出一个能集中处理这些情况的类。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">vm, exp, cb</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getter</span> = exp</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cb</span> = cb</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span></span><br><span class="line">        <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, <span class="variable language_">this</span>.<span class="property">vm</span>)</span><br><span class="line">        <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">undefined</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cb</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, <span class="variable language_">this</span>.<span class="property">value</span>, oldValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Watcher 读取数据的时候也就触发了这个属性的监听 getter，在 getter 里面就需要进行依赖收集，这些依赖存储的地方就叫 <code>Dep</code>，在 <code>Dep</code> 里面就可以把<strong>全局变量中的依赖</strong>进行收集，收集完毕就会把<strong>全局依赖变量</strong>设置为空。将来数据发生变化的时候，就去 <code>Dep</code> 中把相关的 Watcher 拿出来执行一遍。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 我们把依赖收集的代码封装成一个 Dep 类，它专门帮助我们管理依赖。</span></span><br><span class="line"><span class="comment">* 使用这个类，我们可以收集依赖、删除依赖或者向依赖发送通知等。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span> = []</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">addSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">removeSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">        <span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">subs</span>, sub)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Dep</span>.<span class="property">target</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">addSub</span>(<span class="title class_">Dep</span>.<span class="property">target</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">slice</span>()</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">            subs[i].<span class="title function_">update</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除依赖</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">remove</span>(<span class="params">arr, item</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = arr.<span class="title function_">indexOf</span>(item)</span><br><span class="line">        <span class="keyword">if</span>(index &gt; -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr.<span class="title function_">splice</span>(index, <span class="number">1</span>)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说就是通过 <code>Object.defineProperty</code> 监听对象的每一个属性，当读取数据时会触发 getter，修改数据时会触发 setter。</p>
<p>然后我们在 getter 中进行依赖收集，当 setter 被触发的时候，就去把在 getter 中收集到的依赖拿出来进行相关操作，通常是执行一个回调函数。</p>
<p>我们收集依赖需要进行存储，对此 <code>Vue2</code> 中设置了一个 <code>Dep</code> 类，相当于一个管家，负责添加或删除相关的依赖和通知相关的依赖进行相关操作。</p>
<p>在 <code>Vue2</code> 中所谓的依赖就是 Watcher。值得注意的是，只有 Watcher 触发的 getter 才会进行依赖收集，哪个 Watcher 触发了 getter，就把哪个 Watcher 收集到 <code>Dep</code> 中。当响应式数据发生改变的时候，就会把收集到的 Watcher 都进行通知。</p>
<h2 id="响应式对象"><a href="#响应式对象" class="headerlink" title="响应式对象"></a>响应式对象</h2><p>由于 <code>Object.defineProperty</code> 只会对属性进行监测，而不会对对象进行监测，所以 <code>Vue2</code> 中设置了一个 Observer 类来管理对象的响应式依赖，同时也会递归侦测对象中子数据的变化。Observer 类的作用就是把一个对象全部转换成响应式对象，包括子属性数据，当对象新增或删除属性的时候负债通知对应的 Watcher 进行更新操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个属性</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">def</span>(<span class="params">obj, key, val, enumerable</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="attr">value</span>: val,</span><br><span class="line">        <span class="attr">enumerable</span>: !!enumerable,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">        <span class="comment">// 添加一个对象依赖收集的选项</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dep</span> = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">        <span class="comment">// 给响应式对象添加 __ob__ 属性，表明这是一个响应式对象</span></span><br><span class="line">        <span class="title function_">def</span>(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="variable language_">this</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">           </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">walk</span>(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">walk</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line">        <span class="comment">// 遍历对象的属性进行响应式设置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i ++) &#123;</span><br><span class="line">            <span class="title function_">defineReactive</span>(obj, keys[i], obj[keys[i]])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vm-set"><a href="#vm-set" class="headerlink" title="vm.$set"></a>vm.$set</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">target, key, val</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ob = target.<span class="property">__ob__</span></span><br><span class="line">    <span class="title function_">defineReactive</span>(ob.<span class="property">value</span>, key, val)</span><br><span class="line">    ob.<span class="property">dep</span>.<span class="title function_">notify</span>()</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当向一个响应式对象新增属性的时候，需要对这个属性重新进行响应式的设置，即使用 <code>defineReactive</code> 将新增的属性转换成 getter&#x2F;setter。</p>
<p>我们在前面讲过每一个对象是会通过 Observer 类型进行包装的，并在 Observer 类里面创建一个属于这个对象的依赖收集存储对象 <code>dep</code>， 最后在新增属性的时候就通过这个依赖对象进行通知相关 Watcher 进行变化更新。</p>
<h2 id="vm-delete"><a href="#vm-delete" class="headerlink" title="vm.$delete"></a>vm.$delete</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">del</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ob = target.<span class="property">__ob__</span></span><br><span class="line">    <span class="keyword">delete</span> target[key]</span><br><span class="line">    ob.<span class="property">dep</span>.<span class="title function_">notify</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>vm.$delete</code> 的实现原理和 <code>vm.$set</code> 的实现原理是非常相似的。</p>
<p>通过  <code>vm.$delete</code> 和 <code>vm.$set</code> 的实现原理，我们可以更加清晰地理解到 Observer 类的作用，Observer 类就是给一个对象也进行一个监测，因为 <code>Object.defineProperty</code> 是无法实现对对象的监测的，但这个监测是手动，不是自动的。</p>
<h2 id="监听数组的变化"><a href="#监听数组的变化" class="headerlink" title="监听数组的变化"></a>监听数组的变化</h2><p><code>Vue2</code> 对数组的监测是通过重写数组原型上的 7 个方法来实现的，但其实 <code>Object.defineProperty</code> 是可以监听数组的变化的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(arr, index, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;监听到了&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;变化了：&#x27;</span>, val, newVal)</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其实数组就是一个特殊的对象，它的下标就可以看作是它的 key。</p>
<p>所以 <code>Object.defineProperty</code> 也能监听数组变化，那么为什么 <code>Vue2</code> 弃用了这个方案呢？</p>
<p>首先这种直接通过下标获取数组元素的场景就比较少，其次即便通过了 <code>Object.defineProperty</code> 对数组进行监听，但也监听不了 push、pop、shift 等对数组进行操作的方法，所以还是需要通过对数组原型上的那 7 个方法进行重写监听。所以为了性能考虑 <code>Vue2</code> 直接弃用了使用 <code>Object.defineProperty</code> 对数组进行监听的方案。</p>
<p><code>Vue2</code>使用拦截器覆盖 <code>Array.prototype</code>，之后再去使用 Array 原型上的方法的时候，其实使用的是拦截器提供的方法，在拦截器里面才真正使用原生 Array 原型上的方法去操作数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拦截器其实就是一个和 Array.prototype 一样的对象。</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="keyword">const</span> arrayMethods = <span class="title class_">Object</span>.<span class="title function_">create</span>(arrayProto)</span><br><span class="line">;[</span><br><span class="line">    <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">].<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">method</span>) &#123;</span><br><span class="line">    <span class="comment">// 缓存原始方法</span></span><br><span class="line">    <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(arrayMethods, method, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="keyword">function</span> <span class="title function_">mutator</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">            <span class="comment">// 最终还是使用原生的 Array 原型方法去操作数组</span></span><br><span class="line">            <span class="keyword">const</span> result = original.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">            <span class="comment">// 获取 Observer 对象实例</span></span><br><span class="line">            <span class="keyword">const</span> ob = <span class="variable language_">this</span>.<span class="property">__ob__</span></span><br><span class="line">            <span class="comment">// 通过 Observer 对象实例上 Dep 实例对象去通知依赖进行更新</span></span><br><span class="line">            ob.<span class="property">dep</span>.<span class="title function_">notify</span>()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">eumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>所以通过拦截器之后，我们就可以追踪到数组的变化了，然后就可以在拦截器里面进行依赖收集和触发依赖了。</p>
<p>接下来我们就使用拦截器覆盖那些进行了响应式处理的 Array 原型，数组也是一个对象，通过上文我们可以知道 <code>Vue2</code> 是在 Observer 类里面对对象的进行响应式处理，并且给对象也进行一个依赖收集。所以对数组的依赖处理也是在 Observer 类里面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">        <span class="comment">// 添加一个对象依赖收集的选项</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dep</span> = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">        <span class="comment">// 给响应式对象添加 __ob__ 属性，表明这是一个响应式对象</span></span><br><span class="line">        <span class="title function_">def</span>(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="variable language_">this</span>)</span><br><span class="line">        <span class="comment">// 如果是数组则通过覆盖数组的原型方法进来拦截操作</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">          value.<span class="property">__proto__</span> = arrayMethods </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">walk</span>(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>Vue2</code> 的实现方法决定了在 <code>Vue2</code> 中对数组的一些操作无法实现响应式操作，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">list</span>[<span class="number">0</span>] = xxx</span><br></pre></td></tr></table></figure>

<p>由于 <code>Vue2</code> 放弃了 <code>Object.defineProperty</code> 对数组进行监听的方案，所以通过下标操作数组是无法实现响应式操作的。</p>
<p>又例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这个动作在 <code>Vue2</code> 中也是无法实现响应式操作的。</p>
<h1 id="Vue3-的响应式原理"><a href="#Vue3-的响应式原理" class="headerlink" title="Vue3 的响应式原理"></a>Vue3 的响应式原理</h1><p><code>Vue3</code> 是通过 Proxy 对数据实现 getter&#x2F;setter 代理，从而实现响应式数据，然后在副作用函数中读取响应式数据的时候，就会触发 Proxy 的 getter，在 getter 里面把对当前的副作用函数保存起来，将来对应响应式数据发生更改的话，则把之前保存起来的副作用函数取出来执行。</p>
<p>具体是副作用函数里面读取响应式对象的属性值时，会触发代理对象的 getter，然后在 getter 里面进行一定规则的依赖收集保存操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一个全局变量存储被注册的副作用函数</span></span><br><span class="line"><span class="keyword">let</span> activeEffect</span><br><span class="line"><span class="comment">// 注册副作用函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    activeEffect = fn</span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">    <span class="comment">// getter 拦截读取操作</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">        <span class="comment">// 将副作用函数 activeEffect 添加到存储副作用函数的全局变量 targetMap 中</span></span><br><span class="line">        <span class="title function_">track</span>(target, key)</span><br><span class="line">        <span class="comment">// 返回读取的属性值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter 拦截设置操作</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, val</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置属性值</span></span><br><span class="line">        <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, val)</span><br><span class="line">        <span class="comment">// 把之前存储的副作用函数取出来并执行</span></span><br><span class="line">        <span class="title function_">trigger</span>(target, key)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 存储副作用函数的全局变量</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="comment">// 在 getter 拦截器内追踪依赖的变化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有 activeEffect，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(!activeEffect) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 根据 target 从全局变量 targetMap 中获取 depsMap</span></span><br><span class="line">    <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">    <span class="keyword">if</span>(!depsMap) &#123;</span><br><span class="line">       <span class="comment">// 如果 depsMap 不存，那么需要新建一个 Map 并且与 target 关联</span></span><br><span class="line">       depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">       targetMap.<span class="title function_">set</span>(target, depsMap)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再根据 key 从 depsMap 中取得 deps, deps 里面存储的是所有与当前 key 相关联的副作用函数</span></span><br><span class="line">    <span class="keyword">let</span> deps = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">    <span class="keyword">if</span>(!deps) &#123;</span><br><span class="line">       <span class="comment">// 如果 deps 不存在，那么需要新建一个 Set 并且与 key 关联</span></span><br><span class="line">       deps = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">       depsMap.<span class="title function_">set</span>(key, deps)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前的活动的副作用函数保存起来</span></span><br><span class="line">    deps.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 setter 拦截器中触发相关依赖</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trgger</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据 target 从全局变量 targetMap 中取出 depsMap</span></span><br><span class="line">    <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">    <span class="keyword">if</span>(!depsMap) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 根据 key 取出相关联的所有副作用函数</span></span><br><span class="line">    <span class="keyword">const</span> effects = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">    <span class="comment">// 执行所有的副作用函数</span></span><br><span class="line">    effects &amp;&amp; effects.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码我们可以知道 <code>Vue3</code> 中依赖收集的规则，首先把响应式对象作为 key，一个 Map 的实例做为值方式存储在一个 <code>WeakMap</code> 的实例中，其中这个 Map 的实例又是以响应式对象的 key 作为 key, 值为一个 Set 的实例。而且这个 Set 的实例中存储的则是跟那个响应式对象 key 相关的副作用函数。</p>
<p><code>WeakMap</code> 可以接受一个对象作为 key 的，而 <code>WeakMap</code> 对 key 是弱引用的。所以当 <code>WeakMap</code> 的 key 是一个对象时，一旦上下文执行完毕，<code>WeakMap</code> 中 key 对象没有被其他代码引用的时候，<strong>垃圾回收器</strong> 就会把该对象从内存移除，我们就无法该对象从 <code>WeakMap</code> 中获取内容了。</p>
<p>另外副作用函数使用 <code>Set</code> 类型，是因为 <code>Set</code> 类型能自动去除重复内容。</p>
<p>上述方法只实现了对引用类型的响应式处理，因为 Proxy 的代理目标必须是非原始值。在 JavaScript 中，原始值是按值传递的，而非按引用传递。这意味着，如果一个函数接收原始值作为参数，那么形参与实参之间没有引用关系，它们是两个完全独立的值，对形参的修改不会影响实参。</p>
<p><code>Vue3</code> 中是通过对原始值做了一层包裹的方式来实现对原始值变成响应式数据的。最新的 <code>Vue3</code> 实现方式是通过属性访问器 getter&#x2F;setter 来实现的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span>&#123;</span><br><span class="line">    private _value</span><br><span class="line">    public dep</span><br><span class="line">    <span class="comment">// 表示这是一个 Ref 类型的响应式数据</span></span><br><span class="line">    private _v_isRef = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_value</span> = value</span><br><span class="line">        <span class="comment">// 依赖存储</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dep</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// getter 访问拦截</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">        <span class="comment">// 依赖收集</span></span><br><span class="line">        <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// setter 设置拦截</span></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_value</span> = newVal</span><br><span class="line">        <span class="comment">// 触发依赖</span></span><br><span class="line">        <span class="title function_">triggerEffect</span>(<span class="variable language_">this</span>.<span class="property">dep</span>)   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ref 本质上是一个实例化之后的 “包裹对象”，因为 Proxy 无法提供对原始值的代理，所以我们需要使用一层对象作为包裹，间接实现原始值的响应式方案。 由于实例化之后的 “包裹对象” 本质与普通对象没有任何区别，所以为了区分 ref 与 Proxy 响应式对象，我们需要给 ref 的实例对象定义一个 _v_isRef 的标识，表明这是一个 ref 的响应式对象。</p>
<h2 id="与Vue2比较"><a href="#与Vue2比较" class="headerlink" title="与Vue2比较"></a>与Vue2比较</h2><p><code>Vue2</code> 的响应式存在很多的问题，例如：</p>
<ul>
<li>初始化时需要遍历对象所有 key，如果对象层次较深，性能不好</li>
<li>通知更新过程需要维护大量 dep 实例和 watcher 实例，额外占用内存较多</li>
<li>无法监听到数组元素的变化，只能通过劫持重写了几个数组方法</li>
<li>动态新增，删除对象属性无法拦截，只能用特定 <code>set/delete API</code> 代替</li>
<li>不支持 Map、Set 等数据结构</li>
</ul>
<p>而 <code>Vue3</code> 使用 Proxy 实现之后，则以上的问题都不存在了。</p>
<h2 id="监测数组的变化"><a href="#监测数组的变化" class="headerlink" title="监测数组的变化"></a>监测数组的变化</h2><p><code>Vue2</code> 中是需要对数组的监听进行特殊的处理的，其中在 <code>Vue3</code> 中也需要对数组进行特殊的处理。在 <code>Vue2</code> 是不可以通过数组下标对响应式数组进行设置和读取的，而 <code>Vue3</code> 中是可以的，但数组中仍然有很多其他特别的读取和设置的方法，这些方法没经过特殊处理，是无法通过普通的 Proxy 中的 getter&#x2F;setter 进行响应式处理的。</p>
<p>当数组响应式对象使用 includes、indexOf、lastIndexOf 这方法的时候，它们内部的 this 指向的是代理对象，并且在获取数组元素时得到的值要也是代理对象，所以当使用原始值去数组响应式对象中查找的时候，如果不进行特别的处理，是查找不到的，所以我们需要对上述的数组方法进行重写才能解决这个问题。</p>
<p>首先 <code>arr.indexOf</code> 可以理解为读取响应式对象 arr 的 <code>indexOf</code> 属性，这就会触发 getter 拦截器，在 getter 拦截器内我们就可以判断 target 是否是数组，如果是数组就看读取的属性是否是我们需要重写的属性，如果是，则使用我们重新之后的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayInstrumentations = &#123;&#125;</span><br><span class="line">;([<span class="string">&#x27;includes&#x27;</span>, <span class="string">&#x27;indexOf&#x27;</span>, <span class="string">&#x27;lastIndexOf&#x27;</span>]).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> originMethod = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[key]</span><br><span class="line">  arrayInstrumentations[key] = <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// this 是代理对象，先在代理对象中查找</span></span><br><span class="line">    <span class="keyword">let</span> res = originMethod.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(res === <span class="literal">false</span>) &#123;</span><br><span class="line">       <span class="comment">// 在代理对象中没找到，则去原始数组中查找</span></span><br><span class="line">       res = originMethod.<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">raw</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最终的值</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述重写方法的主要是实现先在代理对象中查找，如果没找到，就去原始数组中查找，结合两次的查找结果才是最终的结果，这样就实现了在代理数组中查找原始值也可以查找到。</p>
<p>在一些数组的方法中除了修改数组的内容之外也会隐式地修改数组的长度。</p>
<p>比如进行 <code>arr.push</code> 的操作触发了 getter 拦截器，并且触发了两次。其中一次就是数组 push 属性的读取，还有一次就是调用 push 方法会间接读取 length 属性，那么问题来了，进行了 length 属性的读取，也就会建立 length 的响应依赖，可 arr.push 本意只是修改操作，并不需要建立 length 属性的响应依赖。所以我们需要 “屏蔽” 对 length 属性的读取，从而避免在它与副作用函数之间建立响应联系。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayInstrumentations = &#123;&#125;</span><br><span class="line"><span class="comment">// 是否允许追踪依赖变化</span></span><br><span class="line"><span class="keyword">let</span> shouldTrack = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 重写数组的 push、pop、shift、unshift、splice 方法</span></span><br><span class="line">;[<span class="string">&#x27;push&#x27;</span>,<span class="string">&#x27;pop&#x27;</span>,<span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 取得原始的数组原型上的方法</span></span><br><span class="line">    <span class="keyword">const</span> originMethod = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[method]</span><br><span class="line">    <span class="comment">// 重写</span></span><br><span class="line">    arrayInstrumentations[method] = <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="comment">// 在调用原始方法之前，禁止追踪</span></span><br><span class="line">        shouldTrack = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 调用数组的默认方法</span></span><br><span class="line">        <span class="keyword">let</span> res = originMethod.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        <span class="comment">// 在调用原始方法之后，恢复允许进行依赖追踪</span></span><br><span class="line">        shouldTrack = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在调用数组的默认方法间接读取 length 属性之前，禁止进行依赖跟踪，这样在间接读取 length 属性时，由于是禁止依赖跟踪的状态，所以 length 属性与副作用函数之间不会建立响应联系。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong><code>Vue2</code> 部分</strong></p>
<p><code>Vue2</code> 是通过 <code>Object.defineProperty</code> 将对象的属性转换成 getter&#x2F;setter 的形式来进行监听它们的变化，当读取属性值的时候会触发 getter 进行依赖收集，当设置对象属性值的时候会触发 setter 进行向相关依赖发送通知，从而进行相关操作。</p>
<p>由于 <code>Object.defineProperty</code> 只对属性 key 进行监听，无法对引用对象进行监听，所以在 <code>Vue2</code> 中创建一个了 Observer 类对整个对象的依赖进行管理，当对响应式对象进行新增或者删除则由响应式对象中的 <code>dep</code> 通知相关依赖进行更新操作。</p>
<p><code>Object.defineProperty</code> 也可以实现对数组的监听的，但因为性能的原因 <code>Vue2</code> 放弃了这种方案，改由重写数组原型对象上的 7 个能操作数组内容的变更的方法，从而实现对数组的响应式监听。</p>
<p><strong><code>Vue3</code> 部分</strong></p>
<p><code>Vue3</code> 则是通过 Proxy 对数据实现 getter&#x2F;setter 代理，从而实现响应式数据，然后在副作用函数中读取响应式数据的时候，就会触发 Proxy 的 getter，在 getter 里面把对当前的副作用函数保存起来，将来对应响应式数据发生更改的话，则把之前保存起来的副作用函数取出来执行。</p>
<p><code>Vue3</code> 对数组实现代理时，用于代理普通对象的大部分代码可以继续使用，但由于对数组的操作与对普通对象的操作存在很多的不同，那么也需要对这些不同的操作实现正确的响应式联系或触发响应。这就需要对数组原型上的一些方法进行重写。</p>
<p>比如通过索引为数组设置新的元素，可能会隐式地修改数组的 length 属性的值。同时如果修改数组的 length 属性的值，也可能会间接影响数组中的已有元素。另外用户通过 includes、indexOf 以及 lastIndexOf 等对数组元素进行查找时，可能是使用代理对象进行查找，也有可能使用原始值进行查找，所以我们就需要重写这些数组的查找方法，从而实现用户的需求。原理很简单，当用户使用这些方法查找元素时，先去响应式对象中查找，如果没找到，则再去原始值中查找。</p>
<p>另外如果使用 push、pop、shift、unshift、splice 这些方法操作响应式数组对象时会间接读取和设置数组的 length 属性，所以我们也需要对这些数组的原型方法进行重新，让当使用这些方法间接读取 length 属性时禁止进行依赖追踪，这样就可以断开 length 属性与副作用函数之间的响应式联系了。</p>
<p>参考：</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://juejin.cn/post/7124351370521477128?share_token=0616d10b-a811-4c7f-a7be-acf037342726" >面试官的步步紧逼：Vue2 和 Vue3 的响应式原理比对<i class="fas fa-external-link-alt"></i></a></p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：Vue2和Vue3响应式原理</li>
        <li>本文作者：灵感胜于汗水</li>
        <li>创建时间：2022-11-03 13:24:53</li>
        <li>
            本文链接：https://cjhsyc.github.io/2022/11/03/Vue2和Vue3响应式原理/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/vue/">#vue</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/11/03/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">响应式布局</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/11/02/WebWorker/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">WebWorker</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2022</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">灵感胜于汗水</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Vue2-%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">Vue2 的响应式原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.</span> <span class="nav-text">响应式对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vm-set"><span class="nav-number">1.2.</span> <span class="nav-text">vm.$set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vm-delete"><span class="nav-number">1.3.</span> <span class="nav-text">vm.$delete</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">1.4.</span> <span class="nav-text">监听数组的变化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Vue3-%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">Vue3 的响应式原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8EVue2%E6%AF%94%E8%BE%83"><span class="nav-number">2.1.</span> <span class="nav-text">与Vue2比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%91%E6%B5%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">2.2.</span> <span class="nav-text">监测数组的变化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
